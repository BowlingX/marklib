{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///site.min.js","webpack:///webpack/bootstrap 6656a6a7d39b9f987870","webpack:///./src/main/modules/Site.js","webpack:///./src/main/modules/Marklib.js","webpack:///./src/main/Rendering.js","webpack:///./src/main/util/Util.js","webpack:///./~/babel-runtime/helpers/interop-require-default.js","webpack:///./~/babel-runtime/core-js/object/define-property.js","webpack:///./~/babel-runtime/helpers/create-class.js","webpack:///./~/babel-runtime/helpers/class-call-check.js","webpack:///./~/babel-runtime/~/core-js/library/fn/object/define-property.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.fw.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_Object$defineProperty","_interopRequireDefault","value","_Marklib","_Marklib2","document","addEventListener","presentRendering","selector","classNames","speed","autoMarkText","getElementById","childNodes","thisLength","length","render","_render","_x","_x2","_x3","apply","arguments","toString","r","Rendering","range","createRange","setStart","setEnd","renderWithRange","parentNode","nextSibling","setTimeout","STORAGE_KEY","savedRanges","JSON","parse","localStorage","getItem","animated","forEach","marker","renderWithPath","startContainerPath","startOffset","endContainerPath","endOffset","e","console","warn","setItem","stringify","window","el","getBoundingClientRect","html","documentElement","top","clientHeight","bottom","classList","add","actionMark","selection","getSelection","renderer","result","getRangeAt","removeAllRanges","push","keyCode","target","elements","getElementsByTagName","i","remove","_Rendering","_Rendering2","_Util","_Util2","Util","global","_createClass","_classCallCheck","TAG_NAME","ATTR_DATA_ORIGINAL_OFFSET_START","DATA_ORIGINAL_TEXT_NODE_INDEX","ATTR_DATA_START_END","ATTR_DATA_IS_HIGHLIGHT_NODE","ATTR_DATA_ID","cssClass","context","Document","guid","undefined","startContainer","endContainer","markerPrefix","markerSuffix","_onWrappedNodeFunc","key","f","createElement","vTrue","className","setAttribute","DATA_IS_SELECTION","getId","text","_createWrapTemplate","textContent","initialNode","prefix","offset","index","wrapper","_createStartEndWrapTemplate","ATTR_DATA_ORIGINAL_INDEX","_getIndexParentIfHas","marklibInstance","optionalLength","optionalIndex","optionalIsSameNode","originalIndex","calcIndex","offsetLength","_getOffsetParentIfHas","wrap","_callOnWrappedNode","originalElement","func","walkDom","node","Node","TEXT_NODE","nodeType","nodeIsEmpty","start","nextParent","nextParentNode","currentParentNode","wrapSiblings","_this","next","found","n","hasAttribute","getAttribute","thisNode","_createWrap","removeAttribute","bind","wrapIf","currentNext","compareDocumentPosition","_walkTextNodes","children","textNode","startIndex","endIndex","initialText","nodeValue","initialIndex","textBefore","slice","insertBefore","createTextNode","previousSibling","_createSplitContainer","textAfter","startContainerIndex","endContainerIndex","fullTextStartValue","startT","partTextStartValue","offsetStart","_createStartOrEndContainer","endT","fullTextEndValue","partTextEndValue","offsetParent","element","lengthElement","parent","parseInt","commonAncestor","withoutResult","outer","parents","contextContainer","originalStartOffset","_findOriginalOffset","originalEndOffset","nextElementSibling","endContainerContents","closest","lastChild","getPath","_renderSelection","_markTextSameNode","_markTextDifferentNode","walk","path","pSplit","split","objectIndex","charOffset","container","querySelector","maybeFoundNode","atrOffsetStart","atrIndex","thisOffset","startPath","endPath","_deserializePath","_renderWithElements","commonAncestorContainer","thisIndex","DATA_PSEUDO","SERIALIZE_SEPARATOR","Element","prototype","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","nodes","Array","filter","s4","Math","floor","random","substring","match","optionalList","indexOf","elms","NodeList","child","cloneNode","sibling","appendChild","calculatedIndex","foundWrapper","maybeIndexOfOriginal","isOriginal","optionalSelector","foundElements","name","outerMostElement","reverse","nodeName","toLowerCase","HTMLElement","siblings","nodeListFilter","nodeIndex","replace","obj","__esModule","default","defineProperties","props","descriptor","enumerable","configurable","writable","Constructor","protoProps","staticProps","instance","TypeError","$","it","desc","setDesc","toInteger","isNaN","ceil","bitmap","simpleSet","object","createDefiner","DESC","isObject","isFunction","assertDefined","self","Function","core","defineProperty","Object","hasOwnProperty","max","min","get","a","hide","g","that","toLength","toIndex","has","create","getProto","getPrototypeOf","getDesc","getOwnPropertyDescriptor","setDescs","getKeys","keys","getNames","getOwnPropertyNames","getSymbols","getOwnPropertySymbols","ES5Object","toObject","def","set","Symbol","mix","src","each","__e","__g","FW"],"mappings":"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","file":"site.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Marklib\"] = factory();\n\telse\n\t\troot[\"Marklib\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Marklib\"] = factory();\n\telse\n\t\troot[\"Marklib\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _Object$defineProperty = __webpack_require__(6)[\"default\"];\n\t\n\tvar _interopRequireDefault = __webpack_require__(5)[\"default\"];\n\t\n\t_Object$defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\t/* global localStorage */\n\t\n\tvar _Marklib = __webpack_require__(2);\n\t\n\tvar _Marklib2 = _interopRequireDefault(_Marklib);\n\t\n\t/**\n\t * Contains Module for the demonstration\n\t */\n\t\n\tdocument.addEventListener(\"DOMContentLoaded\", function () {\n\t    \"use strict\";\n\t\n\t    var STORAGE_KEY = \"savedRanges\";\n\t\n\t    /**\n\t     * Creates an animated rendering\n\t     */\n\t    function presentRendering(selector, classNames, speed) {\n\t        var autoMarkText = document.getElementById(selector).childNodes[0];\n\t        var thisLength = autoMarkText.length;\n\t\n\t        var render = (function (_render) {\n\t            function render(_x, _x2, _x3) {\n\t                return _render.apply(this, arguments);\n\t            }\n\t\n\t            render.toString = function () {\n\t                return _render.toString();\n\t            };\n\t\n\t            return render;\n\t        })(function (autoMarkText, c, length) {\n\t            var r = new _Marklib2[\"default\"].Rendering(document, classNames);\n\t            var range = document.createRange();\n\t            range.setStart(autoMarkText, 0);\n\t            range.setEnd(autoMarkText, 1);\n\t            r.renderWithRange(range, true);\n\t            if (autoMarkText.parentNode.nextSibling) {\n\t                autoMarkText = autoMarkText.parentNode.nextSibling.childNodes[0];\n\t                setTimeout(function () {\n\t                    render(autoMarkText, ++c, length);\n\t                }, speed);\n\t            }\n\t        });\n\t        return render(autoMarkText, 0, thisLength);\n\t    }\n\t\n\t    presentRendering(\"automark\", \"fadeInDown\", 20);\n\t\n\t    var savedRanges = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [],\n\t        animated = false;\n\t\n\t    savedRanges.forEach(function (range) {\n\t        var marker = new _Marklib2[\"default\"].Rendering(document);\n\t        try {\n\t            marker.renderWithPath(range.startContainerPath + \";\" + range.startOffset, range.endContainerPath + \";\" + range.endOffset);\n\t        } catch (e) {\n\t            console.warn(\"Could not render:\", range);\n\t            localStorage.setItem(STORAGE_KEY, JSON.stringify([]));\n\t            throw \"Cleared local storage because of a rendering issue, the page might have been changed ;)\";\n\t        }\n\t    });\n\t\n\t    window.addEventListener(\"scroll\", function () {\n\t        var el = document.getElementById(\"secondParagraph\"),\n\t            r = el.getBoundingClientRect(),\n\t            html = document.documentElement;\n\t        if (r.top <= html.clientHeight && r.bottom >= 0 && !animated) {\n\t            animated = true;\n\t\n\t            el.classList.add(\"animate\");\n\t            if (!savedRanges.length) {\n\t                presentRendering(\"secondParagraphItem\", \"marking\", 30);\n\t            }\n\t        }\n\t    });\n\t\n\t    var actionMark = function actionMark() {\n\t        try {\n\t            var selection = document.getSelection(),\n\t                renderer = new _Marklib2[\"default\"].Rendering(document),\n\t                result = renderer.renderWithRange(selection.getRangeAt(0));\n\t            selection.removeAllRanges();\n\t            savedRanges.push(result);\n\t            localStorage.setItem(STORAGE_KEY, JSON.stringify(savedRanges));\n\t        } catch (e) {\n\t            console.warn(\"Could not add selection: \", e);\n\t        }\n\t    };\n\t\n\t    document.addEventListener(\"keydown\", function (e) {\n\t        if (13 === e.keyCode) {\n\t            actionMark();\n\t        }\n\t    });\n\t\n\t    document.addEventListener(\"click\", function (e) {\n\t        if (e.target.id === \"action-mark\") {\n\t            return actionMark();\n\t        } else if (e.target.id === \"action-clear\") {\n\t            var elements = document.getElementsByTagName(\"x-marker\");\n\t            for (var i = 0; i < elements.length; i++) {\n\t                elements[i].classList.add(\"deleted\");\n\t                elements[i].classList.remove(\"marking\");\n\t            }\n\t            savedRanges = [];\n\t            localStorage.setItem(STORAGE_KEY, JSON.stringify([]));\n\t        }\n\t    });\n\t});\n\t\n\texports[\"default\"] = _Marklib2[\"default\"];\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Object$defineProperty = __webpack_require__(6)['default'];\n\t\n\tvar _interopRequireDefault = __webpack_require__(5)['default'];\n\t\n\t_Object$defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\tvar _Rendering = __webpack_require__(3);\n\t\n\tvar _Rendering2 = _interopRequireDefault(_Rendering);\n\t\n\tvar _Util = __webpack_require__(4);\n\t\n\tvar _Util2 = _interopRequireDefault(_Util);\n\t\n\texports['default'] = {\n\t    Rendering: _Rendering2['default'],\n\t    Util: _Util2['default']\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar _createClass = __webpack_require__(7)['default'];\n\t\n\tvar _classCallCheck = __webpack_require__(8)['default'];\n\t\n\tvar _Object$defineProperty = __webpack_require__(6)['default'];\n\t\n\tvar _interopRequireDefault = __webpack_require__(5)['default'];\n\t\n\t_Object$defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\t/* global Node, Rendering, Document, global */\n\t\n\tvar _Util = __webpack_require__(4);\n\t\n\tvar _Util2 = _interopRequireDefault(_Util);\n\t\n\t/**\n\t * @type {string}\n\t */\n\tvar TAG_NAME = 'x-marker';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ORIGINAL_OFFSET_START = 'data-original-offset-start';\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_ORIGINAL_TEXT_NODE_INDEX = 'original-text-node-index';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_START_END = 'data-is-start-end';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_IS_HIGHLIGHT_NODE = 'data-is-highlight-node';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ID = 'data-selection-id';\n\t\n\tvar Rendering = (function () {\n\t    function Rendering(document, cssClass, context) {\n\t        _classCallCheck(this, Rendering);\n\t\n\t        if (!(document instanceof Document)) {\n\t            throw 'Marklib {0} is required to be a document instance';\n\t        }\n\t        /**\n\t         * @type {Document}\n\t         */\n\t        this.document = document;\n\t\n\t        /**\n\t         * ID of rendering, will be set on each element that is part of it\n\t         * @type {String}\n\t         */\n\t        this.id = _Util2['default'].guid();\n\t\n\t        /**\n\t         * Class that is set on all highlight nodes\n\t         * @type {String}\n\t         */\n\t        this.cssClass = undefined === cssClass ? 'marking' : cssClass;\n\t\n\t        /**\n\t         * StartContainer\n\t         * @type {Node}\n\t         */\n\t        this.startContainer = null;\n\t\n\t        /**\n\t         * EndContainer\n\t         * @type {Node}\n\t         */\n\t        this.endContainer = null;\n\t\n\t        /**\n\t         * Prefix before ID\n\t         * @type {string}\n\t         */\n\t        this.markerPrefix = 'marker-start-';\n\t\n\t        /**\n\t         * Suffix before ID\n\t         * @type {string}\n\t         */\n\t        this.markerSuffix = 'marker-end-';\n\t\n\t        /**\n\t         * @type {Node}\n\t         */\n\t        this.context = context || this.document;\n\t\n\t        /**\n\t         * @type {Function}\n\t         * @private\n\t         */\n\t        this._onWrappedNodeFunc = null;\n\t    }\n\t\n\t    _createClass(Rendering, [{\n\t        key: 'getId',\n\t\n\t        /**\n\t         * @returns {string} id of this rendering\n\t         */\n\t        value: function getId() {\n\t            return this.id;\n\t        }\n\t    }, {\n\t        key: 'setId',\n\t\n\t        /**\n\t         * @param {string} id\n\t         * @returns {Rendering}\n\t         */\n\t        value: function setId(id) {\n\t            this.id = id;\n\t            return this;\n\t        }\n\t    }, {\n\t        key: 'onWrappedNode',\n\t\n\t        /**\n\t         * Listener that is called when a node is wrapped on this instance\n\t         * @param {Function} f\n\t         * @returns {Rendering}\n\t         */\n\t        value: function onWrappedNode(f) {\n\t            this._onWrappedNodeFunc = f;\n\t            return this;\n\t        }\n\t    }, {\n\t        key: '_callOnWrappedNode',\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        value: function _callOnWrappedNode() {\n\t            if ('function' === typeof this._onWrappedNodeFunc) {\n\t                this._onWrappedNodeFunc.apply(this, arguments);\n\t            }\n\t        }\n\t    }, {\n\t        key: '_createWrapTemplate',\n\t\n\t        /**\n\t         * Creates a Template used as a wrapper\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t        value: function _createWrapTemplate() {\n\t            var el = this.document.createElement(TAG_NAME),\n\t                vTrue = 'true';\n\t            el.className = this.cssClass;\n\t            el.setAttribute(_Util.DATA_IS_SELECTION, vTrue);\n\t            el.setAttribute(ATTR_DATA_ID, this.getId());\n\t            el.setAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE, vTrue);\n\t\n\t            return el;\n\t        }\n\t    }, {\n\t        key: '_createStartEndWrapTemplate',\n\t\n\t        /**\n\t         * Creates a Template to use as start and end marks\n\t         * @param {String} id\n\t         * @param {String} text\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t        value: function _createStartEndWrapTemplate(id, text) {\n\t            var el = this._createWrapTemplate(),\n\t                vTrue = 'true';\n\t            el.setAttribute(ATTR_DATA_START_END, vTrue);\n\t            el.id = id;\n\t            el.textContent = text;\n\t            return el;\n\t        }\n\t    }, {\n\t        key: '_createStartOrEndContainer',\n\t\n\t        /**\n\t         * Creates Start or End Container Element\n\t         * @param initialNode\n\t         * @param prefix\n\t         * @param text\n\t         * @param offset\n\t         * @param index\n\t         * @returns {Node}\n\t         */\n\t        value: function _createStartOrEndContainer(initialNode, prefix, text, offset, index) {\n\t            var wrapper = this._createStartEndWrapTemplate(prefix + this.getId(), text);\n\t            wrapper.setAttribute(_Util.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(initialNode, index));\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n\t            wrapper.marklibInstance = this;\n\t            return wrapper;\n\t        }\n\t    }, {\n\t        key: '_createWrap',\n\t\n\t        /**\n\t         * Wraps given element\n\t         * @param {Node} el\n\t         * @param [optionalLength]\n\t         * @param [optionalIndex]\n\t         * @param [optionalIsSameNode]\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t        value: function _createWrap(el, optionalLength, optionalIndex, optionalIsSameNode) {\n\t            var originalIndex = optionalIndex >= 0 ? optionalIndex : _Util2['default'].calcIndex(el);\n\t            var wrapper = this._createWrapTemplate();\n\t            wrapper.setAttribute(_Util.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(el, originalIndex));\n\t            var offsetLength = optionalLength >= 0 ? optionalLength : Rendering._getOffsetParentIfHas(el);\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offsetLength);\n\t\n\t            // Save a reference to original text node in wrapper\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, originalIndex);\n\t\n\t            // save this marker instance to given node\n\t            wrapper.marklibInstance = this;\n\t\n\t            if (optionalIsSameNode) {\n\t                wrapper.setAttribute(ATTR_DATA_START_END, ATTR_DATA_START_END);\n\t            }\n\t            var wrap = _Util2['default'].wrap(el, wrapper);\n\t            this._callOnWrappedNode(el, wrap);\n\t            return wrap;\n\t        }\n\t    }, {\n\t        key: '_createSplitContainer',\n\t\n\t        /**\n\t         * Create split container element\n\t         * @param originalElement {Node} original text node element that is created a wrapper for\n\t         * @param index\n\t         * @param offset\n\t         * @returns {*|jQuery|Node}\n\t         */\n\t        value: function _createSplitContainer(originalElement, index, offset) {\n\t            var wrapper = this.document.createElement(TAG_NAME),\n\t                vTrue = 'true';\n\t            wrapper.setAttribute(_Util.DATA_IS_SELECTION, vTrue);\n\t            wrapper.setAttribute(_Util.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(originalElement, index));\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n\t            return wrapper;\n\t        }\n\t    }, {\n\t        key: '_walkTextNodes',\n\t\n\t        /**\n\t         * Extracts all TextNodes inside a container\n\t         * @param {Node} el\n\t         * @returns {Array.<Text>}\n\t         */\n\t        value: function _walkTextNodes(el, func) {\n\t            this.walkDom(el, function (node) {\n\t                if (Node.TEXT_NODE === node.nodeType && !_Util2['default'].nodeIsEmpty(node)) {\n\t                    func(node);\n\t                }\n\t                return true;\n\t            });\n\t        }\n\t    }, {\n\t        key: 'walk',\n\t\n\t        /**\n\t         * Walks the tree\n\t         * @param start\n\t         * @param endContainer\n\t         * @param nextParent\n\t         */\n\t        value: function walk(start, endContainer, nextParent) {\n\t            var nextParentNode = start;\n\t            while (nextParentNode && nextParentNode !== nextParent.parentNode) {\n\t                var currentParentNode = nextParentNode;\n\t                nextParentNode = nextParentNode.parentNode;\n\t                if (this.wrapSiblings(currentParentNode.nextSibling, endContainer)) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: 'wrapSiblings',\n\t\n\t        /**\n\t         * Will Wrap all textNode siblings of a container (start) inside a defined Element (like a span)\n\t         * If an Element node is found, it will wrap all children of this node inside a element as well.\n\t         * It will stop if endContainer is found as a node\n\t         *\n\t         * @param {Node} start\n\t         * @param {Node} endContainer\n\t         * @returns {boolean} (true if endContainer was found)\n\t         */\n\t        value: function wrapSiblings(start, endContainer) {\n\t            var _this = this;\n\t\n\t            var next = start,\n\t                found = false;\n\t\n\t            // Capsule some logic\n\t            var wrap = (function (n) {\n\t                if (n.parentNode.hasAttribute(ATTR_DATA_START_END) && n.parentNode.hasAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE) && n.parentNode.getAttribute(ATTR_DATA_ID) == _this.getId()) {\n\t                    var thisNode = _this._createWrap(n).parentNode;\n\t                    thisNode.classList.remove(_this.cssClass);\n\t                    thisNode.removeAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE);\n\t                } else {\n\t                    _this._createWrap(n);\n\t                }\n\t            }).bind(this);\n\t\n\t            var wrapIf = function wrapIf(n) {\n\t                if (!_Util2['default'].nodeIsEmpty(n)) {\n\t                    wrap(n);\n\t                }\n\t            };\n\t            while (null !== next && next !== endContainer) {\n\t                var currentNext = next;\n\t                next = next.nextSibling;\n\t                // Found a text node, directly wrap inside a span\n\t                if (Node.TEXT_NODE === currentNext.nodeType) {\n\t                    wrapIf(currentNext);\n\t                } else {\n\t\n\t                    if (!!(currentNext.compareDocumentPosition(endContainer) & 16)) {\n\t                        this.walkDom(currentNext, function (e) {\n\t                            if (e === endContainer) {\n\t                                return false;\n\t                            }\n\t                            if (Node.TEXT_NODE === e.nodeType) {\n\t                                wrapIf(e);\n\t                            }\n\t                            return true;\n\t                        });\n\t                        found = true;\n\t                    } else {\n\t                        this._walkTextNodes(currentNext, function (el) {\n\t                            wrapIf(el);\n\t                        });\n\t                    }\n\t                    if (found) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            return found;\n\t        }\n\t    }, {\n\t        key: 'walkDom',\n\t\n\t        /**\n\t         * Recursively walks the dom tree unless func returns false\n\t         * This is a lot more efficient then using any jQuery operations\n\t         *\n\t         * Applies node to function\n\t         * @param node\n\t         * @param func\n\t         * @returns {*}\n\t         */\n\t        value: function walkDom(node, func) {\n\t            if (!node) {\n\t                return false;\n\t            }\n\t            var children = node.childNodes;\n\t            if (!children) {\n\t                return false;\n\t            }\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (!this.walkDom(children[i], func)) {\n\t                    return false;\n\t                }\n\t            }\n\t            return func(node);\n\t        }\n\t    }, {\n\t        key: '_markTextSameNode',\n\t\n\t        /**\n\t         * Marks text of the same node\n\t         * @param {Node} textNode\n\t         * @param {int} startIndex\n\t         * @param {int} endIndex\n\t         * @private\n\t         */\n\t        value: function _markTextSameNode(textNode, startIndex, endIndex) {\n\t\n\t            var initialText = textNode.nodeValue,\n\t                initialIndex = _Util2['default'].calcIndex(textNode);\n\t\n\t            if (!initialText) {\n\t                return false;\n\t            }\n\t\n\t            //If there is an unmarked part in the beginning of the text node,\n\t            //cut off that part and put it into it's own textnode.\n\t            if (startIndex > 0) {\n\t                var textBefore = initialText.slice(0, startIndex);\n\t                textNode.parentNode.insertBefore(global.document.createTextNode(textBefore), textNode);\n\t                // wrap cutted text node:\n\t                _Util2['default'].wrap(textNode.previousSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode)));\n\t            }\n\t            //If there is an unmarked part at the end of the text node,\n\t            //cut off that part and put it into it's own textnode.\n\t            if (endIndex < initialText.length) {\n\t                var textAfter = initialText.slice(endIndex, initialText.length);\n\t                textNode.parentNode.insertBefore(global.document.createTextNode(textAfter), textNode.nextSibling);\n\t                _Util2['default'].wrap(textNode.nextSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode) + endIndex));\n\t            }\n\t\n\t            //Cutoff the unmarked parts and wrap the textnode into a span.\n\t            textNode.nodeValue = initialText.slice(startIndex, endIndex);\n\t            this.startContainer = this._createWrap(textNode, Rendering._getOffsetParentIfHas(textNode) + startIndex, initialIndex, true).parentNode;\n\t            this.endContainer = this.startContainer;\n\t            return this.startContainer;\n\t        }\n\t    }, {\n\t        key: '_markTextDifferentNode',\n\t\n\t        /**\n\t         * Marks text of end and start containers if start and end nodes are different\n\t         * Important: There might be no end container!\n\t         *\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @returns {{startT: (Node), endT: (Node)}}\n\t         * @private\n\t         */\n\t        value: function _markTextDifferentNode(startContainer, endContainer, startOffset, endOffset) {\n\t            // Get current for both start and end:\n\t            var startContainerIndex = _Util2['default'].calcIndex(startContainer);\n\t            var endContainerIndex = _Util2['default'].calcIndex(endContainer);\n\t\n\t            // Split text\n\t            var fullTextStartValue = startContainer.nodeValue;\n\t            // init with startContainer because we may have not a text node here\n\t            var startT = startContainer;\n\t\n\t            if (undefined !== fullTextStartValue) {\n\t                var partTextStartValue = fullTextStartValue.slice(startOffset, fullTextStartValue.length);\n\t                // Set new text to start node\n\t                startContainer.nodeValue = fullTextStartValue.slice(0, startOffset);\n\t\n\t                var offsetStart = Rendering._getOffsetParentIfHas(startContainer);\n\t                // Create a new node for splitted text, offset is the length of new startContainer.nodeValue:\n\t                startT = this._createStartOrEndContainer(startContainer, this.markerPrefix, partTextStartValue, offsetStart === startOffset ? offsetStart : offsetStart + startOffset, startContainerIndex);\n\t                // Append this node after startContainer\n\t                startContainer.parentNode.insertBefore(startT, startContainer.nextSibling);\n\t                this.startContainer = startT;\n\t\n\t                if (startContainer.nodeValue) {\n\t                    // Wrap start container in detection node, offset is always 0 or parent offset.\n\t                    _Util2['default'].wrap(startContainer, this._createSplitContainer(startContainer, startContainerIndex, Rendering._getOffsetParentIfHas(startContainer)));\n\t                }\n\t            }\n\t\n\t            // init with endContainer because we may have not a text node here\n\t            var endT = endContainer;\n\t\n\t            // 2. Extract end Text node,\n\t            var fullTextEndValue = endContainer.nodeValue;\n\t            // It's possible that end container value is null (if a whole paragraph is marked)\n\t            if (undefined !== fullTextEndValue) {\n\t                // Split text\n\t                var partTextEndValue = fullTextEndValue.slice(0, endOffset);\n\t                endContainer.nodeValue = fullTextEndValue.slice(endOffset, fullTextEndValue.length);\n\t                // End Container start offset is always 0 or parent offset.\n\t                endT = this._createStartOrEndContainer(endContainer, this.markerSuffix, partTextEndValue, Rendering._getOffsetParentIfHas(endContainer), endContainerIndex);\n\t\n\t                endContainer.parentNode.insertBefore(endT, endContainer);\n\t                this.endContainer = endT;\n\t                var offsetParent = Rendering._getOffsetParentIfHas(endContainer);\n\t                _Util2['default'].wrap(endContainer, this._createSplitContainer(endContainer, endContainerIndex, offsetParent === endOffset ? offsetParent : offsetParent + endOffset));\n\t            }\n\t\n\t            return { startT: startT, endT: endT };\n\t        }\n\t    }, {\n\t        key: '_findOriginalOffset',\n\t\n\t        /**\n\t         * Will return the original first offset\n\t         * @param element\n\t         * @returns {int}\n\t         * @private\n\t         */\n\t        value: function _findOriginalOffset(element) {\n\t            if (!element.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n\t                return 0;\n\t            }\n\t            var lengthElement = _Util2['default'].parent(element, '[' + ATTR_DATA_ORIGINAL_OFFSET_START + ']');\n\t            return lengthElement ? parseInt(lengthElement.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : 0;\n\t        }\n\t    }, {\n\t        key: '_renderWithElements',\n\t\n\t        /**\n\t         * Renders a selection\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {Node} commonAncestor\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @param {boolean} [withoutResult] if true result will not be calculated\n\t         * @returns {{startOffset: (int), endOffset: (int)}} the original offsets found\n\t         * @private\n\t         */\n\t        value: function _renderWithElements(startContainer, endContainer, commonAncestor, startOffset, endOffset, withoutResult) {\n\t            var outer = _Util2['default'].parents(startContainer, commonAncestor);\n\t            outer = outer[outer.length - 1];\n\t            var contextContainer = outer ? outer : commonAncestor;\n\t\n\t            // Same Element, means the selection is fully contained in a discrete area, start and endpoint have the same parent\n\t            // but are different nodes:\n\t\n\t            // Start and End offset have to be recalculated because dom might be already changed by highlighting in given node\n\t            // 1: First detect real start offset in startContainer:\n\t\n\t            // That works by selecting the highest wrapper and get original-offset-start data element, see \"findOriginalOffset\"\n\t            // So first select that container:\n\t            var originalStartOffset = this._findOriginalOffset(startContainer);\n\t            var originalEndOffset = this._findOriginalOffset(endContainer);\n\t\n\t            // We may run into Browser Bugs:\n\t\n\t            // If both are not text nodes, use next sibling as endContainer\n\t            if (startContainer.nodeType !== Node.TEXT_NODE && endContainer.nodeType !== Node.TEXT_NODE) {\n\t                if (startContainer === endContainer) {\n\t                    endContainer = endContainer.nextElementSibling || endContainer;\n\t                }\n\t            }\n\t            // IF start/end container is not type of text, select first child text node:\n\t            // We run in some bugs with firefox here that selects no text-nodes sometimes, trying to fix this here\n\t            // Sometimes does not work correctly... (specially when DOM was modified)\n\t            if (startContainer.nodeType !== Node.TEXT_NODE) {\n\t                this.walkDom(startContainer, function (el) {\n\t                    if (el.nodeType === Node.TEXT_NODE) {\n\t                        startContainer = el;\n\t                        return false;\n\t                    }\n\t                    return true;\n\t                });\n\t            }\n\t\n\t            if (endContainer.nodeType !== Node.TEXT_NODE) {\n\t                // Get the last text node:\n\t                var endContainerContents = _Util2['default'].closest(startContainer, ':not([' + _Util.DATA_IS_SELECTION + '])').childNodes;\n\t                if (endContainerContents.length) {\n\t                    var r = endContainerContents[endContainerContents.length - 1];\n\t                    if (r.nodeType === Node.TEXT_NODE) {\n\t                        endContainer = r;\n\t                        endOffset = r.length;\n\t                    } else {\n\t                        var f = r.lastChild;\n\t                        while (f !== null) {\n\t                            if (f && f.nodeType === Node.TEXT_NODE) {\n\t                                endContainer = f;\n\t                                endOffset = f.length;\n\t                                if (f.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n\t                                    endOffset = parseInt(f.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) + endOffset;\n\t                                }\n\t                            }\n\t                            f = f.lastChild;\n\t                        }\n\t                    }\n\t                }\n\t                // still no textNode?\n\t                if (endContainer.nodeType !== Node.TEXT_NODE) {\n\t                    throw 'Could not found endContainer, highlighting would be unstable';\n\t                }\n\t            }\n\t\n\t            var result = withoutResult || {\n\t                // Real offset is calculated by relative length and absolute length\n\t                startOffset: originalStartOffset + startOffset,\n\t                endOffset: originalEndOffset + endOffset,\n\t                // get the path for this selection\n\t                startContainerPath: _Util2['default'].getPath(startContainer, this.context),\n\t                endContainerPath: _Util2['default'].getPath(endContainer, this.context)\n\t            };\n\t\n\t            this._renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer);\n\t\n\t            return result;\n\t        }\n\t    }, {\n\t        key: '_renderSelection',\n\t\n\t        /**\n\t         * Renders a given selection\n\t         *\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @param {Node} contextContainer\n\t         * @param {Node} outer\n\t         * @private\n\t         */\n\t        value: function _renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer) {\n\t\n\t            // if start and end-container are the same, mark text on the same node\n\t            if (startContainer === endContainer) {\n\t                this._markTextSameNode(startContainer, startOffset, endOffset);\n\t            } else {\n\t                var result = this._markTextDifferentNode(startContainer, endContainer, startOffset, endOffset);\n\t                if (!outer) {\n\t                    this.wrapSiblings(result.startT.nextSibling, endContainer);\n\t                } else {\n\t                    this.walk(result.startT, endContainer, contextContainer);\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: '_deserializePath',\n\t\n\t        /**\n\t         * Deserializes a specific path and finds the right textnodes\n\t         * This even works when DOM has been manipulated before by `marklib`\n\t         * @param {string} path the serialized path (including offsets)\n\t         * @return {Node}\n\t         * @private\n\t         */\n\t        value: function _deserializePath(path) {\n\t            var pSplit = path.split(';'),\n\t                p = pSplit[0],\n\t                objectIndex = parseInt(pSplit[1]),\n\t                charOffset = parseInt(pSplit[2]),\n\t                container = this.context.querySelector(p),\n\t                maybeFoundNode = null;\n\t            this.walkDom(container, function (n) {\n\t                if (n.nodeType === Node.TEXT_NODE) {\n\t                    var atrOffsetStart = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START);\n\t                    atrOffsetStart = null === atrOffsetStart ? 0 : atrOffsetStart;\n\t                    var atrIndex = n.parentNode.getAttribute(_Util.ATTR_DATA_ORIGINAL_INDEX);\n\t                    atrIndex = null === atrIndex ? _Util2['default'].calcIndex(n) : atrIndex;\n\t                    if (atrIndex == objectIndex && charOffset >= atrOffsetStart && parseInt(atrOffsetStart) + n.length >= charOffset) {\n\t                        var thisOffset = n.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START) ? charOffset - parseInt(n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : charOffset;\n\t                        maybeFoundNode = { node: n, offset: thisOffset };\n\t                        return false;\n\t                    }\n\t                } else {\n\t                    return true;\n\t                }\n\t                return true;\n\t            });\n\t\n\t            return maybeFoundNode;\n\t        }\n\t    }, {\n\t        key: 'renderWithPath',\n\t\n\t        /**\n\t         * Prepares to render a Selection with path selectors\n\t         * ```\n\t         * A Path looks like this:\n\t         *\n\t         * #selector;#textnode;#offset\n\t         * ``\n\t         * @param {string} startPath\n\t         * @param {string} endPath\n\t         * @returns {*}\n\t         */\n\t        value: function renderWithPath(startPath, endPath) {\n\t            var startContainer = this._deserializePath(startPath);\n\t            var endContainer = this._deserializePath(endPath);\n\t            if (startContainer && endContainer && startContainer.node && endContainer.node) {\n\t                var range = document.createRange();\n\t                range.setStart(startContainer.node, startContainer.offset);\n\t                range.setEnd(endContainer.node, endContainer.offset);\n\t                this.renderWithRange(range, true);\n\t                return range;\n\t            }\n\t            throw 'Could not find start- and/or end-container in document';\n\t        }\n\t    }, {\n\t        key: 'renderWithRange',\n\t\n\t        /**\n\t         * Prepares a selection with a range object\n\t         * @param {Range} range\n\t         * @param {boolean} [withoutResult] optional do calculate a result, the selection would not be serializable\n\t         * @returns {*}\n\t         */\n\t        value: function renderWithRange(range, withoutResult) {\n\t            return this._renderWithElements(range.startContainer, range.endContainer, range.commonAncestorContainer, range.startOffset, range.endOffset, withoutResult);\n\t        }\n\t    }], [{\n\t        key: '_getIndexParentIfHas',\n\t\n\t        /**\n\t         * @param {Node} container\n\t         * @param {Number} thisIndex\n\t         * @returns {int} index of parent or original\n\t         * @private\n\t         */\n\t        value: function _getIndexParentIfHas(container, thisIndex) {\n\t            var p = container.parentNode;\n\t            var index = parseInt(p.getAttribute(_Util.ATTR_DATA_ORIGINAL_INDEX));\n\t            return index > thisIndex ? index : thisIndex;\n\t        }\n\t    }, {\n\t        key: '_getOffsetParentIfHas',\n\t\n\t        /**\n\t         * @param container\n\t         * @returns {int} offset start of parent if has, else 0\n\t         */\n\t        value: function _getOffsetParentIfHas(container) {\n\t            var p = container.parentNode;\n\t            var offset = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START));\n\t            return offset > 0 ? offset : 0;\n\t        }\n\t    }]);\n\t\n\t    return Rendering;\n\t})();\n\t\n\texports['default'] = Rendering;\n\tmodule.exports = exports['default'];\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = __webpack_require__(7)['default'];\n\t\n\tvar _classCallCheck = __webpack_require__(8)['default'];\n\t\n\tvar _Object$defineProperty = __webpack_require__(6)['default'];\n\t\n\t_Object$defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\t/* global Node, NodeList, Element */\n\t\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ORIGINAL_INDEX = 'data-original-index';\n\texports.ATTR_DATA_ORIGINAL_INDEX = ATTR_DATA_ORIGINAL_INDEX;\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_PSEUDO = 'data-is-pseudo';\n\texports.DATA_PSEUDO = DATA_PSEUDO;\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_IS_SELECTION = 'data-is-selection';\n\texports.DATA_IS_SELECTION = DATA_IS_SELECTION;\n\t/**\n\t * @type {string}\n\t */\n\tvar SERIALIZE_SEPARATOR = ';';\n\t\n\t// polyfill for matchesSelector, IE 10/11 does not support Element.matches\n\tif (Element && !Element.prototype.matches) {\n\t    var p = Element.prototype;\n\t    p.matches = p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t}\n\t\n\t/**\n\t * Utility class\n\t * Contains DOM/Node manipulation helpers\n\t */\n\t\n\tvar Util = (function () {\n\t    function Util() {\n\t        _classCallCheck(this, Util);\n\t    }\n\t\n\t    _createClass(Util, null, [{\n\t        key: 'nodeListFilter',\n\t\n\t        /**\n\t         * Filter for a NodeList\n\t         * @param {NodeList} nodes\n\t         * @param {Function} func\n\t         * @returns {Array.<HTMLElement>}\n\t         */\n\t        value: function nodeListFilter(nodes, func) {\n\t            return Array.prototype.filter.call(nodes || [], func);\n\t        }\n\t    }, {\n\t        key: 'guid',\n\t\n\t        /**\n\t         * Generates a unique id\n\t         * @return {String}\n\t         */\n\t        value: function guid() {\n\t            function s4() {\n\t                return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);\n\t            }\n\t\n\t            return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t        }\n\t    }, {\n\t        key: 'nodeIsEmpty',\n\t\n\t        /**\n\t         * Checks if a given node is empty\n\t         * @param {HTMLElement} node\n\t         * @returns {*}\n\t         */\n\t        value: function nodeIsEmpty(node) {\n\t            return node.nodeValue.match(/^[\\s]*$/g);\n\t        }\n\t    }, {\n\t        key: 'index',\n\t\n\t        /**\n\t         * @param {HTMLElement} node\n\t         * @param [optionalList]\n\t         * @return {int} the index of this node in context to it's siblings\n\t         */\n\t        value: function index(node, optionalList) {\n\t            var children = optionalList || (node.nodeType === Node.TEXT_NODE ? node.parentNode.childNodes : node.parentNode.children);\n\t            return Array.prototype.indexOf.call(children || [], node);\n\t        }\n\t    }, {\n\t        key: 'wrap',\n\t\n\t        /**\n\t         * Wraps given `elms` in given `wrapper`\n\t         *\n\t         * @param {HTMLElement} wrapper\n\t         * @param {HTMLElement|Array.<HTMLElement>} elms\n\t         * @return {HTMLElement}\n\t         */\n\t        value: function wrap(elms, wrapper) {\n\t            if (!elms) {\n\t                return wrapper;\n\t            } // Convert `elms` to an array, if necessary.\n\t            if (!(elms instanceof NodeList || elms instanceof Array)) elms = [elms];\n\t            for (var i = elms.length - 1; i >= 0; i--) {\n\t                var child = i > 0 ? wrapper.cloneNode(true) : wrapper;\n\t                var el = elms[i];\n\t                // Cache the current parent and sibling.\n\t                var parent = el.parentNode,\n\t                    sibling = el.nextSibling;\n\t\n\t                child.appendChild(el);\n\t                if (sibling) {\n\t                    parent.insertBefore(child, sibling);\n\t                } else {\n\t                    parent.appendChild(child);\n\t                }\n\t            }\n\t            return wrapper;\n\t        }\n\t    }, {\n\t        key: 'calcIndex',\n\t\n\t        /**\n\t         * Will calculate an index depending on an already modified dom by marklib\n\t         * @param {HTMLElement} node\n\t         * @returns {int|boolean}\n\t         */\n\t        value: function calcIndex(node) {\n\t            var calculatedIndex = 0;\n\t            var foundWrapper = false;\n\t            var nodes = node.childNodes,\n\t                length = nodes.length;\n\t            for (var thisIndex = 0; thisIndex < length; thisIndex++) {\n\t                var el = nodes[thisIndex];\n\t                if (el === node) {\n\t                    return false;\n\t                }\n\t                var maybeIndexOfOriginal = el.getAttribute(ATTR_DATA_ORIGINAL_INDEX);\n\t                var isOriginal = maybeIndexOfOriginal !== undefined;\n\t                // Important: do not include pseudo elements\n\t                if (el !== node && (el.nodeType !== Node.TEXT_NODE || isOriginal) && !el.hasAttribute(DATA_PSEUDO)) {\n\t                    if (isOriginal) {\n\t                        calculatedIndex = parseInt(maybeIndexOfOriginal);\n\t                        foundWrapper = true;\n\t                    } else {\n\t                        calculatedIndex++;\n\t                    }\n\t                }\n\t            }\n\t            return foundWrapper ? calculatedIndex : Util.index(node);\n\t        }\n\t    }, {\n\t        key: 'parents',\n\t\n\t        /**\n\t         * @param {HTMLElement} el\n\t         * @param {String} [optionalSelector] will test given element against a selector\n\t         *  if matches, returns this element immediately\n\t         * @return {Array.<HTMLElement>} an array of all found parents of given element (and optional selector)\n\t         */\n\t        value: function parents(el, optionalSelector) {\n\t            var element = el;\n\t            var foundElements = [];\n\t            while (element.parentNode !== null) {\n\t                element = element.parentNode;\n\t                if (optionalSelector && (element === optionalSelector || typeof optionalSelector === 'string' && element.matches && element.matches(optionalSelector))) {\n\t                    foundElements.push(element);\n\t                } else if (!optionalSelector) {\n\t                    foundElements.push(element);\n\t                }\n\t            }\n\t            return foundElements;\n\t        }\n\t    }, {\n\t        key: 'parent',\n\t\n\t        /**\n\t         * Finds a parent node (the closest) with a given selector\n\t         * @param {Node} el\n\t         * @param {String} selector\n\t         * @returns {*}\n\t         */\n\t        value: function parent(el, selector) {\n\t            var element = el;\n\t            while (element.parentNode !== null) {\n\t                element = element.parentNode;\n\t                if (element.matches && element.matches(selector)) {\n\t                    return element;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'closest',\n\t        value: function closest(el, selector) {\n\t            var element = el;\n\t            while (element !== null) {\n\t                if (element.matches && element.matches(selector)) {\n\t                    return element;\n\t                }\n\t                element = element.parentNode;\n\t            }\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'getPath',\n\t\n\t        /**\n\t         * Determines the correct paths and excludes all `marklib` generated content\n\t         * TODO: To improve performance we could shorten the path if an ID is present in it.\n\t         * @param {HTMLElement} el\n\t         * @param {HTMLElement} [context] if given extraction path is relative to this element\n\t         * @returns {*}\n\t         */\n\t        value: function getPath(el, context) {\n\t            var path = null,\n\t                node = el;\n\t\n\t            while (node) {\n\t                var name = null;\n\t                // If node is a text-node, save index\n\t                if (Node.TEXT_NODE === node.nodeType) {\n\t\n\t                    /* Because nodes may wrapped inside a highlighting node, we need to find the original index that was\n\t                     * valid before the dom changes. We store the last known index position inside all wrapper elements\n\t                     * We select the outermost\n\t                     */\n\t\n\t                    // Extract original index of this node:\n\t                    // Outer most data-original-index is original index\n\t                    var outerMostElement = Util.parents(node, '[' + ATTR_DATA_ORIGINAL_INDEX + ']').reverse()[0];\n\t                    // if element is not yet wrapped in span, recalculate index based on parent container:\n\t                    // We have to do this because text node indexes != element indexes...\n\t                    var calculatedIndex = 0;\n\t                    if (!outerMostElement) {\n\t                        calculatedIndex = Util.calcIndex(node);\n\t                    }\n\t                    var index = outerMostElement ? parseInt(outerMostElement.getAttribute(ATTR_DATA_ORIGINAL_INDEX)) : calculatedIndex;\n\t                    name = SERIALIZE_SEPARATOR + index;\n\t                } else {\n\t                    name = node.nodeName;\n\t                }\n\t\n\t                if (!name) break;\n\t\n\t                name = name.toLowerCase();\n\t\n\t                var parent = node.parentNode;\n\t                if (node instanceof HTMLElement && node.hasAttribute(DATA_IS_SELECTION)) {\n\t                    node = parent;\n\t                    continue;\n\t                }\n\t                // Select only siblings that are not part of selection and are of the same type\n\t                // (because we use nth-of-type selector later)\n\t                var siblings = Util.nodeListFilter(parent.children, function (el) {\n\t                    return !el.hasAttribute(DATA_IS_SELECTION) && el.nodeName === node.nodeName;\n\t                }),\n\t                    nodeIndex = Util.index(node, siblings);\n\t\n\t                if (siblings.length > 1 && nodeIndex >= 0) {\n\t                    name += ':nth-of-type(' + (nodeIndex + 1) + ')';\n\t                }\n\t\n\t                path = name + (path ? '>' + path : '');\n\t\n\t                if (parent === context) {\n\t                    break;\n\t                }\n\t\n\t                node = parent;\n\t            }\n\t\n\t            return path.replace('#document>', '').replace('>;', ';');\n\t        }\n\t    }]);\n\t\n\t    return Util;\n\t})();\n\t\n\texports['default'] = Util;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports[\"default\"] = function (obj) {\n\t  return obj && obj.__esModule ? obj : {\n\t    \"default\": obj\n\t  };\n\t};\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(9), __esModule: true };\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _Object$defineProperty = __webpack_require__(6)[\"default\"];\n\t\n\texports[\"default\"] = (function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t\n\t      _Object$defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t})();\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports[\"default\"] = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(10);\r\n\tmodule.exports = function defineProperty(it, key, desc){\r\n\t  return $.setDesc(it, key, desc);\r\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\r\n\tvar global = typeof self != 'undefined' ? self : Function('return this')()\r\n\t  , core   = {}\r\n\t  , defineProperty = Object.defineProperty\r\n\t  , hasOwnProperty = {}.hasOwnProperty\r\n\t  , ceil  = Math.ceil\r\n\t  , floor = Math.floor\r\n\t  , max   = Math.max\r\n\t  , min   = Math.min;\r\n\t// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.\r\n\tvar DESC = !!function(){\r\n\t  try {\r\n\t    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;\r\n\t  } catch(e){ /* empty */ }\r\n\t}();\r\n\tvar hide = createDefiner(1);\r\n\t// 7.1.4 ToInteger\r\n\tfunction toInteger(it){\r\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\r\n\t}\r\n\tfunction desc(bitmap, value){\r\n\t  return {\r\n\t    enumerable  : !(bitmap & 1),\r\n\t    configurable: !(bitmap & 2),\r\n\t    writable    : !(bitmap & 4),\r\n\t    value       : value\r\n\t  };\r\n\t}\r\n\tfunction simpleSet(object, key, value){\r\n\t  object[key] = value;\r\n\t  return object;\r\n\t}\r\n\tfunction createDefiner(bitmap){\r\n\t  return DESC ? function(object, key, value){\r\n\t    return $.setDesc(object, key, desc(bitmap, value));\r\n\t  } : simpleSet;\r\n\t}\r\n\t\r\n\tfunction isObject(it){\r\n\t  return it !== null && (typeof it == 'object' || typeof it == 'function');\r\n\t}\r\n\tfunction isFunction(it){\r\n\t  return typeof it == 'function';\r\n\t}\r\n\tfunction assertDefined(it){\r\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\r\n\t  return it;\r\n\t}\r\n\t\r\n\tvar $ = module.exports = __webpack_require__(11)({\r\n\t  g: global,\r\n\t  core: core,\r\n\t  html: global.document && document.documentElement,\r\n\t  // http://jsperf.com/core-js-isobject\r\n\t  isObject:   isObject,\r\n\t  isFunction: isFunction,\r\n\t  it: function(it){\r\n\t    return it;\r\n\t  },\r\n\t  that: function(){\r\n\t    return this;\r\n\t  },\r\n\t  // 7.1.4 ToInteger\r\n\t  toInteger: toInteger,\r\n\t  // 7.1.15 ToLength\r\n\t  toLength: function(it){\r\n\t    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\r\n\t  },\r\n\t  toIndex: function(index, length){\r\n\t    index = toInteger(index);\r\n\t    return index < 0 ? max(index + length, 0) : min(index, length);\r\n\t  },\r\n\t  has: function(it, key){\r\n\t    return hasOwnProperty.call(it, key);\r\n\t  },\r\n\t  create:     Object.create,\r\n\t  getProto:   Object.getPrototypeOf,\r\n\t  DESC:       DESC,\r\n\t  desc:       desc,\r\n\t  getDesc:    Object.getOwnPropertyDescriptor,\r\n\t  setDesc:    defineProperty,\r\n\t  setDescs:   Object.defineProperties,\r\n\t  getKeys:    Object.keys,\r\n\t  getNames:   Object.getOwnPropertyNames,\r\n\t  getSymbols: Object.getOwnPropertySymbols,\r\n\t  assertDefined: assertDefined,\r\n\t  // Dummy, fix for not array-like ES3 string in es5 module\r\n\t  ES5Object: Object,\r\n\t  toObject: function(it){\r\n\t    return $.ES5Object(assertDefined(it));\r\n\t  },\r\n\t  hide: hide,\r\n\t  def: createDefiner(0),\r\n\t  set: global.Symbol ? simpleSet : hide,\r\n\t  mix: function(target, src){\r\n\t    for(var key in src)hide(target, key, src[key]);\r\n\t    return target;\r\n\t  },\r\n\t  each: [].forEach\r\n\t});\r\n\t/* eslint-disable no-undef */\r\n\tif(typeof __e != 'undefined')__e = core;\r\n\tif(typeof __g != 'undefined')__g = global;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function($){\r\n\t  $.FW   = false;\r\n\t  $.path = $.core;\r\n\t  return $;\r\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** site.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6656a6a7d39b9f987870\n **/","/* global localStorage */\nimport Marklib from 'modules/Marklib';\n/**\n * Contains Module for the demonstration\n */\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    \"use strict\";\n\n    const STORAGE_KEY = 'savedRanges';\n\n    /**\n     * Creates an animated rendering\n     */\n    function presentRendering(selector, classNames, speed) {\n        var autoMarkText = document.getElementById(selector).childNodes[0];\n        let thisLength = autoMarkText.length;\n\n        var render = function (autoMarkText, c, length) {\n            var r = new Marklib.Rendering(document, classNames);\n            var range = document.createRange();\n            range.setStart(autoMarkText, 0);\n            range.setEnd(autoMarkText, 1);\n            r.renderWithRange(range, true);\n            if (autoMarkText.parentNode.nextSibling) {\n                autoMarkText = autoMarkText.parentNode.nextSibling.childNodes[0];\n                setTimeout(function () {\n                        render(autoMarkText, ++c, length);\n                }, speed);\n            }\n        };\n        return render(autoMarkText, 0, thisLength);\n    }\n\n    presentRendering('automark', 'fadeInDown', 20);\n\n    var savedRanges = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [], animated = false;\n\n    savedRanges.forEach(function (range) {\n        var marker = new Marklib.Rendering(document);\n        try {\n            marker.renderWithPath(range.startContainerPath + \";\" + range.startOffset,\n                range.endContainerPath + \";\" + range.endOffset);\n        } catch (e) {\n            console.warn(\"Could not render:\", range);\n            localStorage.setItem(STORAGE_KEY, JSON.stringify([]));\n            throw 'Cleared local storage because of a rendering issue, the page might have been changed ;)';\n        }\n\n    });\n\n    window.addEventListener('scroll', function () {\n        var el = document.getElementById('secondParagraph'), r = el.getBoundingClientRect(),\n            html = document.documentElement;\n        if (r.top <= html.clientHeight && r.bottom >= 0 && !animated) {\n            animated = true;\n\n            el.classList.add('animate');\n            if (!savedRanges.length) {\n                presentRendering('secondParagraphItem', 'marking', 30);\n            }\n        }\n    });\n\n    var actionMark = function () {\n        try {\n            var selection = document.getSelection(), renderer = new Marklib.Rendering(document),\n                result = renderer.renderWithRange(selection.getRangeAt(0));\n            selection.removeAllRanges();\n            savedRanges.push(result);\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(savedRanges));\n        } catch (e) {\n            console.warn(\"Could not add selection: \", e);\n        }\n    };\n\n    document.addEventListener(\"keydown\", function (e) {\n        if (13 === e.keyCode) {\n            actionMark();\n        }\n    });\n\n    document.addEventListener(\"click\", function (e) {\n        if (e.target.id === 'action-mark') {\n            return actionMark();\n        } else if (e.target.id === 'action-clear') {\n            var elements = document.getElementsByTagName('x-marker');\n            for (var i = 0; i < elements.length; i++) {\n                elements[i].classList.add('deleted');\n                elements[i].classList.remove('marking');\n\n            }\n            savedRanges = [];\n            localStorage.setItem(STORAGE_KEY, JSON.stringify([]));\n        }\n    });\n});\n\nexport default Marklib;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/jshint-loader!./src/main/modules/Site.js\n **/","import Rendering from 'Rendering';\nimport Util from 'util/Util';\n\nexport default {\n    Rendering: Rendering,\n    Util:Util\n};\n\n\n/** WEBPACK FOOTER **\n ** ./~/jshint-loader!./src/main/modules/Marklib.js\n **/","/* global Node, Rendering, Document, global */\nimport Util from 'util/Util';\n\nimport {ATTR_DATA_ORIGINAL_INDEX, DATA_IS_SELECTION} from 'util/Util';\n\n/**\n * @type {string}\n */\nconst TAG_NAME = 'x-marker';\n/**\n * @type {string}\n */\nconst ATTR_DATA_ORIGINAL_OFFSET_START = 'data-original-offset-start';\n/**\n * @type {string}\n */\nconst DATA_ORIGINAL_TEXT_NODE_INDEX = 'original-text-node-index';\n/**\n * @type {string}\n */\nconst ATTR_DATA_START_END = 'data-is-start-end';\n/**\n * @type {string}\n */\nconst ATTR_DATA_IS_HIGHLIGHT_NODE = 'data-is-highlight-node';\n/**\n * @type {string}\n */\nconst ATTR_DATA_ID = 'data-selection-id';\n\nexport default\nclass Rendering {\n\n    constructor(document, cssClass, context) {\n\n        if (!(document instanceof Document)) {\n            throw 'Marklib {0} is required to be a document instance';\n        }\n        /**\n         * @type {Document}\n         */\n        this.document = document;\n\n        /**\n         * ID of rendering, will be set on each element that is part of it\n         * @type {String}\n         */\n        this.id = Util.guid();\n\n        /**\n         * Class that is set on all highlight nodes\n         * @type {String}\n         */\n        this.cssClass = undefined === cssClass? 'marking' : cssClass;\n\n        /**\n         * StartContainer\n         * @type {Node}\n         */\n        this.startContainer = null;\n\n        /**\n         * EndContainer\n         * @type {Node}\n         */\n        this.endContainer = null;\n\n        /**\n         * Prefix before ID\n         * @type {string}\n         */\n        this.markerPrefix = 'marker-start-';\n\n        /**\n         * Suffix before ID\n         * @type {string}\n         */\n        this.markerSuffix = 'marker-end-';\n\n        /**\n         * @type {Node}\n         */\n        this.context = context || this.document;\n\n        /**\n         * @type {Function}\n         * @private\n         */\n        this._onWrappedNodeFunc = null;\n    }\n\n    /**\n     * @returns {string} id of this rendering\n     */\n    getId() {\n        return this.id;\n    }\n\n    /**\n     * @param {string} id\n     * @returns {Rendering}\n     */\n    setId(id) {\n        this.id = id;\n        return this;\n    }\n\n    /**\n     * Listener that is called when a node is wrapped on this instance\n     * @param {Function} f\n     * @returns {Rendering}\n     */\n    onWrappedNode(f) {\n        this._onWrappedNodeFunc = f;\n        return this;\n    }\n\n    /**\n     * @private\n     */\n    _callOnWrappedNode() {\n        if (\"function\" === typeof this._onWrappedNodeFunc) {\n            this._onWrappedNodeFunc.apply(this, arguments);\n        }\n    }\n\n\n    /**\n     * @param {Node} container\n     * @param {Number} thisIndex\n     * @returns {int} index of parent or original\n     * @private\n     */\n    static _getIndexParentIfHas(container, thisIndex) {\n        var p = container.parentNode;\n        var index = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_INDEX));\n        return index > thisIndex ? index : thisIndex;\n    }\n\n    /**\n     * @param container\n     * @returns {int} offset start of parent if has, else 0\n     */\n    static _getOffsetParentIfHas(container) {\n        var p = container.parentNode;\n        var offset = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START));\n        return offset > 0 ? offset : 0;\n    }\n\n    /**\n     * Creates a Template used as a wrapper\n     * @returns {Node}\n     * @private\n     */\n    _createWrapTemplate() {\n        var el = this.document.createElement(TAG_NAME), vTrue = \"true\";\n        el.className = this.cssClass;\n        el.setAttribute(DATA_IS_SELECTION, vTrue);\n        el.setAttribute(ATTR_DATA_ID, this.getId());\n        el.setAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE, vTrue);\n\n        return el;\n    }\n\n    /**\n     * Creates a Template to use as start and end marks\n     * @param {String} id\n     * @param {String} text\n     * @returns {Node}\n     * @private\n     */\n    _createStartEndWrapTemplate(id, text) {\n        var el = this._createWrapTemplate(), vTrue = \"true\";\n        el.setAttribute(ATTR_DATA_START_END, vTrue);\n        el.id = id;\n        el.textContent = text;\n        return el;\n    }\n\n\n    /**\n     * Creates Start or End Container Element\n     * @param initialNode\n     * @param prefix\n     * @param text\n     * @param offset\n     * @param index\n     * @returns {Node}\n     */\n    _createStartOrEndContainer(initialNode, prefix, text, offset, index) {\n        var wrapper = this._createStartEndWrapTemplate(prefix + this.getId(), text);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(initialNode, index));\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n        wrapper.marklibInstance = this;\n        return wrapper;\n    }\n\n    /**\n     * Wraps given element\n     * @param {Node} el\n     * @param [optionalLength]\n     * @param [optionalIndex]\n     * @param [optionalIsSameNode]\n     * @returns {Node}\n     * @private\n     */\n    _createWrap(el, optionalLength, optionalIndex, optionalIsSameNode) {\n        var originalIndex = optionalIndex >= 0 ? optionalIndex : Util.calcIndex(el);\n        var wrapper = this._createWrapTemplate();\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(el, originalIndex));\n        var offsetLength = optionalLength >= 0 ? optionalLength : Rendering._getOffsetParentIfHas(el);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offsetLength);\n\n        // Save a reference to original text node in wrapper\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, originalIndex);\n\n        // save this marker instance to given node\n        wrapper.marklibInstance = this;\n\n        if (optionalIsSameNode) {\n            wrapper.setAttribute(ATTR_DATA_START_END, ATTR_DATA_START_END);\n        }\n        var wrap = Util.wrap(el, wrapper);\n        this._callOnWrappedNode(el, wrap);\n        return wrap;\n    }\n\n    /**\n     * Create split container element\n     * @param originalElement {Node} original text node element that is created a wrapper for\n     * @param index\n     * @param offset\n     * @returns {*|jQuery|Node}\n     */\n    _createSplitContainer(originalElement, index, offset) {\n        var wrapper = this.document.createElement(TAG_NAME), vTrue = \"true\";\n        wrapper.setAttribute(DATA_IS_SELECTION, vTrue);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(originalElement, index));\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n        return wrapper;\n    }\n\n    /**\n     * Extracts all TextNodes inside a container\n     * @param {Node} el\n     * @returns {Array.<Text>}\n     */\n    _walkTextNodes(el, func) {\n        this.walkDom(el, function (node) {\n            if (Node.TEXT_NODE === node.nodeType && !Util.nodeIsEmpty(node)) {\n                func(node);\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Walks the tree\n     * @param start\n     * @param endContainer\n     * @param nextParent\n     */\n    walk(start, endContainer, nextParent) {\n        var nextParentNode = start;\n        while (nextParentNode && nextParentNode !== nextParent.parentNode) {\n            var currentParentNode = nextParentNode;\n            nextParentNode = nextParentNode.parentNode;\n            if (this.wrapSiblings(currentParentNode.nextSibling, endContainer)) {\n                break;\n            }\n        }\n    }\n\n\n    /**\n     * Will Wrap all textNode siblings of a container (start) inside a defined Element (like a span)\n     * If an Element node is found, it will wrap all children of this node inside a element as well.\n     * It will stop if endContainer is found as a node\n     *\n     * @param {Node} start\n     * @param {Node} endContainer\n     * @returns {boolean} (true if endContainer was found)\n     */\n    wrapSiblings(start, endContainer) {\n        let next = start,\n            found = false;\n\n        // Capsule some logic\n        var wrap = ((n) => {\n            if (n.parentNode.hasAttribute(ATTR_DATA_START_END) &&\n                n.parentNode.hasAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE) &&\n                n.parentNode.getAttribute(ATTR_DATA_ID) == this.getId()) {\n                let thisNode = this._createWrap(n).parentNode;\n                thisNode.classList.remove(this.cssClass);\n                thisNode.removeAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE);\n            } else {\n                this._createWrap(n);\n            }\n        }).bind(this);\n\n        var wrapIf = (n) => {\n            if (!Util.nodeIsEmpty(n)) {\n                wrap(n);\n            }\n        };\n        while (null !== next && next !== endContainer) {\n            var currentNext = next;\n            next = next.nextSibling;\n            // Found a text node, directly wrap inside a span\n            if (Node.TEXT_NODE === currentNext.nodeType) {\n                wrapIf(currentNext);\n            } else {\n\n                if (!!(currentNext.compareDocumentPosition(endContainer) & 16)) {\n                    this.walkDom(currentNext, (e) => {\n                        if (e === endContainer) {\n                            return false;\n                        }\n                        if (Node.TEXT_NODE === e.nodeType) {\n                            wrapIf(e);\n                        }\n                        return true;\n                    });\n                    found = true;\n                } else {\n                    this._walkTextNodes(currentNext, (el) => {\n                        wrapIf(el);\n                    });\n                }\n                if (found) {\n                    return true;\n                }\n            }\n        }\n        return found;\n    }\n\n    /**\n     * Recursively walks the dom tree unless func returns false\n     * This is a lot more efficient then using any jQuery operations\n     *\n     * Applies node to function\n     * @param node\n     * @param func\n     * @returns {*}\n     */\n    walkDom(node, func) {\n        if (!node) {\n            return false;\n        }\n        var children = node.childNodes;\n        if (!children) {\n            return false;\n        }\n        for (var i = 0; i < children.length; i++) {\n            if (!this.walkDom(children[i], func)) {\n                return false;\n            }\n        }\n        return func(node);\n    }\n\n    /**\n     * Marks text of the same node\n     * @param {Node} textNode\n     * @param {int} startIndex\n     * @param {int} endIndex\n     * @private\n     */\n    _markTextSameNode(textNode, startIndex, endIndex) {\n\n        let initialText   = textNode.nodeValue,\n            initialIndex  = Util.calcIndex(textNode);\n\n        if (!initialText) {\n            return false;\n        }\n\n        //If there is an unmarked part in the beginning of the text node,\n        //cut off that part and put it into it's own textnode.\n        if (startIndex > 0) {\n            var textBefore = initialText.slice(0, startIndex);\n            textNode.parentNode.insertBefore(global.document.createTextNode(textBefore), textNode);\n            // wrap cutted text node:\n            Util.wrap(textNode.previousSibling, this._createSplitContainer(textNode,\n                initialIndex, Rendering._getOffsetParentIfHas(textNode)));\n        }\n        //If there is an unmarked part at the end of the text node,\n        //cut off that part and put it into it's own textnode.\n        if (endIndex < initialText.length) {\n            var textAfter = initialText.slice(endIndex, initialText.length);\n            textNode.parentNode.insertBefore(global.document.createTextNode(textAfter), textNode.nextSibling);\n            Util.wrap(textNode.nextSibling, this._createSplitContainer(textNode,\n                initialIndex, Rendering._getOffsetParentIfHas(textNode) + endIndex));\n        }\n\n        //Cutoff the unmarked parts and wrap the textnode into a span.\n        textNode.nodeValue = initialText.slice(startIndex, endIndex);\n        this.startContainer = this._createWrap(textNode,\n            Rendering._getOffsetParentIfHas(textNode) + startIndex, initialIndex, true).parentNode;\n        this.endContainer = this.startContainer;\n        return this.startContainer;\n    }\n\n\n    /**\n     * Marks text of end and start containers if start and end nodes are different\n     * Important: There might be no end container!\n     *\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @returns {{startT: (Node), endT: (Node)}}\n     * @private\n     */\n    _markTextDifferentNode(startContainer, endContainer, startOffset, endOffset) {\n        // Get current for both start and end:\n        var startContainerIndex = Util.calcIndex(startContainer);\n        var endContainerIndex = Util.calcIndex(endContainer);\n\n        // Split text\n        var fullTextStartValue = startContainer.nodeValue;\n        // init with startContainer because we may have not a text node here\n        var startT = startContainer;\n\n        if (undefined !== fullTextStartValue) {\n            var partTextStartValue = fullTextStartValue.slice(startOffset, fullTextStartValue.length);\n            // Set new text to start node\n            startContainer.nodeValue = fullTextStartValue.slice(0, startOffset);\n\n            var offsetStart = Rendering._getOffsetParentIfHas(startContainer);\n            // Create a new node for splitted text, offset is the length of new startContainer.nodeValue:\n            startT = this._createStartOrEndContainer(startContainer, this.markerPrefix, partTextStartValue,\n                offsetStart === startOffset ? offsetStart : offsetStart + startOffset, startContainerIndex);\n            // Append this node after startContainer\n            startContainer.parentNode.insertBefore(startT, startContainer.nextSibling);\n            this.startContainer = startT;\n\n            if (startContainer.nodeValue) {\n                // Wrap start container in detection node, offset is always 0 or parent offset.\n                Util.wrap(startContainer, this._createSplitContainer(startContainer, startContainerIndex,\n                    Rendering._getOffsetParentIfHas(startContainer)));\n            }\n        }\n\n        // init with endContainer because we may have not a text node here\n        var endT = endContainer;\n\n        // 2. Extract end Text node,\n        var fullTextEndValue = endContainer.nodeValue;\n        // It's possible that end container value is null (if a whole paragraph is marked)\n        if (undefined !== fullTextEndValue) {\n            // Split text\n            var partTextEndValue = fullTextEndValue.slice(0, endOffset);\n            endContainer.nodeValue = fullTextEndValue.slice(endOffset, fullTextEndValue.length);\n            // End Container start offset is always 0 or parent offset.\n            endT = this._createStartOrEndContainer(endContainer, this.markerSuffix, partTextEndValue,\n                Rendering._getOffsetParentIfHas(endContainer), endContainerIndex);\n\n            endContainer.parentNode.insertBefore(endT, endContainer);\n            this.endContainer = endT;\n            var offsetParent = Rendering._getOffsetParentIfHas(endContainer);\n            Util.wrap(endContainer, this._createSplitContainer(endContainer, endContainerIndex,\n                offsetParent === endOffset ? offsetParent : offsetParent + endOffset));\n        }\n\n        return {startT: startT, endT: endT};\n    }\n\n    /**\n     * Will return the original first offset\n     * @param element\n     * @returns {int}\n     * @private\n     */\n    _findOriginalOffset(element) {\n        if (!element.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n            return 0;\n        }\n        var lengthElement = Util.parent(element, '[' + ATTR_DATA_ORIGINAL_OFFSET_START + ']');\n        return lengthElement ? parseInt(lengthElement.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : 0;\n    }\n\n    /**\n     * Renders a selection\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {Node} commonAncestor\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @param {boolean} [withoutResult] if true result will not be calculated\n     * @returns {{startOffset: (int), endOffset: (int)}} the original offsets found\n     * @private\n     */\n    _renderWithElements(startContainer, endContainer, commonAncestor, startOffset, endOffset, withoutResult) {\n        var outer = Util.parents(startContainer, commonAncestor);\n        outer = outer[outer.length - 1];\n        var contextContainer = outer ? outer : commonAncestor;\n\n        // Same Element, means the selection is fully contained in a discrete area, start and endpoint have the same parent\n        // but are different nodes:\n\n        // Start and End offset have to be recalculated because dom might be already changed by highlighting in given node\n        // 1: First detect real start offset in startContainer:\n\n        // That works by selecting the highest wrapper and get original-offset-start data element, see \"findOriginalOffset\"\n        // So first select that container:\n        var originalStartOffset = this._findOriginalOffset(startContainer);\n        var originalEndOffset = this._findOriginalOffset(endContainer);\n\n        // We may run into Browser Bugs:\n\n        // If both are not text nodes, use next sibling as endContainer\n        if (startContainer.nodeType !== Node.TEXT_NODE && endContainer.nodeType !== Node.TEXT_NODE) {\n            if (startContainer === endContainer) {\n                endContainer = endContainer.nextElementSibling || endContainer;\n            }\n        }\n        // IF start/end container is not type of text, select first child text node:\n        // We run in some bugs with firefox here that selects no text-nodes sometimes, trying to fix this here\n        // Sometimes does not work correctly... (specially when DOM was modified)\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            this.walkDom(startContainer, function (el) {\n                if (el.nodeType === Node.TEXT_NODE) {\n                    startContainer = el;\n                    return false;\n                }\n                return true;\n            });\n        }\n\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            // Get the last text node:\n            var endContainerContents = Util.closest(startContainer, ':not([' + DATA_IS_SELECTION + '])').childNodes;\n            if (endContainerContents.length) {\n                var r = endContainerContents[endContainerContents.length - 1];\n                if (r.nodeType === Node.TEXT_NODE) {\n                    endContainer = r;\n                    endOffset = r.length;\n                } else {\n                    var f = r.lastChild;\n                    while (f !== null) {\n                        if (f && f.nodeType === Node.TEXT_NODE) {\n                            endContainer = f;\n                            endOffset = f.length;\n                            if (f.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n                                endOffset = parseInt(f.parentNode\n                                    .getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) + endOffset;\n                            }\n                        }\n                        f = f.lastChild;\n                    }\n                }\n            }\n            // still no textNode?\n            if (endContainer.nodeType !== Node.TEXT_NODE) {\n                throw 'Could not found endContainer, highlighting would be unstable';\n            }\n        }\n\n        var result = withoutResult || {\n            // Real offset is calculated by relative length and absolute length\n            startOffset: originalStartOffset + startOffset,\n            endOffset: originalEndOffset + endOffset,\n            // get the path for this selection\n            startContainerPath: Util.getPath(startContainer, this.context),\n            endContainerPath: Util.getPath(endContainer, this.context)\n        };\n\n        this._renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer);\n\n        return result;\n    }\n\n    /**\n     * Renders a given selection\n     *\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @param {Node} contextContainer\n     * @param {Node} outer\n     * @private\n     */\n    _renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer) {\n\n        // if start and end-container are the same, mark text on the same node\n        if (startContainer === endContainer) {\n            this._markTextSameNode(startContainer, startOffset, endOffset);\n        } else {\n            var result = this._markTextDifferentNode(startContainer, endContainer, startOffset, endOffset);\n            if (!outer) {\n                this.wrapSiblings(result.startT.nextSibling, endContainer);\n            } else {\n                this.walk(result.startT, endContainer, contextContainer);\n            }\n        }\n    }\n\n\n    /**\n     * Deserializes a specific path and finds the right textnodes\n     * This even works when DOM has been manipulated before by `marklib`\n     * @param {string} path the serialized path (including offsets)\n     * @return {Node}\n     * @private\n     */\n    _deserializePath(path) {\n        var pSplit = path.split(';'), p = pSplit[0],\n            objectIndex = parseInt(pSplit[1]),\n            charOffset = parseInt(pSplit[2]),\n            container = this.context.querySelector(p), maybeFoundNode = null;\n        this.walkDom(container, function (n) {\n            if (n.nodeType === Node.TEXT_NODE) {\n                var atrOffsetStart = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START);\n                atrOffsetStart = null === atrOffsetStart ? 0 : atrOffsetStart;\n                var atrIndex = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_INDEX);\n                atrIndex = null === atrIndex ? Util.calcIndex(n) : atrIndex;\n                if (atrIndex == objectIndex && charOffset >= atrOffsetStart &&\n                    ((parseInt(atrOffsetStart) + n.length) >= charOffset)) {\n                    var thisOffset = n.parentNode\n                        .hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START) ? charOffset -\n                    parseInt(n.parentNode\n                        .getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : charOffset;\n                    maybeFoundNode = {node: n, offset: thisOffset};\n                    return false;\n                }\n            } else {\n                return true;\n            }\n            return true;\n        });\n\n        return maybeFoundNode;\n    }\n\n    /**\n     * Prepares to render a Selection with path selectors\n     * ```\n     * A Path looks like this:\n     *\n     * #selector;#textnode;#offset\n     * ``\n     * @param {string} startPath\n     * @param {string} endPath\n     * @returns {*}\n     */\n    renderWithPath(startPath, endPath) {\n        var startContainer = this._deserializePath(startPath);\n        var endContainer = this._deserializePath(endPath);\n        if (startContainer && endContainer && startContainer.node && endContainer.node) {\n            var range = document.createRange();\n            range.setStart(startContainer.node, startContainer.offset);\n            range.setEnd(endContainer.node, endContainer.offset);\n            this.renderWithRange(range, true);\n            return range;\n        }\n        throw 'Could not find start- and/or end-container in document';\n    }\n\n\n    /**\n     * Prepares a selection with a range object\n     * @param {Range} range\n     * @param {boolean} [withoutResult] optional do calculate a result, the selection would not be serializable\n     * @returns {*}\n     */\n    renderWithRange(range, withoutResult) {\n        return this._renderWithElements(range.startContainer, range.endContainer,\n            range.commonAncestorContainer, range.startOffset, range.endOffset, withoutResult);\n    }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/jshint-loader!./src/main/Rendering.js\n **/","/* global Node, NodeList, Element */\n\n/**\n * @type {string}\n */\nexport const ATTR_DATA_ORIGINAL_INDEX = 'data-original-index';\n/**\n * @type {string}\n */\nexport const DATA_PSEUDO = 'data-is-pseudo';\n/**\n * @type {string}\n */\nexport const DATA_IS_SELECTION = 'data-is-selection';\n/**\n * @type {string}\n */\nconst SERIALIZE_SEPARATOR = \";\";\n\n// polyfill for matchesSelector, IE 10/11 does not support Element.matches\nif (Element && !Element.prototype.matches) {\n    var p = Element.prototype;\n    p.matches = p.matchesSelector ||\n    p.mozMatchesSelector || p.msMatchesSelector ||\n    p.oMatchesSelector || p.webkitMatchesSelector;\n}\n\n/**\n * Utility class\n * Contains DOM/Node manipulation helpers\n */\nexport default\nclass Util {\n    /**\n     * Filter for a NodeList\n     * @param {NodeList} nodes\n     * @param {Function} func\n     * @returns {Array.<HTMLElement>}\n     */\n    static nodeListFilter(nodes, func) {\n        return Array.prototype.filter.call(nodes || [], func);\n    }\n\n\n    /**\n     * Generates a unique id\n     * @return {String}\n     */\n    static guid() {\n        function s4() {\n            return Math.floor((1 + Math.random()) * 0x10000)\n                .toString(16)\n                .substring(1);\n        }\n\n        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n            s4() + '-' + s4() + s4() + s4();\n    }\n\n    /**\n     * Checks if a given node is empty\n     * @param {HTMLElement} node\n     * @returns {*}\n     */\n    static nodeIsEmpty(node) {\n        return node.nodeValue.match(/^[\\s]*$/g);\n    }\n\n\n    /**\n     * @param {HTMLElement} node\n     * @param [optionalList]\n     * @return {int} the index of this node in context to it's siblings\n     */\n    static index(node, optionalList) {\n        var children = optionalList || (node.nodeType === Node.TEXT_NODE ? node.parentNode.childNodes : node.parentNode.children);\n        return Array.prototype.indexOf.call(children || [], node);\n    }\n\n    /**\n     * Wraps given `elms` in given `wrapper`\n     *\n     * @param {HTMLElement} wrapper\n     * @param {HTMLElement|Array.<HTMLElement>} elms\n     * @return {HTMLElement}\n     */\n    static wrap(elms, wrapper) {\n        if (!elms) return wrapper;\n        // Convert `elms` to an array, if necessary.\n        if (!(elms instanceof NodeList || elms instanceof Array)) elms = [elms];\n        for (var i = elms.length - 1; i >= 0; i--) {\n            var child = (i > 0) ? wrapper.cloneNode(true) : wrapper;\n            var el = elms[i];\n            // Cache the current parent and sibling.\n            var parent = el.parentNode, sibling = el.nextSibling;\n\n            child.appendChild(el);\n            if (sibling) {\n                parent.insertBefore(child, sibling);\n            } else {\n                parent.appendChild(child);\n            }\n        }\n        return wrapper;\n    }\n\n    /**\n     * Will calculate an index depending on an already modified dom by marklib\n     * @param {HTMLElement} node\n     * @returns {int|boolean}\n     */\n    static calcIndex(node) {\n        var calculatedIndex = 0;\n        var foundWrapper = false;\n        var nodes = node.childNodes, length = nodes.length;\n        for (let thisIndex = 0; thisIndex < length; thisIndex++) {\n            var el = nodes[thisIndex];\n            if (el === node) {\n                return false;\n            }\n            var maybeIndexOfOriginal = el.getAttribute(ATTR_DATA_ORIGINAL_INDEX);\n            var isOriginal = maybeIndexOfOriginal !== undefined;\n            // Important: do not include pseudo elements\n            if (el !== node && (el.nodeType !== Node.TEXT_NODE || isOriginal) && !el.hasAttribute(DATA_PSEUDO)) {\n                if (isOriginal) {\n                    calculatedIndex = parseInt(maybeIndexOfOriginal);\n                    foundWrapper = true;\n                } else {\n                    calculatedIndex++;\n                }\n            }\n        }\n        return foundWrapper ? calculatedIndex : Util.index(node);\n    }\n\n    /**\n     * @param {HTMLElement} el\n     * @param {String} [optionalSelector] will test given element against a selector\n     *  if matches, returns this element immediately\n     * @return {Array.<HTMLElement>} an array of all found parents of given element (and optional selector)\n     */\n    static parents(el, optionalSelector) {\n        var element = el;\n        var foundElements = [];\n        while (element.parentNode !== null) {\n            element = element.parentNode;\n            if (optionalSelector && ((element === optionalSelector) ||\n                ( (typeof optionalSelector === 'string') && element.matches && element.matches(optionalSelector)))) {\n                foundElements.push(element);\n            } else if (!optionalSelector) {\n                foundElements.push(element);\n            }\n        }\n        return foundElements;\n    }\n\n    /**\n     * Finds a parent node (the closest) with a given selector\n     * @param {Node} el\n     * @param {String} selector\n     * @returns {*}\n     */\n    static parent(el, selector) {\n        var element = el;\n        while (element.parentNode !== null) {\n            element = element.parentNode;\n            if (element.matches && element.matches(selector)) {\n                return element;\n            }\n        }\n        return false;\n    }\n\n    static closest(el, selector) {\n        var element = el;\n        while (element !== null) {\n            if (element.matches && element.matches(selector)) {\n                return element;\n            }\n            element = element.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * Determines the correct paths and excludes all `marklib` generated content\n     * TODO: To improve performance we could shorten the path if an ID is present in it.\n     * @param {HTMLElement} el\n     * @param {HTMLElement} [context] if given extraction path is relative to this element\n     * @returns {*}\n     */\n    static getPath(el, context) {\n        var path = null, node = el;\n\n        while (node) {\n            var name = null;\n            // If node is a text-node, save index\n            if (Node.TEXT_NODE === node.nodeType) {\n\n                /* Because nodes may wrapped inside a highlighting node, we need to find the original index that was\n                 * valid before the dom changes. We store the last known index position inside all wrapper elements\n                 * We select the outermost\n                 */\n\n                // Extract original index of this node:\n                // Outer most data-original-index is original index\n                var outerMostElement = Util.parents(node, '[' + ATTR_DATA_ORIGINAL_INDEX + ']').reverse()[0];\n                // if element is not yet wrapped in span, recalculate index based on parent container:\n                // We have to do this because text node indexes != element indexes...\n                var calculatedIndex = 0;\n                if (!outerMostElement) {\n                    calculatedIndex = Util.calcIndex(node);\n                }\n                var index = outerMostElement ? parseInt(\n                    outerMostElement.getAttribute(ATTR_DATA_ORIGINAL_INDEX)) : calculatedIndex;\n                name = SERIALIZE_SEPARATOR + index;\n            } else {\n                name = node.nodeName;\n            }\n\n            if (!name) break;\n\n            name = name.toLowerCase();\n\n            var parent = node.parentNode;\n            if (node instanceof HTMLElement && node.hasAttribute(DATA_IS_SELECTION)) {\n                node = parent;\n                continue;\n            }\n            // Select only siblings that are not part of selection and are of the same type\n            // (because we use nth-of-type selector later)\n            var siblings = Util.nodeListFilter(parent.children, (el) => {\n                return !el.hasAttribute(DATA_IS_SELECTION) && el.nodeName === node.nodeName;\n            }), nodeIndex = Util.index(node, siblings);\n\n            if (siblings.length > 1 && nodeIndex >= 0) {\n                name += ':nth-of-type(' + (nodeIndex + 1) + ')';\n            }\n\n            path = name + (path ? '>' + path : '');\n\n            if (parent === context) {\n                break;\n            }\n\n            node = parent;\n        }\n\n        return path.replace(\"#document>\", \"\").replace('>;', ';');\n    }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/jshint-loader!./src/main/util/Util.js\n **/","\"use strict\";\n\nexports[\"default\"] = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/interop-require-default.js\n ** module id = 5\n ** module chunks = 0 1\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/define-property.js\n ** module id = 6\n ** module chunks = 0 1\n **/","\"use strict\";\n\nvar _Object$defineProperty = require(\"babel-runtime/core-js/object/define-property\")[\"default\"];\n\nexports[\"default\"] = (function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n\n      _Object$defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n})();\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/create-class.js\n ** module id = 7\n ** module chunks = 0 1\n **/","\"use strict\";\n\nexports[\"default\"] = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/class-call-check.js\n ** module id = 8\n ** module chunks = 0 1\n **/","var $ = require('../../modules/$');\r\nmodule.exports = function defineProperty(it, key, desc){\r\n  return $.setDesc(it, key, desc);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/fn/object/define-property.js\n ** module id = 9\n ** module chunks = 0 1\n **/","'use strict';\r\nvar global = typeof self != 'undefined' ? self : Function('return this')()\r\n  , core   = {}\r\n  , defineProperty = Object.defineProperty\r\n  , hasOwnProperty = {}.hasOwnProperty\r\n  , ceil  = Math.ceil\r\n  , floor = Math.floor\r\n  , max   = Math.max\r\n  , min   = Math.min;\r\n// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.\r\nvar DESC = !!function(){\r\n  try {\r\n    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;\r\n  } catch(e){ /* empty */ }\r\n}();\r\nvar hide = createDefiner(1);\r\n// 7.1.4 ToInteger\r\nfunction toInteger(it){\r\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\r\n}\r\nfunction desc(bitmap, value){\r\n  return {\r\n    enumerable  : !(bitmap & 1),\r\n    configurable: !(bitmap & 2),\r\n    writable    : !(bitmap & 4),\r\n    value       : value\r\n  };\r\n}\r\nfunction simpleSet(object, key, value){\r\n  object[key] = value;\r\n  return object;\r\n}\r\nfunction createDefiner(bitmap){\r\n  return DESC ? function(object, key, value){\r\n    return $.setDesc(object, key, desc(bitmap, value));\r\n  } : simpleSet;\r\n}\r\n\r\nfunction isObject(it){\r\n  return it !== null && (typeof it == 'object' || typeof it == 'function');\r\n}\r\nfunction isFunction(it){\r\n  return typeof it == 'function';\r\n}\r\nfunction assertDefined(it){\r\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\r\n  return it;\r\n}\r\n\r\nvar $ = module.exports = require('./$.fw')({\r\n  g: global,\r\n  core: core,\r\n  html: global.document && document.documentElement,\r\n  // http://jsperf.com/core-js-isobject\r\n  isObject:   isObject,\r\n  isFunction: isFunction,\r\n  it: function(it){\r\n    return it;\r\n  },\r\n  that: function(){\r\n    return this;\r\n  },\r\n  // 7.1.4 ToInteger\r\n  toInteger: toInteger,\r\n  // 7.1.15 ToLength\r\n  toLength: function(it){\r\n    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\r\n  },\r\n  toIndex: function(index, length){\r\n    index = toInteger(index);\r\n    return index < 0 ? max(index + length, 0) : min(index, length);\r\n  },\r\n  has: function(it, key){\r\n    return hasOwnProperty.call(it, key);\r\n  },\r\n  create:     Object.create,\r\n  getProto:   Object.getPrototypeOf,\r\n  DESC:       DESC,\r\n  desc:       desc,\r\n  getDesc:    Object.getOwnPropertyDescriptor,\r\n  setDesc:    defineProperty,\r\n  setDescs:   Object.defineProperties,\r\n  getKeys:    Object.keys,\r\n  getNames:   Object.getOwnPropertyNames,\r\n  getSymbols: Object.getOwnPropertySymbols,\r\n  assertDefined: assertDefined,\r\n  // Dummy, fix for not array-like ES3 string in es5 module\r\n  ES5Object: Object,\r\n  toObject: function(it){\r\n    return $.ES5Object(assertDefined(it));\r\n  },\r\n  hide: hide,\r\n  def: createDefiner(0),\r\n  set: global.Symbol ? simpleSet : hide,\r\n  mix: function(target, src){\r\n    for(var key in src)hide(target, key, src[key]);\r\n    return target;\r\n  },\r\n  each: [].forEach\r\n});\r\n/* eslint-disable no-undef */\r\nif(typeof __e != 'undefined')__e = core;\r\nif(typeof __g != 'undefined')__g = global;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.js\n ** module id = 10\n ** module chunks = 0 1\n **/","module.exports = function($){\r\n  $.FW   = false;\r\n  $.path = $.core;\r\n  return $;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.fw.js\n ** module id = 11\n ** module chunks = 0 1\n **/"],"sourceRoot":""}