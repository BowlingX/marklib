{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///marklib.min.js","webpack:///webpack/bootstrap 097d053c67111be39597","webpack:///./src/export.js","webpack:///./src/main/Rendering.js","webpack:///./src/main/util/Util.js","webpack:///./~/babel-runtime/helpers/interop-require.js","webpack:///./~/babel-runtime/helpers/class-call-check.js","webpack:///./~/babel-runtime/helpers/create-class.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequire","Rendering","Util","_classCallCheck","_createClass","_utilUtil","ATTR_DATA_ORIGINAL_INDEX","DATA_IS_SELECTION","TAG_NAME","ATTR_DATA_ORIGINAL_OFFSET_START","DATA_ORIGINAL_TEXT_NODE_INDEX","ATTR_DATA_START_END","ATTR_DATA_IS_HIGHLIGHT_NODE","ATTR_DATA_ID","document","cssClass","context","Document","guid","undefined","startContainer","endContainer","markerPrefix","markerSuffix","_onWrappedNodeFunc","getId","value","setId","onWrappedNode","f","_callOnWrappedNode","apply","arguments","_createWrapTemplate","el","createElement","vTrue","className","setAttribute","_createStartEndWrapTemplate","text","textContent","_createStartOrEndContainer","initialNode","prefix","offset","index","wrapper","_getIndexParentIfHas","marklibInstance","_createWrap","optionalLength","optionalIndex","optionalIsSameNode","originalIndex","calcIndex","offsetLength","_getOffsetParentIfHas","wrap","_createSplitContainer","originalElement","_walkTextNodes","func","walkDom","node","Node","TEXT_NODE","nodeType","nodeIsEmpty","walk","start","nextParent","nextParentNode","parentNode","currentParentNode","wrapSiblings","nextSibling","_this","next","found","n","hasAttribute","getAttribute","thisNode","classList","remove","removeAttribute","bind","wrapIf","currentNext","contains","e","children","childNodes","i","length","_markTextSameNode","textNode","startIndex","endIndex","initialText","nodeValue","initialIndex","textBefore","slice","insertBefore","Text","previousSibling","textAfter","_markTextDifferentNode","startOffset","endOffset","startContainerIndex","endContainerIndex","fullTextStartValue","startT","partTextStartValue","offsetStart","endT","fullTextEndValue","partTextEndValue","offsetParent","_findOriginalOffset","element","lengthElement","parent","parseInt","_renderWithElements","commonAncestor","outer","parents","contextContainer","originalStartOffset","originalEndOffset","nextElementSibling","endContainerContents","closest","r","lastChild","result","startContainerPath","getPath","endContainerPath","_renderSelection","_deserializePath","path","pSplit","split","objectIndex","charOffset","container","querySelector","maybeFoundNode","atrOffsetStart","atrIndex","thisOffset","renderWithPath","startPath","endPath","range","createRange","setStart","setEnd","renderWithRange","commonAncestorContainer","thisIndex","Object","defineProperty","DATA_PSEUDO","SERIALIZE_SEPARATOR","nodeListFilter","nodes","Array","prototype","filter","s4","Math","floor","random","toString","substring","match","optionalList","indexOf","elms","NodeList","child","cloneNode","sibling","appendChild","calculatedIndex","foundWrapper","maybeIndexOfOriginal","isOriginal","optionalSelector","foundElements","matches","push","selector","name","outerMostElement","reverse","nodeName","toLowerCase","HTMLElement","siblings","nodeIndex","replace","obj","__esModule","instance","Constructor","TypeError","defineProperties","target","props","key","prop","configurable","writable","protoProps","staticProps"],"mappings":"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","file":"marklib.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Marklib\"] = factory();\n\telse\n\t\troot[\"Marklib\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Marklib\"] = factory();\n\telse\n\t\troot[\"Marklib\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = __webpack_require__(3)[\"default\"];\n\n\tvar Rendering = _interopRequire(__webpack_require__(1));\n\n\tvar Util = _interopRequire(__webpack_require__(2));\n\n\tmodule.exports = {\n\t    Rendering: Rendering,\n\t    Util: Util\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global Node, Text, Rendering, Document */\n\t\"use strict\";\n\n\tvar _classCallCheck = __webpack_require__(4)[\"default\"];\n\n\tvar _createClass = __webpack_require__(5)[\"default\"];\n\n\tvar _interopRequire = __webpack_require__(3)[\"default\"];\n\n\tvar _utilUtil = __webpack_require__(2);\n\n\tvar Util = _interopRequire(_utilUtil);\n\n\tvar ATTR_DATA_ORIGINAL_INDEX = _utilUtil.ATTR_DATA_ORIGINAL_INDEX;\n\tvar DATA_IS_SELECTION = _utilUtil.DATA_IS_SELECTION;\n\n\t/**\n\t * @type {string}\n\t */\n\tvar TAG_NAME = \"x-marker\";\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ORIGINAL_OFFSET_START = \"data-original-offset-start\";\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_ORIGINAL_TEXT_NODE_INDEX = \"original-text-node-index\";\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_START_END = \"data-is-start-end\";\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_IS_HIGHLIGHT_NODE = \"data-is-highlight-node\";\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ID = \"data-selection-id\";\n\n\tvar Rendering = (function () {\n\t    function Rendering(document, cssClass, context) {\n\t        _classCallCheck(this, Rendering);\n\n\t        if (!(document instanceof Document)) {\n\t            throw \"Marklib {0} is required to be a document instance\";\n\t        }\n\t        /**\n\t         * @type {Document}\n\t         */\n\t        this.document = document;\n\n\t        /**\n\t         * ID of rendering, will be set on each element that is part of it\n\t         * @type {String}\n\t         */\n\t        this.id = Util.guid();\n\n\t        /**\n\t         * Class that is set on all highlight nodes\n\t         * @type {String}\n\t         */\n\t        this.cssClass = undefined === cssClass ? \"marking\" : cssClass;\n\n\t        /**\n\t         * StartContainer\n\t         * @type {Node}\n\t         */\n\t        this.startContainer = null;\n\n\t        /**\n\t         * EndContainer\n\t         * @type {Node}\n\t         */\n\t        this.endContainer = null;\n\n\t        /**\n\t         * Prefix before ID\n\t         * @type {string}\n\t         */\n\t        this.markerPrefix = \"marker-start-\";\n\n\t        /**\n\t         * Suffix before ID\n\t         * @type {string}\n\t         */\n\t        this.markerSuffix = \"marker-end-\";\n\n\t        /**\n\t         * @type {Node}\n\t         */\n\t        this.context = context || this.document;\n\n\t        /**\n\t         * @type {Function}\n\t         * @private\n\t         */\n\t        this._onWrappedNodeFunc = null;\n\t    }\n\n\t    _createClass(Rendering, {\n\t        getId: {\n\n\t            /**\n\t             * @returns {string} id of this rendering\n\t             */\n\n\t            value: function getId() {\n\t                return this.id;\n\t            }\n\t        },\n\t        setId: {\n\n\t            /**\n\t             * @param {string} id\n\t             * @returns {Rendering}\n\t             */\n\n\t            value: function setId(id) {\n\t                this.id = id;\n\t                return this;\n\t            }\n\t        },\n\t        onWrappedNode: {\n\n\t            /**\n\t             * Listener that is called when a node is wrapped on this instance\n\t             * @param {Function} f\n\t             * @returns {Rendering}\n\t             */\n\n\t            value: function onWrappedNode(f) {\n\t                this._onWrappedNodeFunc = f;\n\t                return this;\n\t            }\n\t        },\n\t        _callOnWrappedNode: {\n\n\t            /**\n\t             * @private\n\t             */\n\n\t            value: function _callOnWrappedNode() {\n\t                if (\"function\" === typeof this._onWrappedNodeFunc) {\n\t                    this._onWrappedNodeFunc.apply(this, arguments);\n\t                }\n\t            }\n\t        },\n\t        _createWrapTemplate: {\n\n\t            /**\n\t             * Creates a Template used as a wrapper\n\t             * @returns {Node}\n\t             * @private\n\t             */\n\n\t            value: function _createWrapTemplate() {\n\t                var el = this.document.createElement(TAG_NAME),\n\t                    vTrue = \"true\";\n\t                el.className = this.cssClass;\n\t                el.setAttribute(DATA_IS_SELECTION, vTrue);\n\t                el.setAttribute(ATTR_DATA_ID, this.getId());\n\t                el.setAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE, vTrue);\n\n\t                return el;\n\t            }\n\t        },\n\t        _createStartEndWrapTemplate: {\n\n\t            /**\n\t             * Creates a Template to use as start and end marks\n\t             * @param {String} id\n\t             * @param {String} text\n\t             * @returns {Node}\n\t             * @private\n\t             */\n\n\t            value: function _createStartEndWrapTemplate(id, text) {\n\t                var el = this._createWrapTemplate(),\n\t                    vTrue = \"true\";\n\t                el.setAttribute(ATTR_DATA_START_END, vTrue);\n\t                el.id = id;\n\t                el.textContent = text;\n\t                return el;\n\t            }\n\t        },\n\t        _createStartOrEndContainer: {\n\n\t            /**\n\t             * Creates Start or End Container Element\n\t             * @param initialNode\n\t             * @param prefix\n\t             * @param text\n\t             * @param offset\n\t             * @param index\n\t             * @returns {Node}\n\t             */\n\n\t            value: function _createStartOrEndContainer(initialNode, prefix, text, offset, index) {\n\t                var wrapper = this._createStartEndWrapTemplate(prefix + this.getId(), text);\n\t                wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(initialNode, index));\n\t                wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n\t                wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n\t                wrapper.marklibInstance = this;\n\t                return wrapper;\n\t            }\n\t        },\n\t        _createWrap: {\n\n\t            /**\n\t             * Wraps given element\n\t             * @param {Node} el\n\t             * @param [optionalLength]\n\t             * @param [optionalIndex]\n\t             * @param [optionalIsSameNode]\n\t             * @returns {Node}\n\t             * @private\n\t             */\n\n\t            value: function _createWrap(el, optionalLength, optionalIndex, optionalIsSameNode) {\n\t                var originalIndex = optionalIndex >= 0 ? optionalIndex : Util.calcIndex(el);\n\t                var wrapper = this._createWrapTemplate();\n\t                wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(el, originalIndex));\n\t                var offsetLength = optionalLength >= 0 ? optionalLength : Rendering._getOffsetParentIfHas(el);\n\t                wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offsetLength);\n\n\t                // Save a reference to original text node in wrapper\n\t                wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, originalIndex);\n\n\t                // save this marker instance to given node\n\t                wrapper.marklibInstance = this;\n\n\t                if (optionalIsSameNode) {\n\t                    wrapper.setAttribute(ATTR_DATA_START_END, ATTR_DATA_START_END);\n\t                }\n\t                var wrap = Util.wrap(el, wrapper);\n\t                this._callOnWrappedNode(el, wrap);\n\t                return wrap;\n\t            }\n\t        },\n\t        _createSplitContainer: {\n\n\t            /**\n\t             * Create split container element\n\t             * @param originalElement {Node} original text node element that is created a wrapper for\n\t             * @param index\n\t             * @param offset\n\t             * @returns {*|jQuery|Node}\n\t             */\n\n\t            value: function _createSplitContainer(originalElement, index, offset) {\n\t                var wrapper = this.document.createElement(TAG_NAME),\n\t                    vTrue = \"true\";\n\t                wrapper.setAttribute(DATA_IS_SELECTION, vTrue);\n\t                wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(originalElement, index));\n\t                wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n\t                wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n\t                return wrapper;\n\t            }\n\t        },\n\t        _walkTextNodes: {\n\n\t            /**\n\t             * Extracts all TextNodes inside a container\n\t             * @param {Node} el\n\t             * @returns {Array.<Text>}\n\t             */\n\n\t            value: function _walkTextNodes(el, func) {\n\t                this.walkDom(el, function (node) {\n\t                    if (Node.TEXT_NODE === node.nodeType && !Util.nodeIsEmpty(node)) {\n\t                        func(node);\n\t                    }\n\t                    return true;\n\t                });\n\t            }\n\t        },\n\t        walk: {\n\n\t            /**\n\t             * Walks the tree\n\t             * @param start\n\t             * @param endContainer\n\t             * @param nextParent\n\t             */\n\n\t            value: function walk(start, endContainer, nextParent) {\n\t                var nextParentNode = start;\n\t                while (nextParentNode && nextParentNode !== nextParent.parentNode) {\n\t                    var currentParentNode = nextParentNode;\n\t                    nextParentNode = nextParentNode.parentNode;\n\t                    if (this.wrapSiblings(currentParentNode.nextSibling, endContainer)) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        wrapSiblings: {\n\n\t            /**\n\t             * Will Wrap all textNode siblings of a container (start) inside a defined Element (like a span)\n\t             * If an Element node is found, it will wrap all children of this node inside a element as well.\n\t             * It will stop if endContainer is found as a node\n\t             *\n\t             * @param {Node} start\n\t             * @param {Node} endContainer\n\t             * @returns {boolean} (true if endContainer was found)\n\t             */\n\n\t            value: function wrapSiblings(start, endContainer) {\n\t                var _this = this;\n\n\t                var next = start;\n\t                var found = false;\n\n\t                // Capsule some logic\n\t                var wrap = (function (n) {\n\t                    if (n.parentNode.hasAttribute(ATTR_DATA_START_END) && n.parentNode.hasAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE) && n.parentNode.getAttribute(ATTR_DATA_ID) == _this.getId()) {\n\t                        var thisNode = _this._createWrap(n).parentNode;\n\t                        thisNode.classList.remove(_this.cssClass);\n\t                        thisNode.removeAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE);\n\t                    } else {\n\t                        _this._createWrap(n);\n\t                    }\n\t                }).bind(this);\n\n\t                var wrapIf = function (n) {\n\t                    if (!Util.nodeIsEmpty(n)) {\n\t                        wrap(n);\n\t                    }\n\t                };\n\t                while (null !== next && next !== endContainer) {\n\t                    var currentNext = next;\n\t                    next = next.nextSibling;\n\t                    // Found a text node, directly wrap inside a span\n\t                    if (Node.TEXT_NODE === currentNext.nodeType) {\n\t                        wrapIf(currentNext);\n\t                    } else {\n\t                        if (currentNext.contains(endContainer)) {\n\t                            this.walkDom(currentNext, function (e) {\n\t                                if (e === endContainer) {\n\t                                    return false;\n\t                                }\n\t                                if (Node.TEXT_NODE === e.nodeType) {\n\t                                    wrapIf(e);\n\t                                }\n\t                                return true;\n\t                            });\n\t                            found = true;\n\t                        } else {\n\t                            this._walkTextNodes(currentNext, function (el) {\n\t                                wrapIf(el);\n\t                            });\n\t                        }\n\t                        if (found) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                return found;\n\t            }\n\t        },\n\t        walkDom: {\n\n\t            /**\n\t             * Recursively walks the dom tree unless func returns false\n\t             * This is a lot more efficient then using any jQuery operations\n\t             *\n\t             * Applies node to function\n\t             * @param node\n\t             * @param func\n\t             * @returns {*}\n\t             */\n\n\t            value: function walkDom(node, func) {\n\t                if (!node) {\n\t                    return false;\n\t                }\n\t                var children = node.childNodes;\n\t                if (!children) {\n\t                    return false;\n\t                }\n\t                for (var i = 0; i < children.length; i++) {\n\t                    if (!this.walkDom(children[i], func)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return func(node);\n\t            }\n\t        },\n\t        _markTextSameNode: {\n\n\t            /**\n\t             * Marks text of the same node\n\t             * @param {Node} textNode\n\t             * @param {int} startIndex\n\t             * @param {int} endIndex\n\t             * @private\n\t             */\n\n\t            value: function _markTextSameNode(textNode, startIndex, endIndex) {\n\t                var initialText = textNode.nodeValue;\n\t                var initialIndex = Util.calcIndex(textNode);\n\t                if (!initialText) {\n\t                    return false;\n\t                }\n\t                //If there is an unmarked part in the beginning of the text node,\n\t                //cut off that part and put it into it's own textnode.\n\t                if (startIndex > 0) {\n\t                    var textBefore = initialText.slice(0, startIndex);\n\t                    textNode.parentNode.insertBefore(new Text(textBefore), textNode);\n\t                    // wrap cutted text node:\n\t                    Util.wrap(textNode.previousSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode)));\n\t                }\n\t                //If there is an unmarked part at the end of the text node,\n\t                //cut off that part and put it into it's own textnode.\n\t                if (endIndex < initialText.length) {\n\t                    var textAfter = initialText.slice(endIndex, initialText.length);\n\t                    textNode.parentNode.insertBefore(new Text(textAfter), textNode.nextSibling);\n\n\t                    Util.wrap(textNode.nextSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode) + endIndex));\n\t                }\n\n\t                //Cutoff the unmarked parts and wrap the textnode into a span.\n\t                textNode.nodeValue = initialText.slice(startIndex, endIndex);\n\t                this.startContainer = this._createWrap(textNode, Rendering._getOffsetParentIfHas(textNode) + startIndex, initialIndex, true).parentNode;\n\t                this.endContainer = this.startContainer;\n\t                return this.startContainer;\n\t            }\n\t        },\n\t        _markTextDifferentNode: {\n\n\t            /**\n\t             * Marks text of end and start containers if start and end nodes are different\n\t             * Important: There might be no end container!\n\t             *\n\t             * @param {Node} startContainer\n\t             * @param {Node} endContainer\n\t             * @param {int} startOffset\n\t             * @param {int} endOffset\n\t             * @returns {{startT: (Node), endT: (Node)}}\n\t             * @private\n\t             */\n\n\t            value: function _markTextDifferentNode(startContainer, endContainer, startOffset, endOffset) {\n\t                // Get current for both start and end:\n\t                var startContainerIndex = Util.calcIndex(startContainer);\n\t                var endContainerIndex = Util.calcIndex(endContainer);\n\n\t                // Split text\n\t                var fullTextStartValue = startContainer.nodeValue;\n\t                // init with startContainer because we may have not a text node here\n\t                var startT = startContainer;\n\n\t                if (undefined !== fullTextStartValue) {\n\t                    var partTextStartValue = fullTextStartValue.slice(startOffset, fullTextStartValue.length);\n\t                    // Set new text to start node\n\t                    startContainer.nodeValue = fullTextStartValue.slice(0, startOffset);\n\n\t                    var offsetStart = Rendering._getOffsetParentIfHas(startContainer);\n\t                    // Create a new node for splitted text, offset is the length of new startContainer.nodeValue:\n\t                    startT = this._createStartOrEndContainer(startContainer, this.markerPrefix, partTextStartValue, offsetStart === startOffset ? offsetStart : offsetStart + startOffset, startContainerIndex);\n\t                    // Append this node after startContainer\n\t                    startContainer.parentNode.insertBefore(startT, startContainer.nextSibling);\n\t                    this.startContainer = startT;\n\n\t                    if (startContainer.nodeValue) {\n\t                        // Wrap start container in detection node, offset is always 0 or parent offset.\n\t                        Util.wrap(startContainer, this._createSplitContainer(startContainer, startContainerIndex, Rendering._getOffsetParentIfHas(startContainer)));\n\t                    }\n\t                }\n\n\t                // init with endContainer because we may have not a text node here\n\t                var endT = endContainer;\n\n\t                // 2. Extract end Text node,\n\t                var fullTextEndValue = endContainer.nodeValue;\n\t                // It's possible that end container value is null (if a whole paragraph is marked)\n\t                if (undefined !== fullTextEndValue) {\n\t                    // Split text\n\t                    var partTextEndValue = fullTextEndValue.slice(0, endOffset);\n\t                    endContainer.nodeValue = fullTextEndValue.slice(endOffset, fullTextEndValue.length);\n\t                    // End Container start offset is always 0 or parent offset.\n\t                    endT = this._createStartOrEndContainer(endContainer, this.markerSuffix, partTextEndValue, Rendering._getOffsetParentIfHas(endContainer), endContainerIndex);\n\n\t                    endContainer.parentNode.insertBefore(endT, endContainer);\n\t                    this.endContainer = endT;\n\t                    var offsetParent = Rendering._getOffsetParentIfHas(endContainer);\n\t                    Util.wrap(endContainer, this._createSplitContainer(endContainer, endContainerIndex, offsetParent === endOffset ? offsetParent : offsetParent + endOffset));\n\t                }\n\n\t                return { startT: startT, endT: endT };\n\t            }\n\t        },\n\t        _findOriginalOffset: {\n\n\t            /**\n\t             * Will return the original first offset\n\t             * @param element\n\t             * @returns {int}\n\t             * @private\n\t             */\n\n\t            value: function _findOriginalOffset(element) {\n\t                if (!element.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n\t                    return 0;\n\t                }\n\t                var lengthElement = Util.parent(element, \"[\" + ATTR_DATA_ORIGINAL_OFFSET_START + \"]\");\n\t                return lengthElement ? parseInt(lengthElement.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : 0;\n\t            }\n\t        },\n\t        _renderWithElements: {\n\n\t            /**\n\t             * Renders a selection\n\t             * @param {Node} startContainer\n\t             * @param {Node} endContainer\n\t             * @param {Node} commonAncestor\n\t             * @param {int} startOffset\n\t             * @param {int} endOffset\n\t             * @returns {{startOffset: (int), endOffset: (int)}} the original offsets found\n\t             * @private\n\t             */\n\n\t            value: function _renderWithElements(startContainer, endContainer, commonAncestor, startOffset, endOffset) {\n\t                var outer = Util.parents(startContainer, commonAncestor);\n\t                outer = outer[outer.length - 1];\n\t                var contextContainer = outer ? outer : commonAncestor;\n\n\t                // Same Element, means the selection is fully contained in a discrete area, start and endpoint have the same parent\n\t                // but are different nodes:\n\n\t                // Start and End offset have to be recalculated because dom might be already changed by highlighting in given node\n\t                // 1: First detect real start offset in startContainer:\n\n\t                // That works by selecting the highest wrapper and get original-offset-start data element, see \"findOriginalOffset\"\n\t                // So first select that container:\n\t                var originalStartOffset = this._findOriginalOffset(startContainer);\n\t                var originalEndOffset = this._findOriginalOffset(endContainer);\n\n\t                // We may run into Browser Bugs:\n\n\t                // If both are not text nodes, use next sibling as endContainer\n\t                if (startContainer.nodeType !== Node.TEXT_NODE && endContainer.nodeType !== Node.TEXT_NODE) {\n\t                    if (startContainer === endContainer) {\n\t                        endContainer = endContainer.nextElementSibling || endContainer;\n\t                    }\n\t                }\n\t                // IF start/end container is not type of text, select first child text node:\n\t                // We run in some bugs with firefox here that selects no text-nodes sometimes, trying to fix this here\n\t                // Sometimes does not work correctly... (specially when DOM was modified)\n\t                if (startContainer.nodeType !== Node.TEXT_NODE) {\n\t                    this.walkDom(startContainer, function (el) {\n\t                        if (el.nodeType === Node.TEXT_NODE) {\n\t                            startContainer = el;\n\t                            return false;\n\t                        }\n\t                        return true;\n\t                    });\n\t                }\n\n\t                if (endContainer.nodeType !== Node.TEXT_NODE) {\n\t                    // Get the last text node:\n\t                    var endContainerContents = Util.closest(startContainer, \":not([\" + DATA_IS_SELECTION + \"])\").childNodes;\n\t                    if (endContainerContents.length) {\n\t                        var r = endContainerContents[endContainerContents.length - 1];\n\t                        if (r.nodeType === Node.TEXT_NODE) {\n\t                            endContainer = r;\n\t                            endOffset = r.length;\n\t                        } else {\n\t                            var f = r.lastChild;\n\t                            while (f !== null) {\n\t                                if (f && f.nodeType === Node.TEXT_NODE) {\n\t                                    endContainer = f;\n\t                                    endOffset = f.length;\n\t                                    if (f.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n\t                                        endOffset = parseInt(f.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) + endOffset;\n\t                                    }\n\t                                }\n\t                                f = f.lastChild;\n\t                            }\n\t                        }\n\t                    }\n\t                    // still no textNode?\n\t                    if (endContainer.nodeType !== Node.TEXT_NODE) {\n\t                        throw \"Could not found endContainer, highlighting would be unstable\";\n\t                    }\n\t                }\n\n\t                var result = {\n\t                    // Real offset is calculated by relative length and absolute length\n\t                    startOffset: originalStartOffset + startOffset,\n\t                    endOffset: originalEndOffset + endOffset,\n\t                    // get the path for this selection\n\t                    startContainerPath: Util.getPath(startContainer, this.context),\n\t                    endContainerPath: Util.getPath(endContainer, this.context)\n\t                };\n\n\t                this._renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer);\n\n\t                return result;\n\t            }\n\t        },\n\t        _renderSelection: {\n\n\t            /**\n\t             * Renders a given selection\n\t             *\n\t             * @param {Node} startContainer\n\t             * @param {Node} endContainer\n\t             * @param {int} startOffset\n\t             * @param {int} endOffset\n\t             * @param {Node} contextContainer\n\t             * @param {Node} outer\n\t             * @private\n\t             */\n\n\t            value: function _renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer) {\n\n\t                // if start and end-container are the same, mark text on the same node\n\t                if (startContainer === endContainer) {\n\t                    this._markTextSameNode(startContainer, startOffset, endOffset);\n\t                } else {\n\t                    var result = this._markTextDifferentNode(startContainer, endContainer, startOffset, endOffset);\n\t                    if (!outer) {\n\t                        this.wrapSiblings(result.startT.nextSibling, endContainer);\n\t                    } else {\n\t                        this.walk(result.startT, endContainer, contextContainer);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _deserializePath: {\n\n\t            /**\n\t             * Deserializes a specific path and finds the right textnodes\n\t             * This even works when DOM has been manipulated before by `marklib`\n\t             * @param {string} path the serialized path (including offsets)\n\t             * @return {Node}\n\t             * @private\n\t             */\n\n\t            value: function _deserializePath(path) {\n\t                var pSplit = path.split(\";\"),\n\t                    p = pSplit[0],\n\t                    objectIndex = parseInt(pSplit[1]),\n\t                    charOffset = parseInt(pSplit[2]),\n\t                    container = this.context.querySelector(p),\n\t                    maybeFoundNode = null;\n\t                this.walkDom(container, function (n) {\n\t                    if (n.nodeType === Node.TEXT_NODE) {\n\t                        var atrOffsetStart = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START);\n\t                        atrOffsetStart = null === atrOffsetStart ? 0 : atrOffsetStart;\n\t                        var atrIndex = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_INDEX);\n\t                        atrIndex = null === atrIndex ? Util.calcIndex(n) : atrIndex;\n\t                        if (atrIndex == objectIndex && charOffset >= atrOffsetStart && parseInt(atrOffsetStart) + n.length >= charOffset) {\n\t                            var thisOffset = n.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START) ? charOffset - parseInt(n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : charOffset;\n\t                            maybeFoundNode = { node: n, offset: thisOffset };\n\t                            return false;\n\t                        }\n\t                    } else {\n\t                        return true;\n\t                    }\n\t                    return true;\n\t                });\n\n\t                return maybeFoundNode;\n\t            }\n\t        },\n\t        renderWithPath: {\n\n\t            /**\n\t             * Prepares to render a Selection with path selectors\n\t             * ```\n\t             * A Path looks like this:\n\t             *\n\t             * #selector;#textnode;#offset\n\t             * ``\n\t             * @param {string} startPath\n\t             * @param {string} endPath\n\t             * @returns {*}\n\t             */\n\n\t            value: function renderWithPath(startPath, endPath) {\n\t                var startContainer = this._deserializePath(startPath);\n\t                var endContainer = this._deserializePath(endPath);\n\t                if (startContainer && endContainer && startContainer.node && endContainer.node) {\n\t                    var range = document.createRange();\n\t                    range.setStart(startContainer.node, startContainer.offset);\n\t                    range.setEnd(endContainer.node, endContainer.offset);\n\t                    this.renderWithRange(range);\n\t                    return range;\n\t                }\n\t                throw \"Could not find start- and/or end-container in document\";\n\t            }\n\t        },\n\t        renderWithRange: {\n\n\t            /**\n\t             * Prepares a selection with a range object\n\t             * @param {Range} range\n\t             * @returns {*}\n\t             */\n\n\t            value: function renderWithRange(range) {\n\t                return this._renderWithElements(range.startContainer, range.endContainer, range.commonAncestorContainer, range.startOffset, range.endOffset);\n\t            }\n\t        }\n\t    }, {\n\t        _getIndexParentIfHas: {\n\n\t            /**\n\t             * @param {Node} container\n\t             * @param {Number} thisIndex\n\t             * @returns {int} index of parent or original\n\t             * @private\n\t             */\n\n\t            value: function _getIndexParentIfHas(container, thisIndex) {\n\t                var p = container.parentNode;\n\t                var index = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_INDEX));\n\t                return index > thisIndex ? index : thisIndex;\n\t            }\n\t        },\n\t        _getOffsetParentIfHas: {\n\n\t            /**\n\t             * @param container\n\t             * @returns {int} offset start of parent if has, else 0\n\t             */\n\n\t            value: function _getOffsetParentIfHas(container) {\n\t                var p = container.parentNode;\n\t                var offset = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START));\n\t                return offset > 0 ? offset : 0;\n\t            }\n\t        }\n\t    });\n\n\t    return Rendering;\n\t})();\n\n\tmodule.exports = Rendering;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _classCallCheck = __webpack_require__(4)[\"default\"];\n\n\tvar _createClass = __webpack_require__(5)[\"default\"];\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t/* global Node, NodeList */\n\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ORIGINAL_INDEX = \"data-original-index\";\n\texports.ATTR_DATA_ORIGINAL_INDEX = ATTR_DATA_ORIGINAL_INDEX;\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_PSEUDO = \"data-is-pseudo\";\n\texports.DATA_PSEUDO = DATA_PSEUDO;\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_IS_SELECTION = \"data-is-selection\";\n\texports.DATA_IS_SELECTION = DATA_IS_SELECTION;\n\t/**\n\t * @type {string}\n\t */\n\tvar SERIALIZE_SEPARATOR = \";\";\n\n\t/**\n\t * Utility class\n\t * Contains DOM/Node manipulation helpers\n\t */\n\n\tvar Util = (function () {\n\t    function Util() {\n\t        _classCallCheck(this, Util);\n\t    }\n\n\t    _createClass(Util, null, {\n\t        nodeListFilter: {\n\t            /**\n\t             * Filter for a NodeList\n\t             * @param {NodeList} nodes\n\t             * @param {Function} func\n\t             * @returns {Array.<HTMLElement>}\n\t             */\n\n\t            value: function nodeListFilter(nodes, func) {\n\t                return Array.prototype.filter.call(nodes || [], func);\n\t            }\n\t        },\n\t        guid: {\n\n\t            /**\n\t             * Generates a unique id\n\t             * @return {String}\n\t             */\n\n\t            value: function guid() {\n\t                function s4() {\n\t                    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);\n\t                }\n\n\t                return s4() + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + s4() + s4();\n\t            }\n\t        },\n\t        nodeIsEmpty: {\n\n\t            /**\n\t             * Checks if a given node is empty\n\t             * @param {HTMLElement} node\n\t             * @returns {*}\n\t             */\n\n\t            value: function nodeIsEmpty(node) {\n\t                return node.nodeValue.match(/^[\\s]*$/g);\n\t            }\n\t        },\n\t        index: {\n\n\t            /**\n\t             * @param {HTMLElement} node\n\t             * @param [optionalList]\n\t             * @return {int} the index of this node in context to it's siblings\n\t             */\n\n\t            value: function index(node, optionalList) {\n\t                var children = optionalList || (node.nodeType === Node.TEXT_NODE ? node.parentNode.childNodes : node.parentNode.children);\n\t                return Array.prototype.indexOf.call(children || [], node);\n\t            }\n\t        },\n\t        wrap: {\n\n\t            /**\n\t             * Wraps given `elms` in given `wrapper`\n\t             *\n\t             * @param {HTMLElement} wrapper\n\t             * @param {HTMLElement|Array.<HTMLElement>} elms\n\t             * @return {HTMLElement}\n\t             */\n\n\t            value: function wrap(elms, wrapper) {\n\t                // Convert `elms` to an array, if necessary.\n\t                if (!(elms instanceof NodeList || elms instanceof Array)) elms = [elms];\n\t                for (var i = elms.length - 1; i >= 0; i--) {\n\t                    var child = i > 0 ? wrapper.cloneNode(true) : wrapper;\n\t                    var el = elms[i];\n\t                    // Cache the current parent and sibling.\n\t                    var parent = el.parentNode,\n\t                        sibling = el.nextSibling;\n\n\t                    child.appendChild(el);\n\t                    if (sibling) {\n\t                        parent.insertBefore(child, sibling);\n\t                    } else {\n\t                        parent.appendChild(child);\n\t                    }\n\t                }\n\t                return wrapper;\n\t            }\n\t        },\n\t        calcIndex: {\n\n\t            /**\n\t             * Will calculate an index depending on an already modified dom by marklib\n\t             * @param {HTMLElement} node\n\t             * @returns {int|boolean}\n\t             */\n\n\t            value: function calcIndex(node) {\n\t                var calculatedIndex = 0;\n\t                var foundWrapper = false;\n\t                var nodes = node.childNodes,\n\t                    length = nodes.length;\n\t                for (var thisIndex = 0; thisIndex < length; thisIndex++) {\n\t                    var el = nodes[thisIndex];\n\t                    if (el === node) {\n\t                        return false;\n\t                    }\n\t                    var maybeIndexOfOriginal = el.getAttribute(ATTR_DATA_ORIGINAL_INDEX);\n\t                    var isOriginal = maybeIndexOfOriginal !== undefined;\n\t                    // Important: do not include pseudo elements\n\t                    if (el !== node && (el.nodeType !== Node.TEXT_NODE || isOriginal) && !el.hasAttribute(DATA_PSEUDO)) {\n\t                        if (isOriginal) {\n\t                            calculatedIndex = parseInt(maybeIndexOfOriginal);\n\t                            foundWrapper = true;\n\t                        } else {\n\t                            calculatedIndex++;\n\t                        }\n\t                    }\n\t                }\n\t                return foundWrapper ? calculatedIndex : Util.index(node);\n\t            }\n\t        },\n\t        parents: {\n\n\t            /**\n\t             * @param {HTMLElement} el\n\t             * @param {String} [optionalSelector] will test given element against a selector\n\t             *  if matches, returns this element immediately\n\t             * @return {Array.<HTMLElement>} an array of all found parents of given element (and optional selector)\n\t             */\n\n\t            value: function parents(el, optionalSelector) {\n\t                var element = el;\n\t                var foundElements = [];\n\t                while (element.parentNode !== null) {\n\t                    element = element.parentNode;\n\t                    if (optionalSelector && (element === optionalSelector || typeof optionalSelector === \"string\" && element.matches && element.matches(optionalSelector))) {\n\t                        foundElements.push(element);\n\t                    } else if (!optionalSelector) {\n\t                        foundElements.push(element);\n\t                    }\n\t                }\n\t                return foundElements;\n\t            }\n\t        },\n\t        parent: {\n\n\t            /**\n\t             * Finds a parent node (the closest) with a given selector\n\t             * @param {Node} el\n\t             * @param {String} selector\n\t             * @returns {*}\n\t             */\n\n\t            value: function parent(el, selector) {\n\t                var element = el;\n\t                while (element.parentNode !== null) {\n\t                    element = element.parentNode;\n\t                    if (element.matches && element.matches(selector)) {\n\t                        return element;\n\t                    }\n\t                }\n\t                return false;\n\t            }\n\t        },\n\t        closest: {\n\t            value: function closest(el, selector) {\n\t                var element = el;\n\t                while (element !== null) {\n\t                    if (element.matches && element.matches(selector)) {\n\t                        return element;\n\t                    }\n\t                    element = element.parentNode;\n\t                }\n\t                return false;\n\t            }\n\t        },\n\t        getPath: {\n\n\t            /**\n\t             * Determines the correct paths and excludes all `marklib` generated content\n\t             * TODO: To improve performance we could shorten the path if an ID is present in it.\n\t             * @param {HTMLElement} el\n\t             * @param {HTMLElement} [context] if given extraction path is relative to this element\n\t             * @returns {*}\n\t             */\n\n\t            value: function getPath(el, context) {\n\t                var path = null,\n\t                    node = el;\n\n\t                while (node) {\n\t                    var name = null;\n\t                    // If node is a text-node, save index\n\t                    if (Node.TEXT_NODE === node.nodeType) {\n\n\t                        /* Because nodes may wrapped inside a highlighting node, we need to find the original index that was\n\t                         * valid before the dom changes. We store the last known index position inside all wrapper elements\n\t                         * We select the outermost\n\t                         */\n\n\t                        // Extract original index of this node:\n\t                        // Outer most data-original-index is original index\n\t                        var outerMostElement = Util.parents(node, \"[\" + ATTR_DATA_ORIGINAL_INDEX + \"]\").reverse()[0];\n\t                        // if element is not yet wrapped in span, recalculate index based on parent container:\n\t                        // We have to do this because text node indexes != element indexes...\n\t                        var calculatedIndex = 0;\n\t                        if (!outerMostElement) {\n\t                            calculatedIndex = Util.calcIndex(node);\n\t                        }\n\t                        var index = outerMostElement ? parseInt(outerMostElement.getAttribute(ATTR_DATA_ORIGINAL_INDEX)) : calculatedIndex;\n\t                        name = SERIALIZE_SEPARATOR + index;\n\t                    } else {\n\t                        name = node.nodeName;\n\t                    }\n\n\t                    if (!name) break;\n\n\t                    name = name.toLowerCase();\n\n\t                    var parent = node.parentNode;\n\t                    if (node instanceof HTMLElement && node.hasAttribute(DATA_IS_SELECTION)) {\n\t                        node = parent;\n\t                        continue;\n\t                    }\n\t                    // Select only siblings that are not part of selection and are of the same type\n\t                    // (because we use nth-of-type selector later)\n\t                    var siblings = Util.nodeListFilter(parent.children, function (el) {\n\t                        return !el.hasAttribute(DATA_IS_SELECTION) && el.nodeName === node.nodeName;\n\t                    }),\n\t                        nodeIndex = Util.index(node, siblings);\n\n\t                    if (siblings.length > 1 && nodeIndex >= 0) {\n\t                        name += \":nth-of-type(\" + (nodeIndex + 1) + \")\";\n\t                    }\n\n\t                    path = name + (path ? \">\" + path : \"\");\n\n\t                    if (parent === context) {\n\t                        break;\n\t                    }\n\n\t                    node = parent;\n\t                }\n\n\t                return path.replace(\"#document>\", \"\").replace(\">;\", \";\");\n\t            }\n\t        }\n\t    });\n\n\t    return Util;\n\t})();\n\n\texports[\"default\"] = Util;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports[\"default\"] = function (obj) {\n\t  return obj && obj.__esModule ? obj[\"default\"] : obj;\n\t};\n\n\texports.__esModule = true;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports[\"default\"] = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n\texports.__esModule = true;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports[\"default\"] = (function () {\n\t  function defineProperties(target, props) {\n\t    for (var key in props) {\n\t      var prop = props[key];\n\t      prop.configurable = true;\n\t      if (prop.value) prop.writable = true;\n\t    }\n\n\t    Object.defineProperties(target, props);\n\t  }\n\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t})();\n\n\texports.__esModule = true;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** marklib.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 097d053c67111be39597\n **/","import Rendering from 'Rendering';\nimport Util from 'util/Util';\n\nexport default {\n    Rendering: Rendering,\n    Util:Util\n};\n\n\n/** WEBPACK FOOTER **\n ** ./~/jshint-loader!./src/export.js\n **/","/* global Node, Text, Rendering, Document */\nimport Util from 'util/Util';\n\nimport {ATTR_DATA_ORIGINAL_INDEX, DATA_IS_SELECTION} from 'util/Util';\n\n/**\n * @type {string}\n */\nconst TAG_NAME = 'x-marker';\n/**\n * @type {string}\n */\nconst ATTR_DATA_ORIGINAL_OFFSET_START = 'data-original-offset-start';\n/**\n * @type {string}\n */\nconst DATA_ORIGINAL_TEXT_NODE_INDEX = 'original-text-node-index';\n/**\n * @type {string}\n */\nconst ATTR_DATA_START_END = 'data-is-start-end';\n/**\n * @type {string}\n */\nconst ATTR_DATA_IS_HIGHLIGHT_NODE = 'data-is-highlight-node';\n/**\n * @type {string}\n */\nconst ATTR_DATA_ID = 'data-selection-id';\n\nexport default\nclass Rendering {\n\n    constructor(document, cssClass, context) {\n\n        if (!(document instanceof Document)) {\n            throw 'Marklib {0} is required to be a document instance';\n        }\n        /**\n         * @type {Document}\n         */\n        this.document = document;\n\n        /**\n         * ID of rendering, will be set on each element that is part of it\n         * @type {String}\n         */\n        this.id = Util.guid();\n\n        /**\n         * Class that is set on all highlight nodes\n         * @type {String}\n         */\n        this.cssClass = undefined === cssClass? 'marking' : cssClass;\n\n        /**\n         * StartContainer\n         * @type {Node}\n         */\n        this.startContainer = null;\n\n        /**\n         * EndContainer\n         * @type {Node}\n         */\n        this.endContainer = null;\n\n        /**\n         * Prefix before ID\n         * @type {string}\n         */\n        this.markerPrefix = 'marker-start-';\n\n        /**\n         * Suffix before ID\n         * @type {string}\n         */\n        this.markerSuffix = 'marker-end-';\n\n        /**\n         * @type {Node}\n         */\n        this.context = context || this.document;\n\n        /**\n         * @type {Function}\n         * @private\n         */\n        this._onWrappedNodeFunc = null;\n    }\n\n    /**\n     * @returns {string} id of this rendering\n     */\n    getId() {\n        return this.id;\n    }\n\n    /**\n     * @param {string} id\n     * @returns {Rendering}\n     */\n    setId(id) {\n        this.id = id;\n        return this;\n    }\n\n    /**\n     * Listener that is called when a node is wrapped on this instance\n     * @param {Function} f\n     * @returns {Rendering}\n     */\n    onWrappedNode(f) {\n        this._onWrappedNodeFunc = f;\n        return this;\n    }\n\n    /**\n     * @private\n     */\n    _callOnWrappedNode() {\n        if (\"function\" === typeof this._onWrappedNodeFunc) {\n            this._onWrappedNodeFunc.apply(this, arguments);\n        }\n    }\n\n\n    /**\n     * @param {Node} container\n     * @param {Number} thisIndex\n     * @returns {int} index of parent or original\n     * @private\n     */\n    static _getIndexParentIfHas(container, thisIndex) {\n        var p = container.parentNode;\n        var index = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_INDEX));\n        return index > thisIndex ? index : thisIndex;\n    }\n\n    /**\n     * @param container\n     * @returns {int} offset start of parent if has, else 0\n     */\n    static _getOffsetParentIfHas(container) {\n        var p = container.parentNode;\n        var offset = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START));\n        return offset > 0 ? offset : 0;\n    }\n\n    /**\n     * Creates a Template used as a wrapper\n     * @returns {Node}\n     * @private\n     */\n    _createWrapTemplate() {\n        var el = this.document.createElement(TAG_NAME), vTrue = \"true\";\n        el.className = this.cssClass;\n        el.setAttribute(DATA_IS_SELECTION, vTrue);\n        el.setAttribute(ATTR_DATA_ID, this.getId());\n        el.setAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE, vTrue);\n\n        return el;\n    }\n\n    /**\n     * Creates a Template to use as start and end marks\n     * @param {String} id\n     * @param {String} text\n     * @returns {Node}\n     * @private\n     */\n    _createStartEndWrapTemplate(id, text) {\n        var el = this._createWrapTemplate(), vTrue = \"true\";\n        el.setAttribute(ATTR_DATA_START_END, vTrue);\n        el.id = id;\n        el.textContent = text;\n        return el;\n    }\n\n\n    /**\n     * Creates Start or End Container Element\n     * @param initialNode\n     * @param prefix\n     * @param text\n     * @param offset\n     * @param index\n     * @returns {Node}\n     */\n    _createStartOrEndContainer(initialNode, prefix, text, offset, index) {\n        var wrapper = this._createStartEndWrapTemplate(prefix + this.getId(), text);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(initialNode, index));\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n        wrapper.marklibInstance = this;\n        return wrapper;\n    }\n\n    /**\n     * Wraps given element\n     * @param {Node} el\n     * @param [optionalLength]\n     * @param [optionalIndex]\n     * @param [optionalIsSameNode]\n     * @returns {Node}\n     * @private\n     */\n    _createWrap(el, optionalLength, optionalIndex, optionalIsSameNode) {\n        var originalIndex = optionalIndex >= 0 ? optionalIndex : Util.calcIndex(el);\n        var wrapper = this._createWrapTemplate();\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(el, originalIndex));\n        var offsetLength = optionalLength >= 0 ? optionalLength : Rendering._getOffsetParentIfHas(el);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offsetLength);\n\n        // Save a reference to original text node in wrapper\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, originalIndex);\n\n        // save this marker instance to given node\n        wrapper.marklibInstance = this;\n\n        if (optionalIsSameNode) {\n            wrapper.setAttribute(ATTR_DATA_START_END, ATTR_DATA_START_END);\n        }\n        var wrap = Util.wrap(el, wrapper);\n        this._callOnWrappedNode(el, wrap);\n        return wrap;\n    }\n\n    /**\n     * Create split container element\n     * @param originalElement {Node} original text node element that is created a wrapper for\n     * @param index\n     * @param offset\n     * @returns {*|jQuery|Node}\n     */\n    _createSplitContainer(originalElement, index, offset) {\n        var wrapper = this.document.createElement(TAG_NAME), vTrue = \"true\";\n        wrapper.setAttribute(DATA_IS_SELECTION, vTrue);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(originalElement, index));\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n        return wrapper;\n    }\n\n    /**\n     * Extracts all TextNodes inside a container\n     * @param {Node} el\n     * @returns {Array.<Text>}\n     */\n    _walkTextNodes(el, func) {\n        this.walkDom(el, function (node) {\n            if (Node.TEXT_NODE === node.nodeType && !Util.nodeIsEmpty(node)) {\n                func(node);\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Walks the tree\n     * @param start\n     * @param endContainer\n     * @param nextParent\n     */\n    walk(start, endContainer, nextParent) {\n        var nextParentNode = start;\n        while (nextParentNode && nextParentNode !== nextParent.parentNode) {\n            var currentParentNode = nextParentNode;\n            nextParentNode = nextParentNode.parentNode;\n            if (this.wrapSiblings(currentParentNode.nextSibling, endContainer)) {\n                break;\n            }\n        }\n    }\n\n\n    /**\n     * Will Wrap all textNode siblings of a container (start) inside a defined Element (like a span)\n     * If an Element node is found, it will wrap all children of this node inside a element as well.\n     * It will stop if endContainer is found as a node\n     *\n     * @param {Node} start\n     * @param {Node} endContainer\n     * @returns {boolean} (true if endContainer was found)\n     */\n    wrapSiblings(start, endContainer) {\n        var next = start;\n        var found = false;\n\n        // Capsule some logic\n        var wrap = ((n) => {\n            if (n.parentNode.hasAttribute(ATTR_DATA_START_END) &&\n                n.parentNode.hasAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE) &&\n                n.parentNode.getAttribute(ATTR_DATA_ID) == this.getId()) {\n                var thisNode = this._createWrap(n).parentNode;\n                thisNode.classList.remove(this.cssClass);\n                thisNode.removeAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE);\n            } else {\n                this._createWrap(n);\n            }\n        }).bind(this);\n\n        var wrapIf = (n) => {\n            if (!Util.nodeIsEmpty(n)) {\n                wrap(n);\n            }\n        };\n        while (null !== next && next !== endContainer) {\n            var currentNext = next;\n            next = next.nextSibling;\n            // Found a text node, directly wrap inside a span\n            if (Node.TEXT_NODE === currentNext.nodeType) {\n                wrapIf(currentNext);\n            } else {\n                if (currentNext.contains(endContainer)) {\n                    this.walkDom(currentNext, (e) => {\n                        if (e === endContainer) {\n                            return false;\n                        }\n                        if (Node.TEXT_NODE === e.nodeType) {\n                            wrapIf(e);\n                        }\n                        return true;\n                    });\n                    found = true;\n                } else {\n                    this._walkTextNodes(currentNext, (el) => {\n                        wrapIf(el);\n                    });\n                }\n                if (found) {\n                    return true;\n                }\n            }\n        }\n        return found;\n    }\n\n    /**\n     * Recursively walks the dom tree unless func returns false\n     * This is a lot more efficient then using any jQuery operations\n     *\n     * Applies node to function\n     * @param node\n     * @param func\n     * @returns {*}\n     */\n    walkDom(node, func) {\n        if (!node) {\n            return false;\n        }\n        var children = node.childNodes;\n        if (!children) {\n            return false;\n        }\n        for (var i = 0; i < children.length; i++) {\n            if (!this.walkDom(children[i], func)) {\n                return false;\n            }\n        }\n        return func(node);\n    }\n\n    /**\n     * Marks text of the same node\n     * @param {Node} textNode\n     * @param {int} startIndex\n     * @param {int} endIndex\n     * @private\n     */\n    _markTextSameNode(textNode, startIndex, endIndex) {\n        var initialText = textNode.nodeValue;\n        var initialIndex = Util.calcIndex(textNode);\n        if (!initialText) {\n            return false;\n        }\n        //If there is an unmarked part in the beginning of the text node,\n        //cut off that part and put it into it's own textnode.\n        if (startIndex > 0) {\n            var textBefore = initialText.slice(0, startIndex);\n            textNode.parentNode.insertBefore(new Text(textBefore), textNode);\n            // wrap cutted text node:\n            Util.wrap(textNode.previousSibling, this._createSplitContainer(textNode,\n                initialIndex, Rendering._getOffsetParentIfHas(textNode)));\n        }\n        //If there is an unmarked part at the end of the text node,\n        //cut off that part and put it into it's own textnode.\n        if (endIndex < initialText.length) {\n            var textAfter = initialText.slice(endIndex, initialText.length);\n            textNode.parentNode.insertBefore(new Text(textAfter), textNode.nextSibling);\n\n            Util.wrap(textNode.nextSibling, this._createSplitContainer(textNode,\n                initialIndex, Rendering._getOffsetParentIfHas(textNode) + endIndex));\n        }\n\n        //Cutoff the unmarked parts and wrap the textnode into a span.\n        textNode.nodeValue = initialText.slice(startIndex, endIndex);\n        this.startContainer = this._createWrap(textNode,\n            Rendering._getOffsetParentIfHas(textNode) + startIndex, initialIndex, true).parentNode;\n        this.endContainer = this.startContainer;\n        return this.startContainer;\n    }\n\n\n    /**\n     * Marks text of end and start containers if start and end nodes are different\n     * Important: There might be no end container!\n     *\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @returns {{startT: (Node), endT: (Node)}}\n     * @private\n     */\n    _markTextDifferentNode(startContainer, endContainer, startOffset, endOffset) {\n        // Get current for both start and end:\n        var startContainerIndex = Util.calcIndex(startContainer);\n        var endContainerIndex = Util.calcIndex(endContainer);\n\n        // Split text\n        var fullTextStartValue = startContainer.nodeValue;\n        // init with startContainer because we may have not a text node here\n        var startT = startContainer;\n\n        if (undefined !== fullTextStartValue) {\n            var partTextStartValue = fullTextStartValue.slice(startOffset, fullTextStartValue.length);\n            // Set new text to start node\n            startContainer.nodeValue = fullTextStartValue.slice(0, startOffset);\n\n            var offsetStart = Rendering._getOffsetParentIfHas(startContainer);\n            // Create a new node for splitted text, offset is the length of new startContainer.nodeValue:\n            startT = this._createStartOrEndContainer(startContainer, this.markerPrefix, partTextStartValue,\n                offsetStart === startOffset ? offsetStart : offsetStart + startOffset, startContainerIndex);\n            // Append this node after startContainer\n            startContainer.parentNode.insertBefore(startT, startContainer.nextSibling);\n            this.startContainer = startT;\n\n            if (startContainer.nodeValue) {\n                // Wrap start container in detection node, offset is always 0 or parent offset.\n                Util.wrap(startContainer, this._createSplitContainer(startContainer, startContainerIndex,\n                    Rendering._getOffsetParentIfHas(startContainer)));\n            }\n        }\n\n        // init with endContainer because we may have not a text node here\n        var endT = endContainer;\n\n        // 2. Extract end Text node,\n        var fullTextEndValue = endContainer.nodeValue;\n        // It's possible that end container value is null (if a whole paragraph is marked)\n        if (undefined !== fullTextEndValue) {\n            // Split text\n            var partTextEndValue = fullTextEndValue.slice(0, endOffset);\n            endContainer.nodeValue = fullTextEndValue.slice(endOffset, fullTextEndValue.length);\n            // End Container start offset is always 0 or parent offset.\n            endT = this._createStartOrEndContainer(endContainer, this.markerSuffix, partTextEndValue,\n                Rendering._getOffsetParentIfHas(endContainer), endContainerIndex);\n\n            endContainer.parentNode.insertBefore(endT, endContainer);\n            this.endContainer = endT;\n            var offsetParent = Rendering._getOffsetParentIfHas(endContainer);\n            Util.wrap(endContainer, this._createSplitContainer(endContainer, endContainerIndex,\n                offsetParent === endOffset ? offsetParent : offsetParent + endOffset));\n        }\n\n        return {startT: startT, endT: endT};\n    }\n\n    /**\n     * Will return the original first offset\n     * @param element\n     * @returns {int}\n     * @private\n     */\n    _findOriginalOffset(element) {\n        if (!element.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n            return 0;\n        }\n        var lengthElement = Util.parent(element, '[' + ATTR_DATA_ORIGINAL_OFFSET_START + ']');\n        return lengthElement ? parseInt(lengthElement.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : 0;\n    }\n\n    /**\n     * Renders a selection\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {Node} commonAncestor\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @returns {{startOffset: (int), endOffset: (int)}} the original offsets found\n     * @private\n     */\n    _renderWithElements(startContainer, endContainer, commonAncestor, startOffset, endOffset) {\n        var outer = Util.parents(startContainer, commonAncestor);\n        outer = outer[outer.length - 1];\n        var contextContainer = outer ? outer : commonAncestor;\n\n        // Same Element, means the selection is fully contained in a discrete area, start and endpoint have the same parent\n        // but are different nodes:\n\n        // Start and End offset have to be recalculated because dom might be already changed by highlighting in given node\n        // 1: First detect real start offset in startContainer:\n\n        // That works by selecting the highest wrapper and get original-offset-start data element, see \"findOriginalOffset\"\n        // So first select that container:\n        var originalStartOffset = this._findOriginalOffset(startContainer);\n        var originalEndOffset = this._findOriginalOffset(endContainer);\n\n        // We may run into Browser Bugs:\n\n        // If both are not text nodes, use next sibling as endContainer\n        if (startContainer.nodeType !== Node.TEXT_NODE && endContainer.nodeType !== Node.TEXT_NODE) {\n            if (startContainer === endContainer) {\n                endContainer = endContainer.nextElementSibling || endContainer;\n            }\n        }\n        // IF start/end container is not type of text, select first child text node:\n        // We run in some bugs with firefox here that selects no text-nodes sometimes, trying to fix this here\n        // Sometimes does not work correctly... (specially when DOM was modified)\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            this.walkDom(startContainer, function (el) {\n                if (el.nodeType === Node.TEXT_NODE) {\n                    startContainer = el;\n                    return false;\n                }\n                return true;\n            });\n        }\n\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            // Get the last text node:\n            var endContainerContents = Util.closest(startContainer, ':not([' + DATA_IS_SELECTION + '])').childNodes;\n            if (endContainerContents.length) {\n                var r = endContainerContents[endContainerContents.length - 1];\n                if (r.nodeType === Node.TEXT_NODE) {\n                    endContainer = r;\n                    endOffset = r.length;\n                } else {\n                    var f = r.lastChild;\n                    while (f !== null) {\n                        if (f && f.nodeType === Node.TEXT_NODE) {\n                            endContainer = f;\n                            endOffset = f.length;\n                            if (f.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n                                endOffset = parseInt(f.parentNode\n                                    .getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) + endOffset;\n                            }\n                        }\n                        f = f.lastChild;\n                    }\n                }\n            }\n            // still no textNode?\n            if (endContainer.nodeType !== Node.TEXT_NODE) {\n                throw 'Could not found endContainer, highlighting would be unstable';\n            }\n        }\n\n        var result = {\n            // Real offset is calculated by relative length and absolute length\n            startOffset: originalStartOffset + startOffset,\n            endOffset: originalEndOffset + endOffset,\n            // get the path for this selection\n            startContainerPath: Util.getPath(startContainer, this.context),\n            endContainerPath: Util.getPath(endContainer, this.context)\n        };\n\n        this._renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer);\n\n        return result;\n    }\n\n    /**\n     * Renders a given selection\n     *\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @param {Node} contextContainer\n     * @param {Node} outer\n     * @private\n     */\n    _renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer) {\n\n        // if start and end-container are the same, mark text on the same node\n        if (startContainer === endContainer) {\n            this._markTextSameNode(startContainer, startOffset, endOffset);\n        } else {\n            var result = this._markTextDifferentNode(startContainer, endContainer, startOffset, endOffset);\n            if (!outer) {\n                this.wrapSiblings(result.startT.nextSibling, endContainer);\n            } else {\n                this.walk(result.startT, endContainer, contextContainer);\n            }\n        }\n    }\n\n\n    /**\n     * Deserializes a specific path and finds the right textnodes\n     * This even works when DOM has been manipulated before by `marklib`\n     * @param {string} path the serialized path (including offsets)\n     * @return {Node}\n     * @private\n     */\n    _deserializePath(path) {\n        var pSplit = path.split(';'), p = pSplit[0],\n            objectIndex = parseInt(pSplit[1]),\n            charOffset = parseInt(pSplit[2]),\n            container = this.context.querySelector(p), maybeFoundNode = null;\n        this.walkDom(container, function (n) {\n            if (n.nodeType === Node.TEXT_NODE) {\n                var atrOffsetStart = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START);\n                atrOffsetStart = null === atrOffsetStart ? 0 : atrOffsetStart;\n                var atrIndex = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_INDEX);\n                atrIndex = null === atrIndex ? Util.calcIndex(n) : atrIndex;\n                if (atrIndex == objectIndex && charOffset >= atrOffsetStart &&\n                    ((parseInt(atrOffsetStart) + n.length) >= charOffset)) {\n                    var thisOffset = n.parentNode\n                        .hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START) ? charOffset -\n                    parseInt(n.parentNode\n                        .getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : charOffset;\n                    maybeFoundNode = {node: n, offset: thisOffset};\n                    return false;\n                }\n            } else {\n                return true;\n            }\n            return true;\n        });\n\n        return maybeFoundNode;\n    }\n\n    /**\n     * Prepares to render a Selection with path selectors\n     * ```\n     * A Path looks like this:\n     *\n     * #selector;#textnode;#offset\n     * ``\n     * @param {string} startPath\n     * @param {string} endPath\n     * @returns {*}\n     */\n    renderWithPath(startPath, endPath) {\n        var startContainer = this._deserializePath(startPath);\n        var endContainer = this._deserializePath(endPath);\n        if (startContainer && endContainer && startContainer.node && endContainer.node) {\n            var range = document.createRange();\n            range.setStart(startContainer.node, startContainer.offset);\n            range.setEnd(endContainer.node, endContainer.offset);\n            this.renderWithRange(range);\n            return range;\n        }\n        throw 'Could not find start- and/or end-container in document';\n    }\n\n\n    /**\n     * Prepares a selection with a range object\n     * @param {Range} range\n     * @returns {*}\n     */\n    renderWithRange(range) {\n        return this._renderWithElements(range.startContainer, range.endContainer,\n            range.commonAncestorContainer, range.startOffset, range.endOffset);\n    }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/jshint-loader!./src/main/Rendering.js\n **/","/* global Node, NodeList */\n\n/**\n * @type {string}\n */\nexport const ATTR_DATA_ORIGINAL_INDEX = 'data-original-index';\n/**\n * @type {string}\n */\nexport const DATA_PSEUDO = 'data-is-pseudo';\n/**\n * @type {string}\n */\nexport const DATA_IS_SELECTION = 'data-is-selection';\n/**\n * @type {string}\n */\nconst SERIALIZE_SEPARATOR = \";\";\n\n/**\n * Utility class\n * Contains DOM/Node manipulation helpers\n */\nexport default\nclass Util {\n    /**\n     * Filter for a NodeList\n     * @param {NodeList} nodes\n     * @param {Function} func\n     * @returns {Array.<HTMLElement>}\n     */\n    static nodeListFilter(nodes, func) {\n        return Array.prototype.filter.call(nodes || [], func);\n    }\n\n\n    /**\n     * Generates a unique id\n     * @return {String}\n     */\n    static guid() {\n        function s4() {\n            return Math.floor((1 + Math.random()) * 0x10000)\n                .toString(16)\n                .substring(1);\n        }\n\n        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n            s4() + '-' + s4() + s4() + s4();\n    }\n\n    /**\n     * Checks if a given node is empty\n     * @param {HTMLElement} node\n     * @returns {*}\n     */\n    static nodeIsEmpty(node) {\n        return node.nodeValue.match(/^[\\s]*$/g);\n    }\n\n\n    /**\n     * @param {HTMLElement} node\n     * @param [optionalList]\n     * @return {int} the index of this node in context to it's siblings\n     */\n    static index(node, optionalList) {\n        var children = optionalList || (node.nodeType === Node.TEXT_NODE ? node.parentNode.childNodes : node.parentNode.children);\n        return Array.prototype.indexOf.call(children || [], node);\n    }\n\n    /**\n     * Wraps given `elms` in given `wrapper`\n     *\n     * @param {HTMLElement} wrapper\n     * @param {HTMLElement|Array.<HTMLElement>} elms\n     * @return {HTMLElement}\n     */\n    static wrap(elms, wrapper) {\n        // Convert `elms` to an array, if necessary.\n        if (!(elms instanceof NodeList || elms instanceof Array)) elms = [elms];\n        for (var i = elms.length - 1; i >= 0; i--) {\n            var child = (i > 0) ? wrapper.cloneNode(true) : wrapper;\n            var el = elms[i];\n            // Cache the current parent and sibling.\n            var parent = el.parentNode, sibling = el.nextSibling;\n\n            child.appendChild(el);\n            if (sibling) {\n                parent.insertBefore(child, sibling);\n            } else {\n                parent.appendChild(child);\n            }\n        }\n        return wrapper;\n    }\n\n    /**\n     * Will calculate an index depending on an already modified dom by marklib\n     * @param {HTMLElement} node\n     * @returns {int|boolean}\n     */\n    static calcIndex(node) {\n        var calculatedIndex = 0;\n        var foundWrapper = false;\n        var nodes = node.childNodes, length = nodes.length;\n        for (let thisIndex = 0; thisIndex < length; thisIndex++) {\n            var el = nodes[thisIndex];\n            if (el === node) {\n                return false;\n            }\n            var maybeIndexOfOriginal = el.getAttribute(ATTR_DATA_ORIGINAL_INDEX);\n            var isOriginal = maybeIndexOfOriginal !== undefined;\n            // Important: do not include pseudo elements\n            if (el !== node && (el.nodeType !== Node.TEXT_NODE || isOriginal) && !el.hasAttribute(DATA_PSEUDO)) {\n                if (isOriginal) {\n                    calculatedIndex = parseInt(maybeIndexOfOriginal);\n                    foundWrapper = true;\n                } else {\n                    calculatedIndex++;\n                }\n            }\n        }\n        return foundWrapper ? calculatedIndex : Util.index(node);\n    }\n\n    /**\n     * @param {HTMLElement} el\n     * @param {String} [optionalSelector] will test given element against a selector\n     *  if matches, returns this element immediately\n     * @return {Array.<HTMLElement>} an array of all found parents of given element (and optional selector)\n     */\n    static parents(el, optionalSelector) {\n        var element = el;\n        var foundElements = [];\n        while (element.parentNode !== null) {\n            element = element.parentNode;\n            if (optionalSelector && ((element === optionalSelector) ||\n                ( (typeof optionalSelector === 'string') && element.matches && element.matches(optionalSelector)))) {\n                foundElements.push(element);\n            } else if (!optionalSelector) {\n                foundElements.push(element);\n            }\n        }\n        return foundElements;\n    }\n\n    /**\n     * Finds a parent node (the closest) with a given selector\n     * @param {Node} el\n     * @param {String} selector\n     * @returns {*}\n     */\n    static parent(el, selector) {\n        var element = el;\n        while (element.parentNode !== null) {\n            element = element.parentNode;\n            if (element.matches && element.matches(selector)) {\n                return element;\n            }\n        }\n        return false;\n    }\n\n    static closest(el, selector) {\n        var element = el;\n        while (element !== null) {\n            if (element.matches && element.matches(selector)) {\n                return element;\n            }\n            element = element.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * Determines the correct paths and excludes all `marklib` generated content\n     * TODO: To improve performance we could shorten the path if an ID is present in it.\n     * @param {HTMLElement} el\n     * @param {HTMLElement} [context] if given extraction path is relative to this element\n     * @returns {*}\n     */\n    static getPath(el, context) {\n        var path = null, node = el;\n\n        while (node) {\n            var name = null;\n            // If node is a text-node, save index\n            if (Node.TEXT_NODE === node.nodeType) {\n\n                /* Because nodes may wrapped inside a highlighting node, we need to find the original index that was\n                 * valid before the dom changes. We store the last known index position inside all wrapper elements\n                 * We select the outermost\n                 */\n\n                // Extract original index of this node:\n                // Outer most data-original-index is original index\n                var outerMostElement = Util.parents(node, '[' + ATTR_DATA_ORIGINAL_INDEX + ']').reverse()[0];\n                // if element is not yet wrapped in span, recalculate index based on parent container:\n                // We have to do this because text node indexes != element indexes...\n                var calculatedIndex = 0;\n                if (!outerMostElement) {\n                    calculatedIndex = Util.calcIndex(node);\n                }\n                var index = outerMostElement ? parseInt(\n                    outerMostElement.getAttribute(ATTR_DATA_ORIGINAL_INDEX)) : calculatedIndex;\n                name = SERIALIZE_SEPARATOR + index;\n            } else {\n                name = node.nodeName;\n            }\n\n            if (!name) break;\n\n            name = name.toLowerCase();\n\n            var parent = node.parentNode;\n            if (node instanceof HTMLElement && node.hasAttribute(DATA_IS_SELECTION)) {\n                node = parent;\n                continue;\n            }\n            // Select only siblings that are not part of selection and are of the same type\n            // (because we use nth-of-type selector later)\n            var siblings = Util.nodeListFilter(parent.children, (el) => {\n                return !el.hasAttribute(DATA_IS_SELECTION) && el.nodeName === node.nodeName;\n            }), nodeIndex = Util.index(node, siblings);\n\n            if (siblings.length > 1 && nodeIndex >= 0) {\n                name += ':nth-of-type(' + (nodeIndex + 1) + ')';\n            }\n\n            path = name + (path ? '>' + path : '');\n\n            if (parent === context) {\n                break;\n            }\n\n            node = parent;\n        }\n\n        return path.replace(\"#document>\", \"\").replace('>;', ';');\n    }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/jshint-loader!./src/main/util/Util.js\n **/","\"use strict\";\n\nexports[\"default\"] = function (obj) {\n  return obj && obj.__esModule ? obj[\"default\"] : obj;\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/interop-require.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\n\nexports[\"default\"] = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/class-call-check.js\n ** module id = 4\n ** module chunks = 0\n **/","\"use strict\";\n\nexports[\"default\"] = (function () {\n  function defineProperties(target, props) {\n    for (var key in props) {\n      var prop = props[key];\n      prop.configurable = true;\n      if (prop.value) prop.writable = true;\n    }\n\n    Object.defineProperties(target, props);\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n})();\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/create-class.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}