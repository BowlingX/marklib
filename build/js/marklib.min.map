{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///marklib.min.js","webpack:///webpack/bootstrap 9a09ec5721cb60586071","webpack:///./src/main/modules/Marklib.js","webpack:///./~/babel-runtime/helpers/interop-require-default.js","webpack:///./src/main/Rendering.js","webpack:///./~/babel-runtime/helpers/create-class.js","webpack:///./~/babel-runtime/core-js/object/define-property.js","webpack:///./~/babel-runtime/~/core-js/library/fn/object/define-property.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.fw.js","webpack:///./~/babel-runtime/helpers/class-call-check.js","webpack:///./src/main/util/Util.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","Object","defineProperty","value","_Rendering","_Rendering2","_utilUtil","_utilUtil2","Rendering","Util","obj","__esModule","default","_createClass","_classCallCheck","TAG_NAME","ATTR_DATA_ORIGINAL_OFFSET_START","DATA_ORIGINAL_TEXT_NODE_INDEX","ATTR_DATA_START_END","ATTR_DATA_IS_HIGHLIGHT_NODE","ATTR_DATA_ID","DOCUMENT_POSITION_CONTAINED_BY","document","cssClass","context","Document","guid","undefined","startContainer","endContainer","markerPrefix","markerSuffix","_onWrappedNodeFunc","key","f","apply","arguments","el","createElement","vTrue","className","setAttribute","DATA_IS_SELECTION","getId","text","_createWrapTemplate","textContent","initialNode","prefix","offset","index","wrapper","_createStartEndWrapTemplate","ATTR_DATA_ORIGINAL_INDEX","_getIndexParentIfHas","marklibInstance","optionalLength","optionalIndex","optionalIsSameNode","originalIndex","calcIndex","offsetLength","_getOffsetParentIfHas","wrap","_callOnWrappedNode","originalElement","func","walkDom","node","Node","TEXT_NODE","nodeType","nodeIsEmpty","start","nextParent","nextParentNode","parentNode","currentParentNode","wrapSiblings","nextSibling","_this","next","found","n","hasAttribute","getAttribute","thisNode","_createWrap","classList","remove","removeAttribute","bind","wrapIf","walkIfContained","e","walkIfNotContained","currentNext","compareDocumentPosition","_walkTextNodes","children","childNodes","i","length","textNode","startIndex","endIndex","initialText","nodeValue","initialIndex","textBefore","slice","insertBefore","createTextNode","previousSibling","_createSplitContainer","textAfter","startOffset","endOffset","startContainerIndex","endContainerIndex","fullTextStartValue","startT","partTextStartValue","offsetStart","_createStartOrEndContainer","endT","fullTextEndValue","partTextEndValue","offsetParent","element","lengthElement","parent","parseInt","commonAncestor","withoutResult","outer","parents","contextContainer","originalStartOffset","_findOriginalOffset","originalEndOffset","nextElementSibling","endContainerContents","closest","r","lastChild","result","startContainerPath","getPath","endContainerPath","_renderSelection","_markTextSameNode","_markTextDifferentNode","walk","path","pSplit","split","objectIndex","charOffset","container","trim","querySelector","maybeFoundNode","atrOffsetStart","atrIndex","thisOffset","startPath","endPath","_deserializePath","range","createRange","setStart","setEnd","toString","renderWithRange","renderWithPath","_renderWithElements","commonAncestorContainer","thisIndex","_Object$defineProperty","defineProperties","target","props","descriptor","enumerable","configurable","writable","Constructor","protoProps","staticProps","prototype","$","it","desc","setDesc","toInteger","isNaN","floor","ceil","bitmap","simpleSet","object","createDefiner","DESC","isObject","isFunction","assertDefined","TypeError","global","self","Function","core","hasOwnProperty","Math","max","min","get","a","hide","g","html","documentElement","that","toLength","toIndex","has","create","getProto","getPrototypeOf","getDesc","getOwnPropertyDescriptor","setDescs","getKeys","keys","getNames","getOwnPropertyNames","getSymbols","getOwnPropertySymbols","ES5Object","toObject","def","set","Symbol","each","forEach","__e","__g","FW","instance","DATA_PSEUDO","SERIALIZE_SEPARATOR","Element","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","nodes","Array","filter","s4","random","substring","match","optionalList","indexOf","elms","NodeList","child","cloneNode","_parent","sibling","appendChild","calculatedIndex","foundWrapper","maybeIndexOfOriginal","optionalSelector","foundElements","push","selector","HTMLElement","filterSiblings","thisEl","isMarkNode","nodeName","name","outerMostElement","reverse","toLowerCase","siblings","nodeListFilter","nodeIndex","replace"],"mappings":"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","file":"marklib.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Marklib\"] = factory();\n\telse\n\t\troot[\"Marklib\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Marklib\"] = factory();\n\telse\n\t\troot[\"Marklib\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\tvar _Rendering = __webpack_require__(3);\n\t\n\tvar _Rendering2 = _interopRequireDefault(_Rendering);\n\t\n\tvar _utilUtil = __webpack_require__(10);\n\t\n\tvar _utilUtil2 = _interopRequireDefault(_utilUtil);\n\t\n\texports['default'] = {\n\t    Rendering: _Rendering2['default'],\n\t    Util: _utilUtil2['default']\n\t};\n\tmodule.exports = exports['default'];\n\t//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL3NyYy9tYWluL21vZHVsZXMvTWFya2xpYi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLENBQUM7Ozs7Ozs7O3lCQUVTLFdBQVc7Ozs7d0JBQ2hCLFdBQVc7Ozs7cUJBRWI7QUFDWCxhQUFTLHdCQUFXO0FBQ3BCLFFBQUksdUJBQU07Q0FDYiIsImZpbGUiOiIvVXNlcnMvYm93bGluZ3gvUHJvamVrdGUvbWFya2xpYi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvYm93bGluZ3gvUHJvamVrdGUvbWFya2xpYi9zcmMvbWFpbi9tb2R1bGVzL01hcmtsaWIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBSZW5kZXJpbmcgZnJvbSAnUmVuZGVyaW5nJztcbmltcG9ydCBVdGlsIGZyb20gJ3V0aWwvVXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBSZW5kZXJpbmc6IFJlbmRlcmluZyxcbiAgICBVdGlsOiBVdGlsXG59O1xuIl19\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports[\"default\"] = function (obj) {\n\t  return obj && obj.__esModule ? obj : {\n\t    \"default\": obj\n\t  };\n\t};\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global Node, Document */\n\t\n\t'use strict';\n\t\n\tvar _createClass = __webpack_require__(4)['default'];\n\t\n\tvar _classCallCheck = __webpack_require__(9)['default'];\n\t\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\tvar _utilUtil = __webpack_require__(10);\n\t\n\tvar _utilUtil2 = _interopRequireDefault(_utilUtil);\n\t\n\t/**\n\t * @type {string}\n\t */\n\tvar TAG_NAME = 'x-marker';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ORIGINAL_OFFSET_START = 'data-original-offset-start';\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_ORIGINAL_TEXT_NODE_INDEX = 'original-text-node-index';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_START_END = 'data-is-start-end';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_IS_HIGHLIGHT_NODE = 'data-is-highlight-node';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ID = 'data-selection-id';\n\t\n\t/**\n\t * @see https://developer.mozilla.org/de/docs/Web/API/Node/compareDocumentPosition\n\t * @type {number}\n\t */\n\tvar DOCUMENT_POSITION_CONTAINED_BY = 16;\n\t\n\tvar Rendering = (function () {\n\t    function Rendering(document, cssClass, context) {\n\t        _classCallCheck(this, Rendering);\n\t\n\t        if (!(document instanceof Document)) {\n\t            throw 'Marklib {0} is required to be a document instance';\n\t        }\n\t        /**\n\t         * @type {Document}\n\t         */\n\t        this.document = document;\n\t\n\t        /**\n\t         * ID of rendering, will be set on each element that is part of it\n\t         * @type {String}\n\t         */\n\t        this.id = _utilUtil2['default'].guid();\n\t\n\t        /**\n\t         * Class that is set on all highlight nodes\n\t         * @type {String}\n\t         */\n\t        this.cssClass = undefined === cssClass ? 'marking' : cssClass;\n\t\n\t        /**\n\t         * StartContainer\n\t         * @type {Node}\n\t         */\n\t        this.startContainer = null;\n\t\n\t        /**\n\t         * EndContainer\n\t         * @type {Node}\n\t         */\n\t        this.endContainer = null;\n\t\n\t        /**\n\t         * Prefix before ID\n\t         * @type {string}\n\t         */\n\t        this.markerPrefix = 'marker-start-';\n\t\n\t        /**\n\t         * Suffix before ID\n\t         * @type {string}\n\t         */\n\t        this.markerSuffix = 'marker-end-';\n\t\n\t        /**\n\t         * @type {Node}\n\t         */\n\t        this.context = context || this.document;\n\t\n\t        /**\n\t         * @type {Function}\n\t         * @private\n\t         */\n\t        this._onWrappedNodeFunc = null;\n\t    }\n\t\n\t    _createClass(Rendering, [{\n\t        key: 'getId',\n\t\n\t        /**\n\t         * @returns {string} id of this rendering\n\t         */\n\t        value: function getId() {\n\t            return this.id;\n\t        }\n\t    }, {\n\t        key: 'setId',\n\t\n\t        /**\n\t         * @param {string} id\n\t         * @returns {Rendering}\n\t         */\n\t        value: function setId(id) {\n\t            this.id = id;\n\t            return this;\n\t        }\n\t    }, {\n\t        key: 'onWrappedNode',\n\t\n\t        /**\n\t         * Listener that is called when a node is wrapped on this instance\n\t         * @param {Function} f\n\t         * @returns {Rendering}\n\t         */\n\t        value: function onWrappedNode(f) {\n\t            this._onWrappedNodeFunc = f;\n\t            return this;\n\t        }\n\t    }, {\n\t        key: '_callOnWrappedNode',\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        value: function _callOnWrappedNode() {\n\t            if (typeof this._onWrappedNodeFunc === 'function') {\n\t                this._onWrappedNodeFunc.apply(this, arguments);\n\t            }\n\t        }\n\t    }, {\n\t        key: '_createWrapTemplate',\n\t\n\t        /**\n\t         * Creates a Template used as a wrapper\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t        value: function _createWrapTemplate() {\n\t            var el = this.document.createElement(TAG_NAME),\n\t                vTrue = 'true';\n\t            el.className = this.cssClass;\n\t            el.setAttribute(_utilUtil.DATA_IS_SELECTION, vTrue);\n\t            el.setAttribute(ATTR_DATA_ID, this.getId());\n\t            el.setAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE, vTrue);\n\t\n\t            return el;\n\t        }\n\t    }, {\n\t        key: '_createStartEndWrapTemplate',\n\t\n\t        /**\n\t         * Creates a Template to use as start and end marks\n\t         * @param {String} text\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t        value: function _createStartEndWrapTemplate(text) {\n\t            var el = this._createWrapTemplate(),\n\t                vTrue = 'true';\n\t            el.setAttribute(ATTR_DATA_START_END, vTrue);\n\t            el.textContent = text;\n\t            return el;\n\t        }\n\t    }, {\n\t        key: '_createStartOrEndContainer',\n\t\n\t        /**\n\t         * Creates Start or End Container Element\n\t         * @param initialNode\n\t         * @param prefix\n\t         * @param text\n\t         * @param offset\n\t         * @param index\n\t         * @returns {Node}\n\t         */\n\t        value: function _createStartOrEndContainer(initialNode, prefix, text, offset, index) {\n\t            var wrapper = this._createStartEndWrapTemplate(text);\n\t            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(initialNode, index));\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n\t            wrapper.marklibInstance = this;\n\t            return wrapper;\n\t        }\n\t    }, {\n\t        key: '_createWrap',\n\t\n\t        /**\n\t         * Wraps given element\n\t         * @param {Node} el\n\t         * @param [optionalLength]\n\t         * @param [optionalIndex]\n\t         * @param [optionalIsSameNode]\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t        value: function _createWrap(el, optionalLength, optionalIndex, optionalIsSameNode) {\n\t            var originalIndex = optionalIndex >= 0 ? optionalIndex : _utilUtil2['default'].calcIndex(el);\n\t            var wrapper = this._createWrapTemplate();\n\t            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(el, originalIndex));\n\t            var offsetLength = optionalLength >= 0 ? optionalLength : Rendering._getOffsetParentIfHas(el);\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offsetLength);\n\t\n\t            // Save a reference to original text node in wrapper\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, originalIndex);\n\t\n\t            // save this marker instance to given node\n\t            wrapper.marklibInstance = this;\n\t\n\t            if (optionalIsSameNode) {\n\t                wrapper.setAttribute(ATTR_DATA_START_END, ATTR_DATA_START_END);\n\t            }\n\t            var wrap = _utilUtil2['default'].wrap(el, wrapper);\n\t            this._callOnWrappedNode(el, wrap);\n\t            return wrap;\n\t        }\n\t    }, {\n\t        key: '_createSplitContainer',\n\t\n\t        /**\n\t         * Create split container element\n\t         * @param originalElement {Node} original text node element that is created a wrapper for\n\t         * @param index\n\t         * @param offset\n\t         * @returns {*|jQuery|Node}\n\t         */\n\t        value: function _createSplitContainer(originalElement, index, offset) {\n\t            var wrapper = this.document.createElement(TAG_NAME),\n\t                vTrue = 'true';\n\t            wrapper.setAttribute(_utilUtil.DATA_IS_SELECTION, vTrue);\n\t            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(originalElement, index));\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n\t            return wrapper;\n\t        }\n\t    }, {\n\t        key: '_walkTextNodes',\n\t\n\t        /**\n\t         * Extracts all TextNodes inside a container\n\t         * @param {Node} el\n\t         * @returns {Array.<Text>}\n\t         */\n\t        value: function _walkTextNodes(el, func) {\n\t            this.walkDom(el, function (node) {\n\t                if (Node.TEXT_NODE === node.nodeType && !_utilUtil2['default'].nodeIsEmpty(node)) {\n\t                    func(node);\n\t                }\n\t                return true;\n\t            });\n\t        }\n\t    }, {\n\t        key: 'walk',\n\t\n\t        /**\n\t         * Walks the tree\n\t         * @param start\n\t         * @param endContainer\n\t         * @param nextParent\n\t         */\n\t        value: function walk(start, endContainer, nextParent) {\n\t            var nextParentNode = start;\n\t            while (nextParentNode && nextParentNode !== nextParent.parentNode) {\n\t                var currentParentNode = nextParentNode;\n\t                nextParentNode = nextParentNode.parentNode;\n\t                if (this.wrapSiblings(currentParentNode.nextSibling, endContainer)) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: 'wrapSiblings',\n\t\n\t        /**\n\t         * Will Wrap all textNode siblings of a container (start) inside a defined Element (like a span)\n\t         * If an Element node is found, it will wrap all children of this node inside a element as well.\n\t         * It will stop if endContainer is found as a node\n\t         *\n\t         * @param {Node} start\n\t         * @param {Node} endContainer\n\t         * @returns {boolean} (true if endContainer was found)\n\t         */\n\t        value: function wrapSiblings(start, endContainer) {\n\t            var _this = this;\n\t\n\t            var next = start,\n\t                found = false;\n\t\n\t            // Capsule some logic\n\t            var wrap = (function (n) {\n\t                if (n.parentNode.hasAttribute(ATTR_DATA_START_END) && n.parentNode.hasAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE) && n.parentNode.getAttribute(ATTR_DATA_ID) === _this.getId()) {\n\t                    var thisNode = _this._createWrap(n).parentNode;\n\t                    thisNode.classList.remove(_this.cssClass);\n\t                    thisNode.removeAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE);\n\t                } else {\n\t                    _this._createWrap(n);\n\t                }\n\t            }).bind(this);\n\t\n\t            // helper functions\n\t\n\t            var wrapIf = function wrapIf(n) {\n\t                if (!_utilUtil2['default'].nodeIsEmpty(n)) {\n\t                    wrap(n);\n\t                }\n\t            };\n\t\n\t            var walkIfContained = function walkIfContained(e) {\n\t                if (e === endContainer) {\n\t                    return false;\n\t                }\n\t                if (Node.TEXT_NODE === e.nodeType) {\n\t                    wrapIf(e);\n\t                }\n\t                return true;\n\t            };\n\t\n\t            var walkIfNotContained = function walkIfNotContained(el) {\n\t                wrapIf(el);\n\t            };\n\t\n\t            while (next !== null && next !== endContainer) {\n\t                var currentNext = next;\n\t                next = next.nextSibling;\n\t                // Found a text node, directly wrap inside a span\n\t                if (Node.TEXT_NODE === currentNext.nodeType) {\n\t                    wrapIf(currentNext);\n\t                } else {\n\t                    if (currentNext.compareDocumentPosition(endContainer) & DOCUMENT_POSITION_CONTAINED_BY) {\n\t                        this.walkDom(currentNext, walkIfContained);\n\t                        found = true;\n\t                    } else {\n\t                        this._walkTextNodes(currentNext, walkIfNotContained);\n\t                    }\n\t                    if (found) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            return found;\n\t        }\n\t    }, {\n\t        key: 'walkDom',\n\t\n\t        /**\n\t         * Recursively walks the dom tree unless func returns false\n\t         * This is a lot more efficient then using any jQuery operations\n\t         *\n\t         * Applies node to function\n\t         * @param node\n\t         * @param func\n\t         * @returns {*}\n\t         */\n\t        value: function walkDom(node, func) {\n\t            if (!node) {\n\t                return false;\n\t            }\n\t            var children = node.childNodes;\n\t            if (!children) {\n\t                return false;\n\t            }\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (!this.walkDom(children[i], func)) {\n\t                    return false;\n\t                }\n\t            }\n\t            return func(node);\n\t        }\n\t    }, {\n\t        key: '_markTextSameNode',\n\t\n\t        /**\n\t         * Marks text of the same node\n\t         * @param {Node} textNode\n\t         * @param {int} startIndex\n\t         * @param {int} endIndex\n\t         * @private\n\t         */\n\t        value: function _markTextSameNode(textNode, startIndex, endIndex) {\n\t\n\t            var initialText = textNode.nodeValue,\n\t                initialIndex = _utilUtil2['default'].calcIndex(textNode);\n\t\n\t            if (!initialText) {\n\t                return false;\n\t            }\n\t\n\t            //If there is an unmarked part in the beginning of the text node,\n\t            //cut off that part and put it into it's own textnode.\n\t            if (startIndex > 0) {\n\t                var textBefore = initialText.slice(0, startIndex);\n\t                textNode.parentNode.insertBefore(this.document.createTextNode(textBefore), textNode);\n\t                // wrap cutted text node:\n\t                _utilUtil2['default'].wrap(textNode.previousSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode)));\n\t            }\n\t            //If there is an unmarked part at the end of the text node,\n\t            //cut off that part and put it into it's own textnode.\n\t            if (endIndex < initialText.length) {\n\t                var textAfter = initialText.slice(endIndex, initialText.length);\n\t                textNode.parentNode.insertBefore(this.document.createTextNode(textAfter), textNode.nextSibling);\n\t                _utilUtil2['default'].wrap(textNode.nextSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode) + endIndex));\n\t            }\n\t\n\t            //Cutoff the unmarked parts and wrap the textnode into a span.\n\t            textNode.nodeValue = initialText.slice(startIndex, endIndex);\n\t            this.startContainer = this._createWrap(textNode, Rendering._getOffsetParentIfHas(textNode) + startIndex, initialIndex, true).parentNode;\n\t            this.endContainer = this.startContainer;\n\t            return this.startContainer;\n\t        }\n\t    }, {\n\t        key: '_markTextDifferentNode',\n\t\n\t        /**\n\t         * Marks text of end and start containers if start and end nodes are different\n\t         * Important: There might be no end container!\n\t         *\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @returns {{startT: (Node), endT: (Node)}}\n\t         * @private\n\t         */\n\t        value: function _markTextDifferentNode(startContainer, endContainer, startOffset, endOffset) {\n\t            // Get current for both start and end:\n\t            var startContainerIndex = _utilUtil2['default'].calcIndex(startContainer);\n\t            var endContainerIndex = _utilUtil2['default'].calcIndex(endContainer);\n\t\n\t            // Split text\n\t            var fullTextStartValue = startContainer.nodeValue;\n\t            // init with startContainer because we may have not a text node here\n\t            var startT = startContainer;\n\t\n\t            if (undefined !== fullTextStartValue) {\n\t                var partTextStartValue = fullTextStartValue.slice(startOffset, fullTextStartValue.length);\n\t                // Set new text to start node\n\t                startContainer.nodeValue = fullTextStartValue.slice(0, startOffset);\n\t\n\t                var offsetStart = Rendering._getOffsetParentIfHas(startContainer);\n\t                // Create a new node for splitted text, offset is the length of new startContainer.nodeValue:\n\t                startT = this._createStartOrEndContainer(startContainer, this.markerPrefix, partTextStartValue, offsetStart === startOffset ? offsetStart : offsetStart + startOffset, startContainerIndex);\n\t                // Append this node after startContainer\n\t                startContainer.parentNode.insertBefore(startT, startContainer.nextSibling);\n\t                this.startContainer = startT;\n\t\n\t                if (startContainer.nodeValue) {\n\t                    // Wrap start container in detection node, offset is always 0 or parent offset.\n\t                    _utilUtil2['default'].wrap(startContainer, this._createSplitContainer(startContainer, startContainerIndex, Rendering._getOffsetParentIfHas(startContainer)));\n\t                }\n\t            }\n\t\n\t            // init with endContainer because we may have not a text node here\n\t            var endT = endContainer;\n\t\n\t            // 2. Extract end Text node,\n\t            var fullTextEndValue = endContainer.nodeValue;\n\t            // It's possible that end container value is null (if a whole paragraph is marked)\n\t            if (undefined !== fullTextEndValue) {\n\t                // Split text\n\t                var partTextEndValue = fullTextEndValue.slice(0, endOffset);\n\t                endContainer.nodeValue = fullTextEndValue.slice(endOffset, fullTextEndValue.length);\n\t                // End Container start offset is always 0 or parent offset.\n\t                endT = this._createStartOrEndContainer(endContainer, this.markerSuffix, partTextEndValue, Rendering._getOffsetParentIfHas(endContainer), endContainerIndex);\n\t\n\t                endContainer.parentNode.insertBefore(endT, endContainer);\n\t                this.endContainer = endT;\n\t                var offsetParent = Rendering._getOffsetParentIfHas(endContainer);\n\t                _utilUtil2['default'].wrap(endContainer, this._createSplitContainer(endContainer, endContainerIndex, offsetParent === endOffset ? offsetParent : offsetParent + endOffset));\n\t            }\n\t\n\t            return { startT: startT, endT: endT };\n\t        }\n\t    }, {\n\t        key: '_findOriginalOffset',\n\t\n\t        /**\n\t         * Will return the original first offset\n\t         * @param element\n\t         * @returns {int}\n\t         * @private\n\t         */\n\t        value: function _findOriginalOffset(element) {\n\t            if (!element.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n\t                return 0;\n\t            }\n\t            var lengthElement = _utilUtil2['default'].parent(element, '[' + ATTR_DATA_ORIGINAL_OFFSET_START + ']');\n\t            return lengthElement ? parseInt(lengthElement.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : 0;\n\t        }\n\t    }, {\n\t        key: '_renderWithElements',\n\t\n\t        /**\n\t         * Renders a selection\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {Node} commonAncestor\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @param {boolean} [withoutResult] if true result will not be calculated\n\t         * @returns {{startOffset: (int), endOffset: (int)}} the original offsets found\n\t         * @private\n\t         */\n\t        value: function _renderWithElements(startContainer, endContainer, commonAncestor, startOffset, endOffset, withoutResult) {\n\t            var outer = _utilUtil2['default'].parents(startContainer, commonAncestor);\n\t            outer = outer[outer.length - 1];\n\t            var contextContainer = outer ? outer : commonAncestor;\n\t\n\t            // Same Element, means the selection is fully contained in a discrete area, start and endpoint have the same parent\n\t            // but are different nodes:\n\t\n\t            // Start and End offset have to be recalculated because dom might be already changed by highlighting in given node\n\t            // 1: First detect real start offset in startContainer:\n\t\n\t            // That works by selecting the highest wrapper and get original-offset-start data element, see \"findOriginalOffset\"\n\t            // So first select that container:\n\t            var originalStartOffset = this._findOriginalOffset(startContainer);\n\t            var originalEndOffset = this._findOriginalOffset(endContainer);\n\t\n\t            // We may run into Browser Bugs:\n\t\n\t            // If both are not text nodes, use next sibling as endContainer\n\t            if (startContainer.nodeType !== Node.TEXT_NODE && endContainer.nodeType !== Node.TEXT_NODE) {\n\t                if (startContainer === endContainer) {\n\t                    endContainer = endContainer.nextElementSibling || endContainer;\n\t                }\n\t            }\n\t            // IF start/end container is not type of text, select first child text node:\n\t            // We run in some bugs with firefox here that selects no text-nodes sometimes, trying to fix this here\n\t            // Sometimes does not work correctly... (specially when DOM was modified)\n\t            if (startContainer.nodeType !== Node.TEXT_NODE) {\n\t                this.walkDom(startContainer, function (el) {\n\t                    if (el.nodeType === Node.TEXT_NODE) {\n\t                        startContainer = el;\n\t                        return false;\n\t                    }\n\t                    return true;\n\t                });\n\t            }\n\t\n\t            if (endContainer.nodeType !== Node.TEXT_NODE) {\n\t                // Get the last text node:\n\t                var endContainerContents = _utilUtil2['default'].closest(startContainer, ':not([' + _utilUtil.DATA_IS_SELECTION + '])').childNodes;\n\t                if (endContainerContents.length) {\n\t                    var r = endContainerContents[endContainerContents.length - 1];\n\t                    if (r.nodeType === Node.TEXT_NODE) {\n\t                        endContainer = r;\n\t                        endOffset = r.length;\n\t                    } else {\n\t                        var f = r.lastChild;\n\t                        while (f !== null) {\n\t                            if (f && f.nodeType === Node.TEXT_NODE) {\n\t                                endContainer = f;\n\t                                endOffset = f.length;\n\t                                if (f.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n\t                                    endOffset = parseInt(f.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) + endOffset;\n\t                                }\n\t                            }\n\t                            f = f.lastChild;\n\t                        }\n\t                    }\n\t                }\n\t                // still no textNode?\n\t                if (endContainer.nodeType !== Node.TEXT_NODE) {\n\t                    throw 'Could not found endContainer, highlighting would be unstable';\n\t                }\n\t            }\n\t\n\t            var result = withoutResult || {\n\t                // Real offset is calculated by relative length and absolute length\n\t                startOffset: originalStartOffset + startOffset,\n\t                endOffset: originalEndOffset + endOffset,\n\t                // get the path for this selection\n\t                startContainerPath: _utilUtil2['default'].getPath(startContainer, this.context),\n\t                endContainerPath: _utilUtil2['default'].getPath(endContainer, this.context)\n\t            };\n\t\n\t            this._renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer);\n\t\n\t            return result;\n\t        }\n\t    }, {\n\t        key: '_renderSelection',\n\t\n\t        /**\n\t         * Renders a given selection\n\t         *\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @param {Node} contextContainer\n\t         * @param {Node} outer\n\t         * @private\n\t         */\n\t        value: function _renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer) {\n\t\n\t            // if start and end-container are the same, mark text on the same node\n\t            if (startContainer === endContainer) {\n\t                this._markTextSameNode(startContainer, startOffset, endOffset);\n\t            } else {\n\t                var result = this._markTextDifferentNode(startContainer, endContainer, startOffset, endOffset);\n\t                if (!outer) {\n\t                    this.wrapSiblings(result.startT.nextSibling, endContainer);\n\t                } else {\n\t                    this.walk(result.startT, endContainer, contextContainer);\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: '_deserializePath',\n\t\n\t        /**\n\t         * Deserialize a specific path and finds the right textNodes\n\t         * This even works when DOM has been manipulated before by `marklib`\n\t         * @param {string} path the serialized path (including offsets)\n\t         * @return {Node}\n\t         * @private\n\t         */\n\t        value: function _deserializePath(path) {\n\t            var pSplit = path.split(';'),\n\t                p = pSplit[0],\n\t                objectIndex = parseInt(pSplit[1]),\n\t                charOffset = parseInt(pSplit[2]),\n\t                container = !p.trim() ? this.context : this.context.querySelector(p);\n\t            var maybeFoundNode = null;\n\t            this.walkDom(container, function (n) {\n\t                if (n.nodeType === Node.TEXT_NODE) {\n\t                    var atrOffsetStart = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START);\n\t                    atrOffsetStart = atrOffsetStart === null ? 0 : atrOffsetStart;\n\t                    var atrIndex = n.parentNode.getAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX);\n\t                    atrIndex = atrIndex === null ? _utilUtil2['default'].calcIndex(n) : atrIndex;\n\t                    if (parseInt(atrIndex) === objectIndex && charOffset >= atrOffsetStart && parseInt(atrOffsetStart) + n.length >= charOffset) {\n\t                        var thisOffset = n.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START) ? charOffset - parseInt(n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : charOffset;\n\t                        maybeFoundNode = { node: n, offset: thisOffset };\n\t                        return false;\n\t                    }\n\t                } else {\n\t                    return true;\n\t                }\n\t                return true;\n\t            });\n\t\n\t            return maybeFoundNode;\n\t        }\n\t    }, {\n\t        key: 'renderWithPath',\n\t\n\t        /**\n\t         * Prepares to render a Selection with path selectors\n\t         * ```\n\t         * A Path looks like this:\n\t         *\n\t         * #selector;#textnode;#offset\n\t         * ``\n\t         * @param {string} startPath\n\t         * @param {string} endPath\n\t         * @returns {string}\n\t         */\n\t        value: function renderWithPath(startPath, endPath) {\n\t            var startContainer = this._deserializePath(startPath);\n\t            var endContainer = this._deserializePath(endPath);\n\t            if (startContainer && endContainer && startContainer.node && endContainer.node) {\n\t                var range = document.createRange();\n\t                range.setStart(startContainer.node, startContainer.offset);\n\t                range.setEnd(endContainer.node, endContainer.offset);\n\t                var text = range.toString();\n\t                this.renderWithRange(range, true);\n\t                return text;\n\t            }\n\t            throw 'Could not find start- and/or end-container in document';\n\t        }\n\t    }, {\n\t        key: 'renderWithResult',\n\t\n\t        /**\n\t         * Renders a result (that returned from `renderWithRange`)\n\t         * @param result\n\t         * @returns {string}\n\t         */\n\t        value: function renderWithResult(result) {\n\t            return this.renderWithPath(result.startContainerPath + ';' + result.startOffset, result.endContainerPath + ';' + result.endOffset);\n\t        }\n\t    }, {\n\t        key: 'renderWithRange',\n\t\n\t        /**\n\t         * Prepares a selection with a range object\n\t         * @param {Range} range\n\t         * @param {boolean} [withoutResult] optional do calculate a result, the selection would not be serializable\n\t         * @returns {Object}\n\t         */\n\t        value: function renderWithRange(range, withoutResult) {\n\t            return this._renderWithElements(range.startContainer, range.endContainer, range.commonAncestorContainer, range.startOffset, range.endOffset, withoutResult);\n\t        }\n\t    }], [{\n\t        key: '_getIndexParentIfHas',\n\t\n\t        /**\n\t         * @param {Node} container\n\t         * @param {Number} thisIndex\n\t         * @returns {int} index of parent or original\n\t         * @private\n\t         */\n\t        value: function _getIndexParentIfHas(container, thisIndex) {\n\t            var p = container.parentNode;\n\t            var index = parseInt(p.getAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX));\n\t            return index > thisIndex ? index : thisIndex;\n\t        }\n\t    }, {\n\t        key: '_getOffsetParentIfHas',\n\t\n\t        /**\n\t         * @param container\n\t         * @returns {int} offset start of parent if has, else 0\n\t         */\n\t        value: function _getOffsetParentIfHas(container) {\n\t            var p = container.parentNode;\n\t            var offset = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START));\n\t            return offset > 0 ? offset : 0;\n\t        }\n\t    }]);\n\t\n\t    return Rendering;\n\t})();\n\t\n\texports['default'] = Rendering;\n\tmodule.exports = exports['default'];\n\t//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL3NyYy9tYWluL1JlbmRlcmluZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7O3dCQUVJLFdBQVc7Ozs7Ozs7QUFPNUIsSUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDOzs7O0FBSTVCLElBQU0sK0JBQStCLEdBQUcsNEJBQTRCLENBQUM7Ozs7QUFJckUsSUFBTSw2QkFBNkIsR0FBRywwQkFBMEIsQ0FBQzs7OztBQUlqRSxJQUFNLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDOzs7O0FBSWhELElBQU0sMkJBQTJCLEdBQUcsd0JBQXdCLENBQUM7Ozs7QUFJN0QsSUFBTSxZQUFZLEdBQUcsbUJBQW1CLENBQUM7Ozs7OztBQU16QyxJQUFNLDhCQUE4QixHQUFHLEVBQUUsQ0FBQzs7SUFHcEMsU0FBUztBQUVBLGFBRlQsU0FBUyxDQUVDLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFOzhCQUZ2QyxTQUFTOztBQUlQLFlBQUksRUFBRSxRQUFRLFlBQVksUUFBUSxDQUFBLEFBQUMsRUFBRTtBQUNqQyxrQkFBTSxtREFBbUQsQ0FBQztTQUM3RDs7OztBQUlELFlBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDOzs7Ozs7QUFNekIsWUFBSSxDQUFDLEVBQUUsR0FBRyxzQkFBSyxJQUFJLEVBQUUsQ0FBQzs7Ozs7O0FBTXRCLFlBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxLQUFLLFFBQVEsR0FBRyxTQUFTLEdBQUcsUUFBUSxDQUFDOzs7Ozs7QUFNOUQsWUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7Ozs7OztBQU0zQixZQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQzs7Ozs7O0FBTXpCLFlBQUksQ0FBQyxZQUFZLEdBQUcs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QUFHLFNBQVMsQ0FBQyxVQUFVLENBQUM7QUFDN0IsZ0JBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLCtCQUErQixDQUFDLENBQUMsQ0FBQztBQUN2RSxtQkFBTyxNQUFNLEdBQUcsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDbEM7OztXQXBIQyxTQUFTOzs7cUJBQVQsU0FBUyIsImZpbGUiOiIvVXNlcnMvYm93bGluZ3gvUHJvamVrdGUvbWFya2xpYi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvYm93bGluZ3gvUHJvamVrdGUvbWFya2xpYi9zcmMvbWFpbi9SZW5kZXJpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgTm9kZSwgRG9jdW1lbnQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXRpbCBmcm9tICd1dGlsL1V0aWwnO1xuXG5pbXBvcnQge0FUVFJfREFUQV9PUklHSU5BTF9JTkRFWCwgREFUQV9JU19TRUxFQ1RJT059IGZyb20gJ3V0aWwvVXRpbCc7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgVEFHX05BTUUgPSAneC1tYXJrZXInO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJUID0gJ2RhdGEtb3JpZ2luYWwtb2Zmc2V0LXN0YXJ0Jztcbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgREFUQV9PUklHSU5BTF9URVhUX05PREVfSU5ERVggPSAnb3JpZ2luYWwtdGV4dC1ub2RlLWluZGV4Jztcbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgQVRUUl9EQVRBX1NUQVJUX0VORCA9ICdkYXRhLWlzLXN0YXJ0LWVuZCc7XG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IEFUVFJfREFUQV9JU19ISUdITElHSFRfTk9ERSA9ICdkYXRhLWlzLWhpZ2hsaWdodC1ub2RlJztcbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgQVRUUl9EQVRBX0lEID0gJ2RhdGEtc2VsZWN0aW9uLWlkJztcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9Ob2RlL2NvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkgPSAxNjtcblxuZXhwb3J0IGRlZmF1bHRcbmNsYXNzIFJlbmRlcmluZyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgY3NzQ2xhc3MsIGNvbnRleHQpIHtcblxuICAgICAgICBpZiAoIShkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgJ01hcmtsaWIgezB9IGlzIHJlcXVpcmVkIHRvIGJlIGEgZG9jdW1lbnQgaW5zdGFuY2UnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RG9jdW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHJlbmRlcmluZywgd2lsbCBiZSBzZXQgb24gZWFjaCBlbGVtZW50IHRoYXQgaXMgcGFydCBvZiBpdFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IFV0aWwuZ3VpZCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGFzcyB0aGF0IGlzIHNldCBvbiBhbGwgaGlnaGxpZ2h0IG5vZGVzXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNzc0NsYXNzID0gdW5kZWZpbmVkID09PSBjc3NDbGFzcyA/ICdtYXJraW5nJyA6IGNzc0NsYXNzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydENvbnRhaW5lclxuICAgICAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmRDb250YWluZXJcbiAgICAgICAgICogQHR5cGUge05vZGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZENvbnRhaW5lciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZWZpeCBiZWZvcmUgSURcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFya2VyUHJlZml4ID0gJ21hcmtlci1zdGFydC0nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWZmaXggYmVmb3JlIElEXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtlclN1ZmZpeCA9ICdtYXJrZXItZW5kLSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtOb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmRvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbldyYXBwZWROb2RlRnVuYyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gaWQgb2YgdGhpcyByZW5kZXJpbmdcbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge1JlbmRlcmluZ31cbiAgICAgKi9cbiAgICBzZXRJZChpZCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBub2RlIGlzIHdyYXBwZWQgb24gdGhpcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyaW5nfVxuICAgICAqL1xuICAgIG9uV3JhcHBlZE5vZGUoZikge1xuICAgICAgICB0aGlzLl9vbldyYXBwZWROb2RlRnVuYyA9IGY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGxPbldyYXBwZWROb2RlKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uV3JhcHBlZE5vZGVGdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9vbldyYXBwZWROb2RlRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7aW50fSBpbmRleCBvZiBwYXJlbnQgb3Igb3JpZ2luYWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfZ2V0SW5kZXhQYXJlbnRJZkhhcyhjb250YWluZXIsIHRoaXNJbmRleCkge1xuICAgICAgICB2YXIgcCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChwLmdldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfSU5ERVgpKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gdGhpc0luZGV4ID8gaW5kZXggOiB0aGlzSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtpbnR9IG9mZnNldCBzdGFydCBvZiBwYXJlbnQgaWYgaGFzLCBlbHNlIDBcbiAgICAgKi9cbiAgICBzdGF0aWMgX2dldE9mZnNldFBhcmVudElmSGFzKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgcCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocC5nZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCkpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID4gMCA/IG9mZnNldCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRlbXBsYXRlIHVzZWQgYXMgYSB3cmFwcGVyXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlV3JhcFRlbXBsYXRlKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoVEFHX05BTUUpLCB2VHJ1ZSA9IFwidHJ1ZVwiO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSB0aGlzLmNzc0NsYXNzO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoREFUQV9JU19TRUxFQ1RJT04sIHZUcnVlKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9JRCwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9JU19ISUdITElHSFRfTk9ERSwgdlRydWUpO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVGVtcGxhdGUgdG8gdXNlIGFzIHN0YXJ0IGFuZCBlbmQgbWFya3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVN0YXJ0RW5kV3JhcFRlbXBsYXRlKHRleHQpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5fY3JlYXRlV3JhcFRlbXBsYXRlKCksIHZUcnVlID0gXCJ0cnVlXCI7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShBVFRSX0RBVEFfU1RBUlRfRU5ELCB2VHJ1ZSk7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBTdGFydCBvciBFbmQgQ29udGFpbmVyIEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE5vZGVcbiAgICAgKiBAcGFyYW0gcHJlZml4XG4gICAgICogQHBhcmFtIHRleHRcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICovXG4gICAgX2NyZWF0ZVN0YXJ0T3JFbmRDb250YWluZXIoaW5pdGlhbE5vZGUsIHByZWZpeCwgdGV4dCwgb2Zmc2V0LCBpbmRleCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5fY3JlYXRlU3RhcnRFbmRXcmFwVGVtcGxhdGUodGV4dCk7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9JTkRFWCwgUmVuZGVyaW5nLl9nZXRJbmRleFBhcmVudElmSGFzKGluaXRpYWxOb2RlLCBpbmRleCkpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJULCBvZmZzZXQpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShEQVRBX09SSUdJTkFMX1RFWFRfTk9ERV9JTkRFWCwgaW5kZXgpO1xuICAgICAgICB3cmFwcGVyLm1hcmtsaWJJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIFtvcHRpb25hbExlbmd0aF1cbiAgICAgKiBAcGFyYW0gW29wdGlvbmFsSW5kZXhdXG4gICAgICogQHBhcmFtIFtvcHRpb25hbElzU2FtZU5vZGVdXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlV3JhcChlbCwgb3B0aW9uYWxMZW5ndGgsIG9wdGlvbmFsSW5kZXgsIG9wdGlvbmFsSXNTYW1lTm9kZSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGV4ID0gb3B0aW9uYWxJbmRleCA+PSAwID8gb3B0aW9uYWxJbmRleCA6IFV0aWwuY2FsY0luZGV4KGVsKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuX2NyZWF0ZVdyYXBUZW1wbGF0ZSgpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfSU5ERVgsIFJlbmRlcmluZy5fZ2V0SW5kZXhQYXJlbnRJZkhhcyhlbCwgb3JpZ2luYWxJbmRleCkpO1xuICAgICAgICBjb25zdCBvZmZzZXRMZW5ndGggPSBvcHRpb25hbExlbmd0aCA+PSAwID8gb3B0aW9uYWxMZW5ndGggOiBSZW5kZXJpbmcuX2dldE9mZnNldFBhcmVudElmSGFzKGVsKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCwgb2Zmc2V0TGVuZ3RoKTtcblxuICAgICAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIHRleHQgbm9kZSBpbiB3cmFwcGVyXG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKERBVEFfT1JJR0lOQUxfVEVYVF9OT0RFX0lOREVYLCBvcmlnaW5hbEluZGV4KTtcblxuICAgICAgICAvLyBzYXZlIHRoaXMgbWFya2VyIGluc3RhbmNlIHRvIGdpdmVuIG5vZGVcbiAgICAgICAgd3JhcHBlci5tYXJrbGliSW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvcHRpb25hbElzU2FtZU5vZGUpIHtcbiAgICAgICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9TVEFSVF9FTkQsIEFUVFJfREFUQV9TVEFSVF9FTkQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXAgPSBVdGlsLndyYXAoZWwsIHdyYXBwZXIpO1xuICAgICAgICB0aGlzLl9jYWxsT25XcmFwcGVkTm9kZShlbCwgd3JhcCk7XG4gICAgICAgIHJldHVybiB3cmFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzcGxpdCBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEVsZW1lbnQge05vZGV9IG9yaWdpbmFsIHRleHQgbm9kZSBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZCBhIHdyYXBwZXIgZm9yXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeXxOb2RlfVxuICAgICAqL1xuICAgIF9jcmVhdGVTcGxpdENvbnRhaW5lcihvcmlnaW5hbEVsZW1lbnQsIGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChUQUdfTkFNRSksIHZUcnVlID0gXCJ0cnVlXCI7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKERBVEFfSVNfU0VMRUNUSU9OLCB2VHJ1ZSk7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9JTkRFWCwgUmVuZGVyaW5nLl9nZXRJbmRleFBhcmVudElmSGFzKG9yaWdpbmFsRWxlbWVudCwgaW5kZXgpKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCwgb2Zmc2V0KTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoREFUQV9PUklHSU5BTF9URVhUX05PREVfSU5ERVgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgYWxsIFRleHROb2RlcyBpbnNpZGUgYSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge0FycmF5LjxUZXh0Pn1cbiAgICAgKi9cbiAgICBfd2Fsa1RleHROb2RlcyhlbCwgZnVuYykge1xuICAgICAgICB0aGlzLndhbGtEb20oZWwsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoTm9kZS5URVhUX05PREUgPT09IG5vZGUubm9kZVR5cGUgJiYgIVV0aWwubm9kZUlzRW1wdHkobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBmdW5jKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhbGtzIHRoZSB0cmVlXG4gICAgICogQHBhcmFtIHN0YXJ0XG4gICAgICogQHBhcmFtIGVuZENvbnRhaW5lclxuICAgICAqIEBwYXJhbSBuZXh0UGFyZW50XG4gICAgICovXG4gICAgd2FsayhzdGFydCwgZW5kQ29udGFpbmVyLCBuZXh0UGFyZW50KSB7XG4gICAgICAgIGxldCBuZXh0UGFyZW50Tm9kZSA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSAobmV4dFBhcmVudE5vZGUgJiYgbmV4dFBhcmVudE5vZGUgIT09IG5leHRQYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnROb2RlID0gbmV4dFBhcmVudE5vZGU7XG4gICAgICAgICAgICBuZXh0UGFyZW50Tm9kZSA9IG5leHRQYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy53cmFwU2libGluZ3MoY3VycmVudFBhcmVudE5vZGUubmV4dFNpYmxpbmcsIGVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2lsbCBXcmFwIGFsbCB0ZXh0Tm9kZSBzaWJsaW5ncyBvZiBhIGNvbnRhaW5lciAoc3RhcnQpIGluc2lkZSBhIGRlZmluZWQgRWxlbWVudCAobGlrZSBhIHNwYW4pXG4gICAgICogSWYgYW4gRWxlbWVudCBub2RlIGlzIGZvdW5kLCBpdCB3aWxsIHdyYXAgYWxsIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSBpbnNpZGUgYSBlbGVtZW50IGFzIHdlbGwuXG4gICAgICogSXQgd2lsbCBzdG9wIGlmIGVuZENvbnRhaW5lciBpcyBmb3VuZCBhcyBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVuZENvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAodHJ1ZSBpZiBlbmRDb250YWluZXIgd2FzIGZvdW5kKVxuICAgICAqL1xuICAgIHdyYXBTaWJsaW5ncyhzdGFydCwgZW5kQ29udGFpbmVyKSB7XG4gICAgICAgIGxldCBuZXh0ID0gc3RhcnQsXG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENhcHN1bGUgc29tZSBsb2dpY1xuICAgICAgICBjb25zdCB3cmFwID0gKChuKSA9PiB7XG4gICAgICAgICAgICBpZiAobi5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShBVFRSX0RBVEFfU1RBUlRfRU5EKSAmJlxuICAgICAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9EQVRBX0lTX0hJR0hMSUdIVF9OT0RFKSAmJlxuICAgICAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX0lEKSA9PT0gdGhpcy5nZXRJZCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRoaXNOb2RlID0gdGhpcy5fY3JlYXRlV3JhcChuKS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHRoaXNOb2RlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jc3NDbGFzcyk7XG4gICAgICAgICAgICAgICAgdGhpc05vZGUucmVtb3ZlQXR0cmlidXRlKEFUVFJfREFUQV9JU19ISUdITElHSFRfTk9ERSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVdyYXAobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gaGVscGVyIGZ1bmN0aW9uc1xuXG4gICAgICAgIGNvbnN0IHdyYXBJZiA9IChuKSA9PiB7XG4gICAgICAgICAgICBpZiAoIVV0aWwubm9kZUlzRW1wdHkobikpIHtcbiAgICAgICAgICAgICAgICB3cmFwKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHdhbGtJZkNvbnRhaW5lZCA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSA9PT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE5vZGUuVEVYVF9OT0RFID09PSBlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgd3JhcElmKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgd2Fsa0lmTm90Q29udGFpbmVkID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB3cmFwSWYoZWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChuZXh0ICE9PSBudWxsICYmIG5leHQgIT09IGVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgLy8gRm91bmQgYSB0ZXh0IG5vZGUsIGRpcmVjdGx5IHdyYXAgaW5zaWRlIGEgc3BhblxuICAgICAgICAgICAgaWYgKE5vZGUuVEVYVF9OT0RFID09PSBjdXJyZW50TmV4dC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIHdyYXBJZihjdXJyZW50TmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudE5leHQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZW5kQ29udGFpbmVyKSAmIERPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxrRG9tKGN1cnJlbnROZXh0LCB3YWxrSWZDb250YWluZWQpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2Fsa1RleHROb2RlcyhjdXJyZW50TmV4dCwgd2Fsa0lmTm90Q29udGFpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgd2Fsa3MgdGhlIGRvbSB0cmVlIHVubGVzcyBmdW5jIHJldHVybnMgZmFsc2VcbiAgICAgKiBUaGlzIGlzIGEgbG90IG1vcmUgZWZmaWNpZW50IHRoZW4gdXNpbmcgYW55IGpRdWVyeSBvcGVyYXRpb25zXG4gICAgICpcbiAgICAgKiBBcHBsaWVzIG5vZGUgdG8gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgd2Fsa0RvbShub2RlLCBmdW5jKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndhbGtEb20oY2hpbGRyZW5baV0sIGZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRleHQgb2YgdGhlIHNhbWUgbm9kZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGV4dE5vZGVcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRJbmRleFxuICAgICAqIEBwYXJhbSB7aW50fSBlbmRJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21hcmtUZXh0U2FtZU5vZGUodGV4dE5vZGUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG5cbiAgICAgICAgY29uc3QgaW5pdGlhbFRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsSW5kZXggPSBVdGlsLmNhbGNJbmRleCh0ZXh0Tm9kZSk7XG5cbiAgICAgICAgaWYgKCFpbml0aWFsVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiB0aGVyZSBpcyBhbiB1bm1hcmtlZCBwYXJ0IGluIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQgbm9kZSxcbiAgICAgICAgLy9jdXQgb2ZmIHRoYXQgcGFydCBhbmQgcHV0IGl0IGludG8gaXQncyBvd24gdGV4dG5vZGUuXG4gICAgICAgIGlmIChzdGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dEJlZm9yZSA9IGluaXRpYWxUZXh0LnNsaWNlKDAsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgdGV4dE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0QmVmb3JlKSwgdGV4dE5vZGUpO1xuICAgICAgICAgICAgLy8gd3JhcCBjdXR0ZWQgdGV4dCBub2RlOlxuICAgICAgICAgICAgVXRpbC53cmFwKHRleHROb2RlLnByZXZpb3VzU2libGluZywgdGhpcy5fY3JlYXRlU3BsaXRDb250YWluZXIodGV4dE5vZGUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4LCBSZW5kZXJpbmcuX2dldE9mZnNldFBhcmVudElmSGFzKHRleHROb2RlKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vSWYgdGhlcmUgaXMgYW4gdW5tYXJrZWQgcGFydCBhdCB0aGUgZW5kIG9mIHRoZSB0ZXh0IG5vZGUsXG4gICAgICAgIC8vY3V0IG9mZiB0aGF0IHBhcnQgYW5kIHB1dCBpdCBpbnRvIGl0J3Mgb3duIHRleHRub2RlLlxuICAgICAgICBpZiAoZW5kSW5kZXggPCBpbml0aWFsVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRBZnRlciA9IGluaXRpYWxUZXh0LnNsaWNlKGVuZEluZGV4LCBpbml0aWFsVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgdGV4dE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0QWZ0ZXIpLCB0ZXh0Tm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBVdGlsLndyYXAodGV4dE5vZGUubmV4dFNpYmxpbmcsIHRoaXMuX2NyZWF0ZVNwbGl0Q29udGFpbmVyKHRleHROb2RlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCwgUmVuZGVyaW5nLl9nZXRPZmZzZXRQYXJlbnRJZkhhcyh0ZXh0Tm9kZSkgKyBlbmRJbmRleCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9DdXRvZmYgdGhlIHVubWFya2VkIHBhcnRzIGFuZCB3cmFwIHRoZSB0ZXh0bm9kZSBpbnRvIGEgc3Bhbi5cbiAgICAgICAgdGV4dE5vZGUubm9kZVZhbHVlID0gaW5pdGlhbFRleHQuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gdGhpcy5fY3JlYXRlV3JhcCh0ZXh0Tm9kZSxcbiAgICAgICAgICAgIFJlbmRlcmluZy5fZ2V0T2Zmc2V0UGFyZW50SWZIYXModGV4dE5vZGUpICsgc3RhcnRJbmRleCwgaW5pdGlhbEluZGV4LCB0cnVlKS5wYXJlbnROb2RlO1xuICAgICAgICB0aGlzLmVuZENvbnRhaW5lciA9IHRoaXMuc3RhcnRDb250YWluZXI7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0Q29udGFpbmVyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGV4dCBvZiBlbmQgYW5kIHN0YXJ0IGNvbnRhaW5lcnMgaWYgc3RhcnQgYW5kIGVuZCBub2RlcyBhcmUgZGlmZmVyZW50XG4gICAgICogSW1wb3J0YW50OiBUaGVyZSBtaWdodCBiZSBubyBlbmQgY29udGFpbmVyIVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBzdGFydENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0T2Zmc2V0XG4gICAgICogQHBhcmFtIHtpbnR9IGVuZE9mZnNldFxuICAgICAqIEByZXR1cm5zIHt7c3RhcnRUOiAoTm9kZSksIGVuZFQ6IChOb2RlKX19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFya1RleHREaWZmZXJlbnROb2RlKHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgZm9yIGJvdGggc3RhcnQgYW5kIGVuZDpcbiAgICAgICAgY29uc3Qgc3RhcnRDb250YWluZXJJbmRleCA9IFV0aWwuY2FsY0luZGV4KHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgZW5kQ29udGFpbmVySW5kZXggPSBVdGlsLmNhbGNJbmRleChlbmRDb250YWluZXIpO1xuXG4gICAgICAgIC8vIFNwbGl0IHRleHRcbiAgICAgICAgY29uc3QgZnVsbFRleHRTdGFydFZhbHVlID0gc3RhcnRDb250YWluZXIubm9kZVZhbHVlO1xuICAgICAgICAvLyBpbml0IHdpdGggc3RhcnRDb250YWluZXIgYmVjYXVzZSB3ZSBtYXkgaGF2ZSBub3QgYSB0ZXh0IG5vZGUgaGVyZVxuICAgICAgICBsZXQgc3RhcnRUID0gc3RhcnRDb250YWluZXI7XG5cbiAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnVsbFRleHRTdGFydFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcGFydFRleHRTdGFydFZhbHVlID0gZnVsbFRleHRTdGFydFZhbHVlLnNsaWNlKHN0YXJ0T2Zmc2V0LCBmdWxsVGV4dFN0YXJ0VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIFNldCBuZXcgdGV4dCB0byBzdGFydCBub2RlXG4gICAgICAgICAgICBzdGFydENvbnRhaW5lci5ub2RlVmFsdWUgPSBmdWxsVGV4dFN0YXJ0VmFsdWUuc2xpY2UoMCwgc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0U3RhcnQgPSBSZW5kZXJpbmcuX2dldE9mZnNldFBhcmVudElmSGFzKHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBub2RlIGZvciBzcGxpdHRlZCB0ZXh0LCBvZmZzZXQgaXMgdGhlIGxlbmd0aCBvZiBuZXcgc3RhcnRDb250YWluZXIubm9kZVZhbHVlOlxuICAgICAgICAgICAgc3RhcnRUID0gdGhpcy5fY3JlYXRlU3RhcnRPckVuZENvbnRhaW5lcihzdGFydENvbnRhaW5lciwgdGhpcy5tYXJrZXJQcmVmaXgsIHBhcnRUZXh0U3RhcnRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRTdGFydCA9PT0gc3RhcnRPZmZzZXQgPyBvZmZzZXRTdGFydCA6IG9mZnNldFN0YXJ0ICsgc3RhcnRPZmZzZXQsIHN0YXJ0Q29udGFpbmVySW5kZXgpO1xuICAgICAgICAgICAgLy8gQXBwZW5kIHRoaXMgbm9kZSBhZnRlciBzdGFydENvbnRhaW5lclxuICAgICAgICAgICAgc3RhcnRDb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3RhcnRULCBzdGFydENvbnRhaW5lci5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gc3RhcnRUO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCBzdGFydCBjb250YWluZXIgaW4gZGV0ZWN0aW9uIG5vZGUsIG9mZnNldCBpcyBhbHdheXMgMCBvciBwYXJlbnQgb2Zmc2V0LlxuICAgICAgICAgICAgICAgIFV0aWwud3JhcChzdGFydENvbnRhaW5lciwgdGhpcy5fY3JlYXRlU3BsaXRDb250YWluZXIoc3RhcnRDb250YWluZXIsIHN0YXJ0Q29udGFpbmVySW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIFJlbmRlcmluZy5fZ2V0T2Zmc2V0UGFyZW50SWZIYXMoc3RhcnRDb250YWluZXIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0IHdpdGggZW5kQ29udGFpbmVyIGJlY2F1c2Ugd2UgbWF5IGhhdmUgbm90IGEgdGV4dCBub2RlIGhlcmVcbiAgICAgICAgbGV0IGVuZFQgPSBlbmRDb250YWluZXI7XG5cbiAgICAgICAgLy8gMi4gRXh0cmFjdCBlbmQgVGV4dCBub2RlLFxuICAgICAgICBjb25zdCBmdWxsVGV4dEVuZFZhbHVlID0gZW5kQ29udGFpbmVyLm5vZGVWYWx1ZTtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGVuZCBjb250YWluZXIgdmFsdWUgaXMgbnVsbCAoaWYgYSB3aG9sZSBwYXJhZ3JhcGggaXMgbWFya2VkKVxuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdWxsVGV4dEVuZFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBTcGxpdCB0ZXh0XG4gICAgICAgICAgICB2YXIgcGFydFRleHRFbmRWYWx1ZSA9IGZ1bGxUZXh0RW5kVmFsdWUuc2xpY2UoMCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lci5ub2RlVmFsdWUgPSBmdWxsVGV4dEVuZFZhbHVlLnNsaWNlKGVuZE9mZnNldCwgZnVsbFRleHRFbmRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gRW5kIENvbnRhaW5lciBzdGFydCBvZmZzZXQgaXMgYWx3YXlzIDAgb3IgcGFyZW50IG9mZnNldC5cbiAgICAgICAgICAgIGVuZFQgPSB0aGlzLl9jcmVhdGVTdGFydE9yRW5kQ29udGFpbmVyKGVuZENvbnRhaW5lciwgdGhpcy5tYXJrZXJTdWZmaXgsIHBhcnRUZXh0RW5kVmFsdWUsXG4gICAgICAgICAgICAgICAgUmVuZGVyaW5nLl9nZXRPZmZzZXRQYXJlbnRJZkhhcyhlbmRDb250YWluZXIpLCBlbmRDb250YWluZXJJbmRleCk7XG5cbiAgICAgICAgICAgIGVuZENvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbmRULCBlbmRDb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5lbmRDb250YWluZXIgPSBlbmRUO1xuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IFJlbmRlcmluZy5fZ2V0T2Zmc2V0UGFyZW50SWZIYXMoZW5kQ29udGFpbmVyKTtcbiAgICAgICAgICAgIFV0aWwud3JhcChlbmRDb250YWluZXIsIHRoaXMuX2NyZWF0ZVNwbGl0Q29udGFpbmVyKGVuZENvbnRhaW5lciwgZW5kQ29udGFpbmVySW5kZXgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID09PSBlbmRPZmZzZXQgPyBvZmZzZXRQYXJlbnQgOiBvZmZzZXRQYXJlbnQgKyBlbmRPZmZzZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7c3RhcnRUOiBzdGFydFQsIGVuZFQ6IGVuZFR9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCBmaXJzdCBvZmZzZXRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtpbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE9yaWdpbmFsT2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9PRkZTRVRfU1RBUlQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGhFbGVtZW50ID0gVXRpbC5wYXJlbnQoZWxlbWVudCwgJ1snICsgQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCArICddJyk7XG4gICAgICAgIHJldHVybiBsZW5ndGhFbGVtZW50ID8gcGFyc2VJbnQobGVuZ3RoRWxlbWVudC5nZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCkpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtOb2RlfSBzdGFydENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtOb2RlfSBjb21tb25BbmNlc3RvclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydE9mZnNldFxuICAgICAqIEBwYXJhbSB7aW50fSBlbmRPZmZzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRob3V0UmVzdWx0XSBpZiB0cnVlIHJlc3VsdCB3aWxsIG5vdCBiZSBjYWxjdWxhdGVkXG4gICAgICogQHJldHVybnMge3tzdGFydE9mZnNldDogKGludCksIGVuZE9mZnNldDogKGludCl9fSB0aGUgb3JpZ2luYWwgb2Zmc2V0cyBmb3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlcldpdGhFbGVtZW50cyhzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyLCBjb21tb25BbmNlc3Rvciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgd2l0aG91dFJlc3VsdCkge1xuICAgICAgICBsZXQgb3V0ZXIgPSBVdGlsLnBhcmVudHMoc3RhcnRDb250YWluZXIsIGNvbW1vbkFuY2VzdG9yKTtcbiAgICAgICAgb3V0ZXIgPSBvdXRlcltvdXRlci5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgY29udGV4dENvbnRhaW5lciA9IG91dGVyID8gb3V0ZXIgOiBjb21tb25BbmNlc3RvcjtcblxuICAgICAgICAvLyBTYW1lIEVsZW1lbnQsIG1lYW5zIHRoZSBzZWxlY3Rpb24gaXMgZnVsbHkgY29udGFpbmVkIGluIGEgZGlzY3JldGUgYXJlYSwgc3RhcnQgYW5kIGVuZHBvaW50IGhhdmUgdGhlIHNhbWUgcGFyZW50XG4gICAgICAgIC8vIGJ1dCBhcmUgZGlmZmVyZW50IG5vZGVzOlxuXG4gICAgICAgIC8vIFN0YXJ0IGFuZCBFbmQgb2Zmc2V0IGhhdmUgdG8gYmUgcmVjYWxjdWxhdGVkIGJlY2F1c2UgZG9tIG1pZ2h0IGJlIGFscmVhZHkgY2hhbmdlZCBieSBoaWdobGlnaHRpbmcgaW4gZ2l2ZW4gbm9kZVxuICAgICAgICAvLyAxOiBGaXJzdCBkZXRlY3QgcmVhbCBzdGFydCBvZmZzZXQgaW4gc3RhcnRDb250YWluZXI6XG5cbiAgICAgICAgLy8gVGhhdCB3b3JrcyBieSBzZWxlY3RpbmcgdGhlIGhpZ2hlc3Qgd3JhcHBlciBhbmQgZ2V0IG9yaWdpbmFsLW9mZnNldC1zdGFydCBkYXRhIGVsZW1lbnQsIHNlZSBcImZpbmRPcmlnaW5hbE9mZnNldFwiXG4gICAgICAgIC8vIFNvIGZpcnN0IHNlbGVjdCB0aGF0IGNvbnRhaW5lcjpcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydE9mZnNldCA9IHRoaXMuX2ZpbmRPcmlnaW5hbE9mZnNldChzdGFydENvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRW5kT2Zmc2V0ID0gdGhpcy5fZmluZE9yaWdpbmFsT2Zmc2V0KGVuZENvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gV2UgbWF5IHJ1biBpbnRvIEJyb3dzZXIgQnVnczpcblxuICAgICAgICAvLyBJZiBib3RoIGFyZSBub3QgdGV4dCBub2RlcywgdXNlIG5leHQgc2libGluZyBhcyBlbmRDb250YWluZXJcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJiBlbmRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIgPT09IGVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGVuZENvbnRhaW5lci5uZXh0RWxlbWVudFNpYmxpbmcgfHwgZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElGIHN0YXJ0L2VuZCBjb250YWluZXIgaXMgbm90IHR5cGUgb2YgdGV4dCwgc2VsZWN0IGZpcnN0IGNoaWxkIHRleHQgbm9kZTpcbiAgICAgICAgLy8gV2UgcnVuIGluIHNvbWUgYnVncyB3aXRoIGZpcmVmb3ggaGVyZSB0aGF0IHNlbGVjdHMgbm8gdGV4dC1ub2RlcyBzb21ldGltZXMsIHRyeWluZyB0byBmaXggdGhpcyBoZXJlXG4gICAgICAgIC8vIFNvbWV0aW1lcyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseS4uLiAoc3BlY2lhbGx5IHdoZW4gRE9NIHdhcyBtb2RpZmllZClcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgdGhpcy53YWxrRG9tKHN0YXJ0Q29udGFpbmVyLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZWw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxhc3QgdGV4dCBub2RlOlxuICAgICAgICAgICAgY29uc3QgZW5kQ29udGFpbmVyQ29udGVudHMgPSBVdGlsLmNsb3Nlc3Qoc3RhcnRDb250YWluZXIsICc6bm90KFsnICsgREFUQV9JU19TRUxFQ1RJT04gKyAnXSknKS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgaWYgKGVuZENvbnRhaW5lckNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBlbmRDb250YWluZXJDb250ZW50c1tlbmRDb250YWluZXJDb250ZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gcjtcbiAgICAgICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYgPSByLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmICYmIGYubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBwYXJzZUludChmLnBhcmVudE5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9PRkZTRVRfU1RBUlQpKSArIGVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gZi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGlsbCBubyB0ZXh0Tm9kZT9cbiAgICAgICAgICAgIGlmIChlbmRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0NvdWxkIG5vdCBmb3VuZCBlbmRDb250YWluZXIsIGhpZ2hsaWdodGluZyB3b3VsZCBiZSB1bnN0YWJsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gd2l0aG91dFJlc3VsdCB8fCB7XG4gICAgICAgICAgICAgICAgLy8gUmVhbCBvZmZzZXQgaXMgY2FsY3VsYXRlZCBieSByZWxhdGl2ZSBsZW5ndGggYW5kIGFic29sdXRlIGxlbmd0aFxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBvcmlnaW5hbFN0YXJ0T2Zmc2V0ICsgc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0OiBvcmlnaW5hbEVuZE9mZnNldCArIGVuZE9mZnNldCxcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBhdGggZm9yIHRoaXMgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgc3RhcnRDb250YWluZXJQYXRoOiBVdGlsLmdldFBhdGgoc3RhcnRDb250YWluZXIsIHRoaXMuY29udGV4dCksXG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyUGF0aDogVXRpbC5nZXRQYXRoKGVuZENvbnRhaW5lciwgdGhpcy5jb250ZXh0KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJTZWxlY3Rpb24oc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgY29udGV4dENvbnRhaW5lciwgb3V0ZXIpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGdpdmVuIHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBzdGFydENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0T2Zmc2V0XG4gICAgICogQHBhcmFtIHtpbnR9IGVuZE9mZnNldFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY29udGV4dENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gb3V0ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZWxlY3Rpb24oc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgY29udGV4dENvbnRhaW5lciwgb3V0ZXIpIHtcblxuICAgICAgICAvLyBpZiBzdGFydCBhbmQgZW5kLWNvbnRhaW5lciBhcmUgdGhlIHNhbWUsIG1hcmsgdGV4dCBvbiB0aGUgc2FtZSBub2RlXG4gICAgICAgIGlmIChzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrVGV4dFNhbWVOb2RlKHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9tYXJrVGV4dERpZmZlcmVudE5vZGUoc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIW91dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwU2libGluZ3MocmVzdWx0LnN0YXJ0VC5uZXh0U2libGluZywgZW5kQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrKHJlc3VsdC5zdGFydFQsIGVuZENvbnRhaW5lciwgY29udGV4dENvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplIGEgc3BlY2lmaWMgcGF0aCBhbmQgZmluZHMgdGhlIHJpZ2h0IHRleHROb2Rlc1xuICAgICAqIFRoaXMgZXZlbiB3b3JrcyB3aGVuIERPTSBoYXMgYmVlbiBtYW5pcHVsYXRlZCBiZWZvcmUgYnkgYG1hcmtsaWJgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHNlcmlhbGl6ZWQgcGF0aCAoaW5jbHVkaW5nIG9mZnNldHMpXG4gICAgICogQHJldHVybiB7Tm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZXNlcmlhbGl6ZVBhdGgocGF0aCkge1xuICAgICAgICBjb25zdCBwU3BsaXQgPSBwYXRoLnNwbGl0KCc7JyksIHAgPSBwU3BsaXRbMF0sXG4gICAgICAgICAgICBvYmplY3RJbmRleCA9IHBhcnNlSW50KHBTcGxpdFsxXSksXG4gICAgICAgICAgICBjaGFyT2Zmc2V0ID0gcGFyc2VJbnQocFNwbGl0WzJdKSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9ICFwLnRyaW0oKSA/IHRoaXMuY29udGV4dCA6IHRoaXMuY29udGV4dC5xdWVyeVNlbGVjdG9yKHApO1xuICAgICAgICBsZXQgbWF5YmVGb3VuZE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLndhbGtEb20oY29udGFpbmVyLCBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0ck9mZnNldFN0YXJ0ID0gbi5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJUKTtcbiAgICAgICAgICAgICAgICBhdHJPZmZzZXRTdGFydCA9IGF0ck9mZnNldFN0YXJ0ID09PSBudWxsID8gMCA6IGF0ck9mZnNldFN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBhdHJJbmRleCA9IG4ucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX0lOREVYKTtcbiAgICAgICAgICAgICAgICBhdHJJbmRleCA9IGF0ckluZGV4ID09PSBudWxsID8gVXRpbC5jYWxjSW5kZXgobikgOiBhdHJJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoYXRySW5kZXgpID09PSBvYmplY3RJbmRleCAmJiBjaGFyT2Zmc2V0ID49IGF0ck9mZnNldFN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgICgocGFyc2VJbnQoYXRyT2Zmc2V0U3RhcnQpICsgbi5sZW5ndGgpID49IGNoYXJPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlzT2Zmc2V0ID0gbi5wYXJlbnROb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAuaGFzQXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9PRkZTRVRfU1RBUlQpID8gY2hhck9mZnNldCAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KG4ucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJUKSkgOiBjaGFyT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBtYXliZUZvdW5kTm9kZSA9IHtub2RlOiBuLCBvZmZzZXQ6IHRoaXNPZmZzZXR9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF5YmVGb3VuZE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgdG8gcmVuZGVyIGEgU2VsZWN0aW9uIHdpdGggcGF0aCBzZWxlY3RvcnNcbiAgICAgKiBgYGBcbiAgICAgKiBBIFBhdGggbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogI3NlbGVjdG9yOyN0ZXh0bm9kZTsjb2Zmc2V0XG4gICAgICogYGBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRQYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFBhdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHJlbmRlcldpdGhQYXRoKHN0YXJ0UGF0aCwgZW5kUGF0aCkge1xuICAgICAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IHRoaXMuX2Rlc2VyaWFsaXplUGF0aChzdGFydFBhdGgpO1xuICAgICAgICBjb25zdCBlbmRDb250YWluZXIgPSB0aGlzLl9kZXNlcmlhbGl6ZVBhdGgoZW5kUGF0aCk7XG4gICAgICAgIGlmIChzdGFydENvbnRhaW5lciAmJiBlbmRDb250YWluZXIgJiYgc3RhcnRDb250YWluZXIubm9kZSAmJiBlbmRDb250YWluZXIubm9kZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLm5vZGUsIHN0YXJ0Q29udGFpbmVyLm9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoZW5kQ29udGFpbmVyLm5vZGUsIGVuZENvbnRhaW5lci5vZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhbmdlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcldpdGhSYW5nZShyYW5nZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyAnQ291bGQgbm90IGZpbmQgc3RhcnQtIGFuZC9vciBlbmQtY29udGFpbmVyIGluIGRvY3VtZW50JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgcmVzdWx0ICh0aGF0IHJldHVybmVkIGZyb20gYHJlbmRlcldpdGhSYW5nZWApXG4gICAgICogQHBhcmFtIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgcmVuZGVyV2l0aFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyV2l0aFBhdGgoXG4gICAgICAgICAgICBgJHtyZXN1bHQuc3RhcnRDb250YWluZXJQYXRofTske3Jlc3VsdC5zdGFydE9mZnNldH1gLFxuICAgICAgICAgICAgYCR7cmVzdWx0LmVuZENvbnRhaW5lclBhdGh9OyR7cmVzdWx0LmVuZE9mZnNldH1gKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgc2VsZWN0aW9uIHdpdGggYSByYW5nZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhvdXRSZXN1bHRdIG9wdGlvbmFsIGRvIGNhbGN1bGF0ZSBhIHJlc3VsdCwgdGhlIHNlbGVjdGlvbiB3b3VsZCBub3QgYmUgc2VyaWFsaXphYmxlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICByZW5kZXJXaXRoUmFuZ2UocmFuZ2UsIHdpdGhvdXRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcldpdGhFbGVtZW50cyhyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2UuZW5kQ29udGFpbmVyLFxuICAgICAgICAgICAgcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRPZmZzZXQsIHdpdGhvdXRSZXN1bHQpO1xuICAgIH1cbn1cblxuIl19\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _Object$defineProperty = __webpack_require__(5)[\"default\"];\n\t\n\texports[\"default\"] = (function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t\n\t      _Object$defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t})();\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(6), __esModule: true };\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(7);\n\tmodule.exports = function defineProperty(it, key, desc){\n\t  return $.setDesc(it, key, desc);\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar global = typeof self != 'undefined' ? self : Function('return this')()\n\t  , core   = {}\n\t  , defineProperty = Object.defineProperty\n\t  , hasOwnProperty = {}.hasOwnProperty\n\t  , ceil  = Math.ceil\n\t  , floor = Math.floor\n\t  , max   = Math.max\n\t  , min   = Math.min;\n\t// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.\n\tvar DESC = !!function(){\n\t  try {\n\t    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;\n\t  } catch(e){ /* empty */ }\n\t}();\n\tvar hide = createDefiner(1);\n\t// 7.1.4 ToInteger\n\tfunction toInteger(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t}\n\tfunction desc(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t}\n\tfunction simpleSet(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t}\n\tfunction createDefiner(bitmap){\n\t  return DESC ? function(object, key, value){\n\t    return $.setDesc(object, key, desc(bitmap, value));\n\t  } : simpleSet;\n\t}\n\t\n\tfunction isObject(it){\n\t  return it !== null && (typeof it == 'object' || typeof it == 'function');\n\t}\n\tfunction isFunction(it){\n\t  return typeof it == 'function';\n\t}\n\tfunction assertDefined(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t}\n\t\n\tvar $ = module.exports = __webpack_require__(8)({\n\t  g: global,\n\t  core: core,\n\t  html: global.document && document.documentElement,\n\t  // http://jsperf.com/core-js-isobject\n\t  isObject:   isObject,\n\t  isFunction: isFunction,\n\t  that: function(){\n\t    return this;\n\t  },\n\t  // 7.1.4 ToInteger\n\t  toInteger: toInteger,\n\t  // 7.1.15 ToLength\n\t  toLength: function(it){\n\t    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t  },\n\t  toIndex: function(index, length){\n\t    index = toInteger(index);\n\t    return index < 0 ? max(index + length, 0) : min(index, length);\n\t  },\n\t  has: function(it, key){\n\t    return hasOwnProperty.call(it, key);\n\t  },\n\t  create:     Object.create,\n\t  getProto:   Object.getPrototypeOf,\n\t  DESC:       DESC,\n\t  desc:       desc,\n\t  getDesc:    Object.getOwnPropertyDescriptor,\n\t  setDesc:    defineProperty,\n\t  setDescs:   Object.defineProperties,\n\t  getKeys:    Object.keys,\n\t  getNames:   Object.getOwnPropertyNames,\n\t  getSymbols: Object.getOwnPropertySymbols,\n\t  assertDefined: assertDefined,\n\t  // Dummy, fix for not array-like ES3 string in es5 module\n\t  ES5Object: Object,\n\t  toObject: function(it){\n\t    return $.ES5Object(assertDefined(it));\n\t  },\n\t  hide: hide,\n\t  def: createDefiner(0),\n\t  set: global.Symbol ? simpleSet : hide,\n\t  each: [].forEach\n\t});\n\t/* eslint-disable no-undef */\n\tif(typeof __e != 'undefined')__e = core;\n\tif(typeof __g != 'undefined')__g = global;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function($){\n\t  $.FW   = false;\n\t  $.path = $.core;\n\t  return $;\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports[\"default\"] = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global Node, NodeList, Element */\n\t\n\t'use strict';\n\t\n\tvar _createClass = __webpack_require__(4)['default'];\n\t\n\tvar _classCallCheck = __webpack_require__(9)['default'];\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ORIGINAL_INDEX = 'data-original-index';\n\texports.ATTR_DATA_ORIGINAL_INDEX = ATTR_DATA_ORIGINAL_INDEX;\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_PSEUDO = 'data-is-pseudo';\n\texports.DATA_PSEUDO = DATA_PSEUDO;\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_IS_SELECTION = 'data-is-selection';\n\texports.DATA_IS_SELECTION = DATA_IS_SELECTION;\n\t/**\n\t * @type {string}\n\t */\n\tvar SERIALIZE_SEPARATOR = ';';\n\t\n\t// polyfill for matchesSelector, IE 10/11 does not support Element.matches\n\tif (Element && !Element.prototype.matches) {\n\t    var p = Element.prototype;\n\t    p.matches = p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t}\n\t\n\t/**\n\t * Utility class\n\t * Contains DOM/Node manipulation helpers\n\t */\n\t\n\tvar Util = (function () {\n\t    function Util() {\n\t        _classCallCheck(this, Util);\n\t    }\n\t\n\t    _createClass(Util, null, [{\n\t        key: 'nodeListFilter',\n\t\n\t        /**\n\t         * Filter for a NodeList\n\t         * @param {NodeList} nodes\n\t         * @param {Function} func\n\t         * @returns {Array.<HTMLElement>}\n\t         */\n\t        value: function nodeListFilter(nodes, func) {\n\t            return Array.prototype.filter.call(nodes || [], func);\n\t        }\n\t    }, {\n\t        key: 'guid',\n\t\n\t        /**\n\t         * Generates a unique id\n\t         * @return {String}\n\t         */\n\t        value: function guid() {\n\t            function s4() {\n\t                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t            }\n\t\n\t            return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t        }\n\t    }, {\n\t        key: 'nodeIsEmpty',\n\t\n\t        /**\n\t         * Checks if a given node is empty\n\t         * @param {HTMLElement} node\n\t         * @returns {*}\n\t         */\n\t        value: function nodeIsEmpty(node) {\n\t            return node.nodeValue.match(/^[\\s]*$/g);\n\t        }\n\t    }, {\n\t        key: 'index',\n\t\n\t        /**\n\t         * @param {HTMLElement} node\n\t         * @param [optionalList]\n\t         * @return {int} the index of this node in context to it's siblings\n\t         */\n\t        value: function index(node, optionalList) {\n\t            var children = optionalList || (node.nodeType === Node.TEXT_NODE ? node.parentNode.childNodes : node.parentNode.children);\n\t            return Array.prototype.indexOf.call(children || [], node);\n\t        }\n\t    }, {\n\t        key: 'wrap',\n\t\n\t        /**\n\t         * Wraps given `elms` in given `wrapper`\n\t         *\n\t         * @param {HTMLElement} wrapper\n\t         * @param {HTMLElement|Array.<HTMLElement>} elms\n\t         * @return {HTMLElement}\n\t         */\n\t        value: function wrap(elms, wrapper) {\n\t            if (!elms) {\n\t                return wrapper;\n\t            }\n\t            // Convert `elms` to an array, if necessary.\n\t            if (!(elms instanceof NodeList || elms instanceof Array)) {\n\t                elms = [elms];\n\t            }\n\t            for (var i = elms.length - 1; i >= 0; i--) {\n\t                var child = i > 0 ? wrapper.cloneNode(true) : wrapper;\n\t                var el = elms[i];\n\t                // Cache the current parent and sibling.\n\t                var _parent = el.parentNode,\n\t                    sibling = el.nextSibling;\n\t\n\t                child.appendChild(el);\n\t                if (sibling) {\n\t                    _parent.insertBefore(child, sibling);\n\t                } else {\n\t                    _parent.appendChild(child);\n\t                }\n\t            }\n\t            return wrapper;\n\t        }\n\t    }, {\n\t        key: 'calcIndex',\n\t\n\t        /**\n\t         * Will calculate an index depending on an already modified dom by marklib\n\t         * @param {HTMLElement} node\n\t         * @returns {int|boolean}\n\t         */\n\t        value: function calcIndex(node) {\n\t            var calculatedIndex = 0,\n\t                foundWrapper = false;\n\t            var nodes = node.parentNode.childNodes,\n\t                length = nodes.length;\n\t            for (var thisIndex = 0; thisIndex < length; thisIndex++) {\n\t                var el = nodes[thisIndex];\n\t                if (el === node) {\n\t                    break;\n\t                }\n\t                // reset index when original index is found\n\t                var maybeIndexOfOriginal = el.getAttribute ? el.getAttribute(ATTR_DATA_ORIGINAL_INDEX) : null;\n\t\n\t                if (maybeIndexOfOriginal) {\n\t                    calculatedIndex = parseInt(maybeIndexOfOriginal);\n\t                    foundWrapper = true;\n\t                }\n\t                calculatedIndex++;\n\t            }\n\t            return foundWrapper ? calculatedIndex : Util.index(node);\n\t        }\n\t    }, {\n\t        key: 'parents',\n\t\n\t        /**\n\t         * @param {HTMLElement} el\n\t         * @param {String} [optionalSelector] will test given element against a selector\n\t         *  if matches, returns this element immediately\n\t         * @return {Array.<HTMLElement>} an array of all found parents of given element (and optional selector)\n\t         */\n\t        value: function parents(el, optionalSelector) {\n\t            var element = el;\n\t            var foundElements = [];\n\t            while (element.parentNode !== null) {\n\t                element = element.parentNode;\n\t                if (optionalSelector && (element === optionalSelector || typeof optionalSelector === 'string' && element.matches && element.matches(optionalSelector))) {\n\t                    foundElements.push(element);\n\t                } else if (!optionalSelector) {\n\t                    foundElements.push(element);\n\t                }\n\t            }\n\t            return foundElements;\n\t        }\n\t    }, {\n\t        key: 'parent',\n\t\n\t        /**\n\t         * Finds a parent node (the closest) with a given selector\n\t         * @param {Node} el\n\t         * @param {String} selector\n\t         * @returns {Node|bool}\n\t         */\n\t        value: function parent(el, selector) {\n\t            var element = el;\n\t            while (element.parentNode !== null) {\n\t                element = element.parentNode;\n\t                if (element.matches && element.matches(selector)) {\n\t                    return element;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'closest',\n\t\n\t        /**\n\t         * Finds the closest element including itself matching a given selector\n\t         * @param {Node} el\n\t         * @param selector\n\t         * @returns {Node|bool}\n\t         */\n\t        value: function closest(el, selector) {\n\t            var element = el;\n\t            while (element !== null) {\n\t                if (element.matches && element.matches(selector)) {\n\t                    return element;\n\t                }\n\t                element = element.parentNode;\n\t            }\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'isMarkNode',\n\t\n\t        /**\n\t         * @param {HTMLElement} n\n\t         * @return {bool}\n\t         */\n\t        value: function isMarkNode(n) {\n\t            return n instanceof HTMLElement && n.hasAttribute(DATA_IS_SELECTION);\n\t        }\n\t    }, {\n\t        key: 'getPath',\n\t\n\t        /**\n\t         * Determines the correct paths and excludes all `marklib` generated content\n\t         * TODO: To improve performance we could shorten the path if an ID is present in it.\n\t         * @param {HTMLElement} el\n\t         * @param {HTMLElement} [context] if given extraction path is relative to this element\n\t         * @returns {string}\n\t         */\n\t        value: function getPath(el, context) {\n\t            var path = null,\n\t                node = el;\n\t\n\t            var filterSiblings = function filterSiblings(thisEl) {\n\t                return !Util.isMarkNode(thisEl) && thisEl.nodeName === node.nodeName;\n\t            };\n\t\n\t            while (node) {\n\t                var name = null;\n\t                // If node is a text-node, save index\n\t                if (Node.TEXT_NODE === node.nodeType) {\n\t\n\t                    /* Because nodes may wrapped inside a highlighting node, we need to find the original index that was\n\t                     * valid before the dom changes. We store the last known index position inside all wrapper elements\n\t                     * We select the outermost\n\t                     */\n\t\n\t                    // Extract original index of this node:\n\t                    // Outer most data-original-index is original index\n\t                    var outerMostElement = Util.parents(node, '[' + ATTR_DATA_ORIGINAL_INDEX + ']').reverse()[0];\n\t                    // if element is not yet wrapped in span, recalculate index based on parent container:\n\t                    // We have to do this because text node indexes != element indexes...\n\t                    var calculatedIndex = 0;\n\t                    if (!outerMostElement) {\n\t                        calculatedIndex = Util.calcIndex(node);\n\t                    }\n\t                    var index = outerMostElement ? parseInt(outerMostElement.getAttribute(ATTR_DATA_ORIGINAL_INDEX)) : calculatedIndex;\n\t                    name = SERIALIZE_SEPARATOR + index;\n\t                } else {\n\t                    name = node.nodeName;\n\t                }\n\t\n\t                if (!name) {\n\t                    break;\n\t                }\n\t\n\t                name = name.toLowerCase();\n\t\n\t                var parent = node.parentNode;\n\t\n\t                if (Util.isMarkNode(node)) {\n\t                    if (parent !== context) {\n\t                        node = parent;\n\t                        continue;\n\t                    } else {\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                // Select only siblings that are not part of selection and are of the same type\n\t                // (because we use nth-of-type selector later)\n\t                var siblings = Util.nodeListFilter(parent.children, filterSiblings),\n\t                    nodeIndex = Util.index(node, siblings);\n\t\n\t                if (siblings.length > 1 && nodeIndex >= 0) {\n\t                    name += ':nth-of-type(' + (nodeIndex + 1) + ')';\n\t                }\n\t\n\t                path = name + (path ? '>' + path : '');\n\t\n\t                if (parent === context) {\n\t                    break;\n\t                }\n\t\n\t                node = parent;\n\t            }\n\t\n\t            return path.replace('#document>', '').replace('>;', ';');\n\t        }\n\t    }]);\n\t\n\t    return Util;\n\t})();\n\t\n\texports['default'] = Util;\n\t//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL3NyYy9tYWluL3V0aWwvVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7O0FBS04sSUFBTSx3QkFBd0IsR0FBRyxxQkFBcUIsQ0FBQztRQUFqRCx3QkFBd0IsR0FBeEIsd0JBQXdCOzs7O0FBSTlCLElBQU0sV0FBVyxHQUFHLGdCQUFnQixDQUFDO1FBQS9CLFdBQVcsR0FBWCxXQUFXOzs7O0FBSWpCLElBQU0saUJBQWlCLEdBQUcsbUJBQW1CLENBQUM7UUFBeEMsaUJBQWlCLEdBQWpCLGlCQUFpQjs7OztBQUk5QixJQUFNLG1CQUFtQixHQUFHLEdBQUcsQ0FBQzs7O0FBR2hDLElBQUksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUU7QUFDdkMsUUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztBQUMxQixLQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxlQUFlLElBQ3pCLENBQUMsQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLENBQUMsaUJBQWlCLElBQzNDLENBQUMsQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLENBQUMscUJBQXFCLENBQUM7Q0FDckQ7Ozs7Ozs7SUFPSyxJQUFJO2FBQUosSUFBSTs4QkFBSixJQUFJOzs7aUJBQUosSUFBSTs7Ozs7Ozs7O2VBT2Usd0JBQUMsS0FBSyxFQUFFLElBQUksRUFBRTtBQUMvQixtQkFBTyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUN6RDs7Ozs7Ozs7ZUFPVSxnQkFBRztBQUNWLHFCQUFTLEVBQUUsR0FBRztBQUNWLHVCQUFPLElBQUksQ0FB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Q0FBQztpQkFDbkQ7O0FBRUQsb0JBQUksR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBLEFBQUMsQ0FBQzs7QUFHdkMsb0JBQUksTUFBTSxLQUFLLE9BQU8sRUFBRTtBQUNwQiwwQkFBTTtpQkFDVDs7QUFFRCxvQkFBSSxHQUFHLE1BQU0sQ0FBQzthQUNqQjs7QUFFRCxtQkFBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQzVEOzs7V0FyUEMsSUFBSTs7O3FCQUFKLElBQUkiLCJmaWxlIjoiL1VzZXJzL2Jvd2xpbmd4L1Byb2pla3RlL21hcmtsaWIvbm9kZV9tb2R1bGVzL2VzbGludC1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2Jvd2xpbmd4L1Byb2pla3RlL21hcmtsaWIvc3JjL21haW4vdXRpbC9VdGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIE5vZGUsIE5vZGVMaXN0LCBFbGVtZW50ICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQVRUUl9EQVRBX09SSUdJTkFMX0lOREVYID0gJ2RhdGEtb3JpZ2luYWwtaW5kZXgnO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgREFUQV9QU0VVRE8gPSAnZGF0YS1pcy1wc2V1ZG8nO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgREFUQV9JU19TRUxFQ1RJT04gPSAnZGF0YS1pcy1zZWxlY3Rpb24nO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBTRVJJQUxJWkVfU0VQQVJBVE9SID0gXCI7XCI7XG5cbi8vIHBvbHlmaWxsIGZvciBtYXRjaGVzU2VsZWN0b3IsIElFIDEwLzExIGRvZXMgbm90IHN1cHBvcnQgRWxlbWVudC5tYXRjaGVzXG5pZiAoRWxlbWVudCAmJiAhRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgIHZhciBwID0gRWxlbWVudC5wcm90b3R5cGU7XG4gICAgcC5tYXRjaGVzID0gcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG59XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzc1xuICogQ29udGFpbnMgRE9NL05vZGUgbWFuaXB1bGF0aW9uIGhlbHBlcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHRcbmNsYXNzIFV0aWwge1xuICAgIC8qKlxuICAgICAqIEZpbHRlciBmb3IgYSBOb2RlTGlzdFxuICAgICAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48SFRNTEVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHN0YXRpYyBub2RlTGlzdEZpbHRlcihub2RlcywgZnVuYykge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKG5vZGVzIHx8IFtdLCBmdW5jKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBpZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ3VpZCgpIHtcbiAgICAgICAgZnVuY3Rpb24gczQoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICAgLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICtcbiAgICAgICAgICAgIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gbm9kZSBpcyBlbXB0eVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbm9kZUlzRW1wdHkobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5ub2RlVmFsdWUubWF0Y2goL15bXFxzXSokL2cpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSBbb3B0aW9uYWxMaXN0XVxuICAgICAqIEByZXR1cm4ge2ludH0gdGhlIGluZGV4IG9mIHRoaXMgbm9kZSBpbiBjb250ZXh0IHRvIGl0J3Mgc2libGluZ3NcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5kZXgobm9kZSwgb3B0aW9uYWxMaXN0KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gb3B0aW9uYWxMaXN0IHx8IChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMgOiBub2RlLnBhcmVudE5vZGUuY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChjaGlsZHJlbiB8fCBbXSwgbm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgZ2l2ZW4gYGVsbXNgIGluIGdpdmVuIGB3cmFwcGVyYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gd3JhcHBlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8QXJyYXkuPEhUTUxFbGVtZW50Pn0gZWxtc1xuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHN0YXRpYyB3cmFwKGVsbXMsIHdyYXBwZXIpIHtcbiAgICAgICAgaWYgKCFlbG1zKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IGBlbG1zYCB0byBhbiBhcnJheSwgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoIShlbG1zIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgZWxtcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgZWxtcyA9IFtlbG1zXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZWxtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAoaSA+IDApID8gd3JhcHBlci5jbG9uZU5vZGUodHJ1ZSkgOiB3cmFwcGVyO1xuICAgICAgICAgICAgY29uc3QgZWwgPSBlbG1zW2ldO1xuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGN1cnJlbnQgcGFyZW50IGFuZCBzaWJsaW5nLlxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50Tm9kZSwgc2libGluZyA9IGVsLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICBjaGlsZC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgY2FsY3VsYXRlIGFuIGluZGV4IGRlcGVuZGluZyBvbiBhbiBhbHJlYWR5IG1vZGlmaWVkIGRvbSBieSBtYXJrbGliXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqIEByZXR1cm5zIHtpbnR8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY0luZGV4KG5vZGUpIHtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRJbmRleCA9IDAsXG4gICAgICAgICAgICBmb3VuZFdyYXBwZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBub2RlLnBhcmVudE5vZGUuY2hpbGROb2RlcywgbGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCB0aGlzSW5kZXggPSAwOyB0aGlzSW5kZXggPCBsZW5ndGg7IHRoaXNJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IG5vZGVzW3RoaXNJbmRleF07XG4gICAgICAgICAgICBpZiAoZWwgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc2V0IGluZGV4IHdoZW4gb3JpZ2luYWwgaW5kZXggaXMgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IG1heWJlSW5kZXhPZk9yaWdpbmFsID0gZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9JTkRFWCkgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAobWF5YmVJbmRleE9mT3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSW5kZXggPSBwYXJzZUludChtYXliZUluZGV4T2ZPcmlnaW5hbCk7XG4gICAgICAgICAgICAgICAgZm91bmRXcmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGN1bGF0ZWRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZFdyYXBwZXIgPyBjYWxjdWxhdGVkSW5kZXggOiBVdGlsLmluZGV4KG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25hbFNlbGVjdG9yXSB3aWxsIHRlc3QgZ2l2ZW4gZWxlbWVudCBhZ2FpbnN0IGEgc2VsZWN0b3JcbiAgICAgKiAgaWYgbWF0Y2hlcywgcmV0dXJucyB0aGlzIGVsZW1lbnQgaW1tZWRpYXRlbHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48SFRNTEVsZW1lbnQ+fSBhbiBhcnJheSBvZiBhbGwgZm91bmQgcGFyZW50cyBvZiBnaXZlbiBlbGVtZW50IChhbmQgb3B0aW9uYWwgc2VsZWN0b3IpXG4gICAgICovXG4gICAgc3RhdGljIHBhcmVudHMoZWwsIG9wdGlvbmFsU2VsZWN0b3IpIHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBlbDtcbiAgICAgICAgY29uc3QgZm91bmRFbGVtZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsU2VsZWN0b3IgJiYgKChlbGVtZW50ID09PSBvcHRpb25hbFNlbGVjdG9yKSB8fFxuICAgICAgICAgICAgICAgICggKHR5cGVvZiBvcHRpb25hbFNlbGVjdG9yID09PSAnc3RyaW5nJykgJiYgZWxlbWVudC5tYXRjaGVzICYmIGVsZW1lbnQubWF0Y2hlcyhvcHRpb25hbFNlbGVjdG9yKSkpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3B0aW9uYWxTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGZvdW5kRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRFbGVtZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIHBhcmVudCBub2RlICh0aGUgY2xvc2VzdCkgd2l0aCBhIGdpdmVuIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICAgICAqIEByZXR1cm5zIHtOb2RlfGJvb2x9XG4gICAgICovXG4gICAgc3RhdGljIHBhcmVudChlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBlbDtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm1hdGNoZXMgJiYgZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgY2xvc2VzdCBlbGVtZW50IGluY2x1ZGluZyBpdHNlbGYgbWF0Y2hpbmcgYSBnaXZlbiBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXxib29sfVxuICAgICAqL1xuICAgIHN0YXRpYyBjbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICAgICAgICBsZXQgZWxlbWVudCA9IGVsO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubWF0Y2hlcyAmJiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBuXG4gICAgICogQHJldHVybiB7Ym9vbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNNYXJrTm9kZShuKSB7XG4gICAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgbi5oYXNBdHRyaWJ1dGUoREFUQV9JU19TRUxFQ1RJT04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGNvcnJlY3QgcGF0aHMgYW5kIGV4Y2x1ZGVzIGFsbCBgbWFya2xpYmAgZ2VuZXJhdGVkIGNvbnRlbnRcbiAgICAgKiBUT0RPOiBUbyBpbXByb3ZlIHBlcmZvcm1hbmNlIHdlIGNvdWxkIHNob3J0ZW4gdGhlIHBhdGggaWYgYW4gSUQgaXMgcHJlc2VudCBpbiBpdC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250ZXh0XSBpZiBnaXZlbiBleHRyYWN0aW9uIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhpcyBlbGVtZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGF0aChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcGF0aCA9IG51bGwsIG5vZGUgPSBlbDtcblxuICAgICAgICBjb25zdCBmaWx0ZXJTaWJsaW5ncyA9ICh0aGlzRWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhVXRpbC5pc01hcmtOb2RlKHRoaXNFbCkgJiYgdGhpc0VsLm5vZGVOYW1lID09PSBub2RlLm5vZGVOYW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBJZiBub2RlIGlzIGEgdGV4dC1ub2RlLCBzYXZlIGluZGV4XG4gICAgICAgICAgICBpZiAoTm9kZS5URVhUX05PREUgPT09IG5vZGUubm9kZVR5cGUpIHtcblxuICAgICAgICAgICAgICAgIC8qIEJlY2F1c2Ugbm9kZXMgbWF5IHdyYXBwZWQgaW5zaWRlIGEgaGlnaGxpZ2h0aW5nIG5vZGUsIHdlIG5lZWQgdG8gZmluZCB0aGUgb3JpZ2luYWwgaW5kZXggdGhhdCB3YXNcbiAgICAgICAgICAgICAgICAgKiB2YWxpZCBiZWZvcmUgdGhlIGRvbSBjaGFuZ2VzLiBXZSBzdG9yZSB0aGUgbGFzdCBrbm93biBpbmRleCBwb3NpdGlvbiBpbnNpZGUgYWxsIHdyYXBwZXIgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgKiBXZSBzZWxlY3QgdGhlIG91dGVybW9zdFxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBvcmlnaW5hbCBpbmRleCBvZiB0aGlzIG5vZGU6XG4gICAgICAgICAgICAgICAgLy8gT3V0ZXIgbW9zdCBkYXRhLW9yaWdpbmFsLWluZGV4IGlzIG9yaWdpbmFsIGluZGV4XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ZXJNb3N0RWxlbWVudCA9IFV0aWwucGFyZW50cyhub2RlLCAnWycgKyBBVFRSX0RBVEFfT1JJR0lOQUxfSU5ERVggKyAnXScpLnJldmVyc2UoKVswXTtcbiAgICAgICAgICAgICAgICAvLyBpZiBlbGVtZW50IGlzIG5vdCB5ZXQgd3JhcHBlZCBpbiBzcGFuLCByZWNhbGN1bGF0ZSBpbmRleCBiYXNlZCBvbiBwYXJlbnQgY29udGFpbmVyOlxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZG8gdGhpcyBiZWNhdXNlIHRleHQgbm9kZSBpbmRleGVzICE9IGVsZW1lbnQgaW5kZXhlcy4uLlxuICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGlmICghb3V0ZXJNb3N0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSW5kZXggPSBVdGlsLmNhbGNJbmRleChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvdXRlck1vc3RFbGVtZW50ID8gcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAgIG91dGVyTW9zdEVsZW1lbnQuZ2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9JTkRFWCkpIDogY2FsY3VsYXRlZEluZGV4O1xuICAgICAgICAgICAgICAgIG5hbWUgPSBTRVJJQUxJWkVfU0VQQVJBVE9SICsgaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgaWYgKFV0aWwuaXNNYXJrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmKHBhcmVudCAhPT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdCBvbmx5IHNpYmxpbmdzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHNlbGVjdGlvbiBhbmQgYXJlIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgIC8vIChiZWNhdXNlIHdlIHVzZSBudGgtb2YtdHlwZSBzZWxlY3RvciBsYXRlcilcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdzID0gVXRpbC5ub2RlTGlzdEZpbHRlcihwYXJlbnQuY2hpbGRyZW4sIGZpbHRlclNpYmxpbmdzKSxcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBVdGlsLmluZGV4KG5vZGUsIHNpYmxpbmdzKTtcblxuICAgICAgICAgICAgaWYgKHNpYmxpbmdzLmxlbmd0aCA+IDEgJiYgbm9kZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9ICc6bnRoLW9mLXR5cGUoJyArIChub2RlSW5kZXggKyAxKSArICcpJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0aCA9IG5hbWUgKyAocGF0aCA/ICc+JyArIHBhdGggOiAnJyk7XG5cblxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZShcIiNkb2N1bWVudD5cIiwgXCJcIikucmVwbGFjZSgnPjsnLCAnOycpO1xuICAgIH1cblxufVxuIl19\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** marklib.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9a09ec5721cb60586071\n **/","'use strict';\n\nvar _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];\n\nObject.defineProperty(exports, '__esModule', {\n    value: true\n});\n\nvar _Rendering = require('Rendering');\n\nvar _Rendering2 = _interopRequireDefault(_Rendering);\n\nvar _utilUtil = require('util/Util');\n\nvar _utilUtil2 = _interopRequireDefault(_utilUtil);\n\nexports['default'] = {\n    Rendering: _Rendering2['default'],\n    Util: _utilUtil2['default']\n};\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL3NyYy9tYWluL21vZHVsZXMvTWFya2xpYi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLENBQUM7Ozs7Ozs7O3lCQUVTLFdBQVc7Ozs7d0JBQ2hCLFdBQVc7Ozs7cUJBRWI7QUFDWCxhQUFTLHdCQUFXO0FBQ3BCLFFBQUksdUJBQU07Q0FDYiIsImZpbGUiOiIvVXNlcnMvYm93bGluZ3gvUHJvamVrdGUvbWFya2xpYi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvYm93bGluZ3gvUHJvamVrdGUvbWFya2xpYi9zcmMvbWFpbi9tb2R1bGVzL01hcmtsaWIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBSZW5kZXJpbmcgZnJvbSAnUmVuZGVyaW5nJztcbmltcG9ydCBVdGlsIGZyb20gJ3V0aWwvVXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBSZW5kZXJpbmc6IFJlbmRlcmluZyxcbiAgICBVdGlsOiBVdGlsXG59O1xuIl19\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main/modules/Marklib.js\n ** module id = 1\n ** module chunks = 0 1\n **/","\"use strict\";\n\nexports[\"default\"] = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/interop-require-default.js\n ** module id = 2\n ** module chunks = 0 1\n **/","/* global Node, Document */\n\n'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];\n\nObject.defineProperty(exports, '__esModule', {\n    value: true\n});\n\nvar _utilUtil = require('util/Util');\n\nvar _utilUtil2 = _interopRequireDefault(_utilUtil);\n\n/**\n * @type {string}\n */\nvar TAG_NAME = 'x-marker';\n/**\n * @type {string}\n */\nvar ATTR_DATA_ORIGINAL_OFFSET_START = 'data-original-offset-start';\n/**\n * @type {string}\n */\nvar DATA_ORIGINAL_TEXT_NODE_INDEX = 'original-text-node-index';\n/**\n * @type {string}\n */\nvar ATTR_DATA_START_END = 'data-is-start-end';\n/**\n * @type {string}\n */\nvar ATTR_DATA_IS_HIGHLIGHT_NODE = 'data-is-highlight-node';\n/**\n * @type {string}\n */\nvar ATTR_DATA_ID = 'data-selection-id';\n\n/**\n * @see https://developer.mozilla.org/de/docs/Web/API/Node/compareDocumentPosition\n * @type {number}\n */\nvar DOCUMENT_POSITION_CONTAINED_BY = 16;\n\nvar Rendering = (function () {\n    function Rendering(document, cssClass, context) {\n        _classCallCheck(this, Rendering);\n\n        if (!(document instanceof Document)) {\n            throw 'Marklib {0} is required to be a document instance';\n        }\n        /**\n         * @type {Document}\n         */\n        this.document = document;\n\n        /**\n         * ID of rendering, will be set on each element that is part of it\n         * @type {String}\n         */\n        this.id = _utilUtil2['default'].guid();\n\n        /**\n         * Class that is set on all highlight nodes\n         * @type {String}\n         */\n        this.cssClass = undefined === cssClass ? 'marking' : cssClass;\n\n        /**\n         * StartContainer\n         * @type {Node}\n         */\n        this.startContainer = null;\n\n        /**\n         * EndContainer\n         * @type {Node}\n         */\n        this.endContainer = null;\n\n        /**\n         * Prefix before ID\n         * @type {string}\n         */\n        this.markerPrefix = 'marker-start-';\n\n        /**\n         * Suffix before ID\n         * @type {string}\n         */\n        this.markerSuffix = 'marker-end-';\n\n        /**\n         * @type {Node}\n         */\n        this.context = context || this.document;\n\n        /**\n         * @type {Function}\n         * @private\n         */\n        this._onWrappedNodeFunc = null;\n    }\n\n    _createClass(Rendering, [{\n        key: 'getId',\n\n        /**\n         * @returns {string} id of this rendering\n         */\n        value: function getId() {\n            return this.id;\n        }\n    }, {\n        key: 'setId',\n\n        /**\n         * @param {string} id\n         * @returns {Rendering}\n         */\n        value: function setId(id) {\n            this.id = id;\n            return this;\n        }\n    }, {\n        key: 'onWrappedNode',\n\n        /**\n         * Listener that is called when a node is wrapped on this instance\n         * @param {Function} f\n         * @returns {Rendering}\n         */\n        value: function onWrappedNode(f) {\n            this._onWrappedNodeFunc = f;\n            return this;\n        }\n    }, {\n        key: '_callOnWrappedNode',\n\n        /**\n         * @private\n         */\n        value: function _callOnWrappedNode() {\n            if (typeof this._onWrappedNodeFunc === 'function') {\n                this._onWrappedNodeFunc.apply(this, arguments);\n            }\n        }\n    }, {\n        key: '_createWrapTemplate',\n\n        /**\n         * Creates a Template used as a wrapper\n         * @returns {Node}\n         * @private\n         */\n        value: function _createWrapTemplate() {\n            var el = this.document.createElement(TAG_NAME),\n                vTrue = 'true';\n            el.className = this.cssClass;\n            el.setAttribute(_utilUtil.DATA_IS_SELECTION, vTrue);\n            el.setAttribute(ATTR_DATA_ID, this.getId());\n            el.setAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE, vTrue);\n\n            return el;\n        }\n    }, {\n        key: '_createStartEndWrapTemplate',\n\n        /**\n         * Creates a Template to use as start and end marks\n         * @param {String} text\n         * @returns {Node}\n         * @private\n         */\n        value: function _createStartEndWrapTemplate(text) {\n            var el = this._createWrapTemplate(),\n                vTrue = 'true';\n            el.setAttribute(ATTR_DATA_START_END, vTrue);\n            el.textContent = text;\n            return el;\n        }\n    }, {\n        key: '_createStartOrEndContainer',\n\n        /**\n         * Creates Start or End Container Element\n         * @param initialNode\n         * @param prefix\n         * @param text\n         * @param offset\n         * @param index\n         * @returns {Node}\n         */\n        value: function _createStartOrEndContainer(initialNode, prefix, text, offset, index) {\n            var wrapper = this._createStartEndWrapTemplate(text);\n            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(initialNode, index));\n            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n            wrapper.marklibInstance = this;\n            return wrapper;\n        }\n    }, {\n        key: '_createWrap',\n\n        /**\n         * Wraps given element\n         * @param {Node} el\n         * @param [optionalLength]\n         * @param [optionalIndex]\n         * @param [optionalIsSameNode]\n         * @returns {Node}\n         * @private\n         */\n        value: function _createWrap(el, optionalLength, optionalIndex, optionalIsSameNode) {\n            var originalIndex = optionalIndex >= 0 ? optionalIndex : _utilUtil2['default'].calcIndex(el);\n            var wrapper = this._createWrapTemplate();\n            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(el, originalIndex));\n            var offsetLength = optionalLength >= 0 ? optionalLength : Rendering._getOffsetParentIfHas(el);\n            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offsetLength);\n\n            // Save a reference to original text node in wrapper\n            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, originalIndex);\n\n            // save this marker instance to given node\n            wrapper.marklibInstance = this;\n\n            if (optionalIsSameNode) {\n                wrapper.setAttribute(ATTR_DATA_START_END, ATTR_DATA_START_END);\n            }\n            var wrap = _utilUtil2['default'].wrap(el, wrapper);\n            this._callOnWrappedNode(el, wrap);\n            return wrap;\n        }\n    }, {\n        key: '_createSplitContainer',\n\n        /**\n         * Create split container element\n         * @param originalElement {Node} original text node element that is created a wrapper for\n         * @param index\n         * @param offset\n         * @returns {*|jQuery|Node}\n         */\n        value: function _createSplitContainer(originalElement, index, offset) {\n            var wrapper = this.document.createElement(TAG_NAME),\n                vTrue = 'true';\n            wrapper.setAttribute(_utilUtil.DATA_IS_SELECTION, vTrue);\n            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(originalElement, index));\n            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n            return wrapper;\n        }\n    }, {\n        key: '_walkTextNodes',\n\n        /**\n         * Extracts all TextNodes inside a container\n         * @param {Node} el\n         * @returns {Array.<Text>}\n         */\n        value: function _walkTextNodes(el, func) {\n            this.walkDom(el, function (node) {\n                if (Node.TEXT_NODE === node.nodeType && !_utilUtil2['default'].nodeIsEmpty(node)) {\n                    func(node);\n                }\n                return true;\n            });\n        }\n    }, {\n        key: 'walk',\n\n        /**\n         * Walks the tree\n         * @param start\n         * @param endContainer\n         * @param nextParent\n         */\n        value: function walk(start, endContainer, nextParent) {\n            var nextParentNode = start;\n            while (nextParentNode && nextParentNode !== nextParent.parentNode) {\n                var currentParentNode = nextParentNode;\n                nextParentNode = nextParentNode.parentNode;\n                if (this.wrapSiblings(currentParentNode.nextSibling, endContainer)) {\n                    break;\n                }\n            }\n        }\n    }, {\n        key: 'wrapSiblings',\n\n        /**\n         * Will Wrap all textNode siblings of a container (start) inside a defined Element (like a span)\n         * If an Element node is found, it will wrap all children of this node inside a element as well.\n         * It will stop if endContainer is found as a node\n         *\n         * @param {Node} start\n         * @param {Node} endContainer\n         * @returns {boolean} (true if endContainer was found)\n         */\n        value: function wrapSiblings(start, endContainer) {\n            var _this = this;\n\n            var next = start,\n                found = false;\n\n            // Capsule some logic\n            var wrap = (function (n) {\n                if (n.parentNode.hasAttribute(ATTR_DATA_START_END) && n.parentNode.hasAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE) && n.parentNode.getAttribute(ATTR_DATA_ID) === _this.getId()) {\n                    var thisNode = _this._createWrap(n).parentNode;\n                    thisNode.classList.remove(_this.cssClass);\n                    thisNode.removeAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE);\n                } else {\n                    _this._createWrap(n);\n                }\n            }).bind(this);\n\n            // helper functions\n\n            var wrapIf = function wrapIf(n) {\n                if (!_utilUtil2['default'].nodeIsEmpty(n)) {\n                    wrap(n);\n                }\n            };\n\n            var walkIfContained = function walkIfContained(e) {\n                if (e === endContainer) {\n                    return false;\n                }\n                if (Node.TEXT_NODE === e.nodeType) {\n                    wrapIf(e);\n                }\n                return true;\n            };\n\n            var walkIfNotContained = function walkIfNotContained(el) {\n                wrapIf(el);\n            };\n\n            while (next !== null && next !== endContainer) {\n                var currentNext = next;\n                next = next.nextSibling;\n                // Found a text node, directly wrap inside a span\n                if (Node.TEXT_NODE === currentNext.nodeType) {\n                    wrapIf(currentNext);\n                } else {\n                    if (currentNext.compareDocumentPosition(endContainer) & DOCUMENT_POSITION_CONTAINED_BY) {\n                        this.walkDom(currentNext, walkIfContained);\n                        found = true;\n                    } else {\n                        this._walkTextNodes(currentNext, walkIfNotContained);\n                    }\n                    if (found) {\n                        return true;\n                    }\n                }\n            }\n            return found;\n        }\n    }, {\n        key: 'walkDom',\n\n        /**\n         * Recursively walks the dom tree unless func returns false\n         * This is a lot more efficient then using any jQuery operations\n         *\n         * Applies node to function\n         * @param node\n         * @param func\n         * @returns {*}\n         */\n        value: function walkDom(node, func) {\n            if (!node) {\n                return false;\n            }\n            var children = node.childNodes;\n            if (!children) {\n                return false;\n            }\n            for (var i = 0; i < children.length; i++) {\n                if (!this.walkDom(children[i], func)) {\n                    return false;\n                }\n            }\n            return func(node);\n        }\n    }, {\n        key: '_markTextSameNode',\n\n        /**\n         * Marks text of the same node\n         * @param {Node} textNode\n         * @param {int} startIndex\n         * @param {int} endIndex\n         * @private\n         */\n        value: function _markTextSameNode(textNode, startIndex, endIndex) {\n\n            var initialText = textNode.nodeValue,\n                initialIndex = _utilUtil2['default'].calcIndex(textNode);\n\n            if (!initialText) {\n                return false;\n            }\n\n            //If there is an unmarked part in the beginning of the text node,\n            //cut off that part and put it into it's own textnode.\n            if (startIndex > 0) {\n                var textBefore = initialText.slice(0, startIndex);\n                textNode.parentNode.insertBefore(this.document.createTextNode(textBefore), textNode);\n                // wrap cutted text node:\n                _utilUtil2['default'].wrap(textNode.previousSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode)));\n            }\n            //If there is an unmarked part at the end of the text node,\n            //cut off that part and put it into it's own textnode.\n            if (endIndex < initialText.length) {\n                var textAfter = initialText.slice(endIndex, initialText.length);\n                textNode.parentNode.insertBefore(this.document.createTextNode(textAfter), textNode.nextSibling);\n                _utilUtil2['default'].wrap(textNode.nextSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode) + endIndex));\n            }\n\n            //Cutoff the unmarked parts and wrap the textnode into a span.\n            textNode.nodeValue = initialText.slice(startIndex, endIndex);\n            this.startContainer = this._createWrap(textNode, Rendering._getOffsetParentIfHas(textNode) + startIndex, initialIndex, true).parentNode;\n            this.endContainer = this.startContainer;\n            return this.startContainer;\n        }\n    }, {\n        key: '_markTextDifferentNode',\n\n        /**\n         * Marks text of end and start containers if start and end nodes are different\n         * Important: There might be no end container!\n         *\n         * @param {Node} startContainer\n         * @param {Node} endContainer\n         * @param {int} startOffset\n         * @param {int} endOffset\n         * @returns {{startT: (Node), endT: (Node)}}\n         * @private\n         */\n        value: function _markTextDifferentNode(startContainer, endContainer, startOffset, endOffset) {\n            // Get current for both start and end:\n            var startContainerIndex = _utilUtil2['default'].calcIndex(startContainer);\n            var endContainerIndex = _utilUtil2['default'].calcIndex(endContainer);\n\n            // Split text\n            var fullTextStartValue = startContainer.nodeValue;\n            // init with startContainer because we may have not a text node here\n            var startT = startContainer;\n\n            if (undefined !== fullTextStartValue) {\n                var partTextStartValue = fullTextStartValue.slice(startOffset, fullTextStartValue.length);\n                // Set new text to start node\n                startContainer.nodeValue = fullTextStartValue.slice(0, startOffset);\n\n                var offsetStart = Rendering._getOffsetParentIfHas(startContainer);\n                // Create a new node for splitted text, offset is the length of new startContainer.nodeValue:\n                startT = this._createStartOrEndContainer(startContainer, this.markerPrefix, partTextStartValue, offsetStart === startOffset ? offsetStart : offsetStart + startOffset, startContainerIndex);\n                // Append this node after startContainer\n                startContainer.parentNode.insertBefore(startT, startContainer.nextSibling);\n                this.startContainer = startT;\n\n                if (startContainer.nodeValue) {\n                    // Wrap start container in detection node, offset is always 0 or parent offset.\n                    _utilUtil2['default'].wrap(startContainer, this._createSplitContainer(startContainer, startContainerIndex, Rendering._getOffsetParentIfHas(startContainer)));\n                }\n            }\n\n            // init with endContainer because we may have not a text node here\n            var endT = endContainer;\n\n            // 2. Extract end Text node,\n            var fullTextEndValue = endContainer.nodeValue;\n            // It's possible that end container value is null (if a whole paragraph is marked)\n            if (undefined !== fullTextEndValue) {\n                // Split text\n                var partTextEndValue = fullTextEndValue.slice(0, endOffset);\n                endContainer.nodeValue = fullTextEndValue.slice(endOffset, fullTextEndValue.length);\n                // End Container start offset is always 0 or parent offset.\n                endT = this._createStartOrEndContainer(endContainer, this.markerSuffix, partTextEndValue, Rendering._getOffsetParentIfHas(endContainer), endContainerIndex);\n\n                endContainer.parentNode.insertBefore(endT, endContainer);\n                this.endContainer = endT;\n                var offsetParent = Rendering._getOffsetParentIfHas(endContainer);\n                _utilUtil2['default'].wrap(endContainer, this._createSplitContainer(endContainer, endContainerIndex, offsetParent === endOffset ? offsetParent : offsetParent + endOffset));\n            }\n\n            return { startT: startT, endT: endT };\n        }\n    }, {\n        key: '_findOriginalOffset',\n\n        /**\n         * Will return the original first offset\n         * @param element\n         * @returns {int}\n         * @private\n         */\n        value: function _findOriginalOffset(element) {\n            if (!element.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n                return 0;\n            }\n            var lengthElement = _utilUtil2['default'].parent(element, '[' + ATTR_DATA_ORIGINAL_OFFSET_START + ']');\n            return lengthElement ? parseInt(lengthElement.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : 0;\n        }\n    }, {\n        key: '_renderWithElements',\n\n        /**\n         * Renders a selection\n         * @param {Node} startContainer\n         * @param {Node} endContainer\n         * @param {Node} commonAncestor\n         * @param {int} startOffset\n         * @param {int} endOffset\n         * @param {boolean} [withoutResult] if true result will not be calculated\n         * @returns {{startOffset: (int), endOffset: (int)}} the original offsets found\n         * @private\n         */\n        value: function _renderWithElements(startContainer, endContainer, commonAncestor, startOffset, endOffset, withoutResult) {\n            var outer = _utilUtil2['default'].parents(startContainer, commonAncestor);\n            outer = outer[outer.length - 1];\n            var contextContainer = outer ? outer : commonAncestor;\n\n            // Same Element, means the selection is fully contained in a discrete area, start and endpoint have the same parent\n            // but are different nodes:\n\n            // Start and End offset have to be recalculated because dom might be already changed by highlighting in given node\n            // 1: First detect real start offset in startContainer:\n\n            // That works by selecting the highest wrapper and get original-offset-start data element, see \"findOriginalOffset\"\n            // So first select that container:\n            var originalStartOffset = this._findOriginalOffset(startContainer);\n            var originalEndOffset = this._findOriginalOffset(endContainer);\n\n            // We may run into Browser Bugs:\n\n            // If both are not text nodes, use next sibling as endContainer\n            if (startContainer.nodeType !== Node.TEXT_NODE && endContainer.nodeType !== Node.TEXT_NODE) {\n                if (startContainer === endContainer) {\n                    endContainer = endContainer.nextElementSibling || endContainer;\n                }\n            }\n            // IF start/end container is not type of text, select first child text node:\n            // We run in some bugs with firefox here that selects no text-nodes sometimes, trying to fix this here\n            // Sometimes does not work correctly... (specially when DOM was modified)\n            if (startContainer.nodeType !== Node.TEXT_NODE) {\n                this.walkDom(startContainer, function (el) {\n                    if (el.nodeType === Node.TEXT_NODE) {\n                        startContainer = el;\n                        return false;\n                    }\n                    return true;\n                });\n            }\n\n            if (endContainer.nodeType !== Node.TEXT_NODE) {\n                // Get the last text node:\n                var endContainerContents = _utilUtil2['default'].closest(startContainer, ':not([' + _utilUtil.DATA_IS_SELECTION + '])').childNodes;\n                if (endContainerContents.length) {\n                    var r = endContainerContents[endContainerContents.length - 1];\n                    if (r.nodeType === Node.TEXT_NODE) {\n                        endContainer = r;\n                        endOffset = r.length;\n                    } else {\n                        var f = r.lastChild;\n                        while (f !== null) {\n                            if (f && f.nodeType === Node.TEXT_NODE) {\n                                endContainer = f;\n                                endOffset = f.length;\n                                if (f.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n                                    endOffset = parseInt(f.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) + endOffset;\n                                }\n                            }\n                            f = f.lastChild;\n                        }\n                    }\n                }\n                // still no textNode?\n                if (endContainer.nodeType !== Node.TEXT_NODE) {\n                    throw 'Could not found endContainer, highlighting would be unstable';\n                }\n            }\n\n            var result = withoutResult || {\n                // Real offset is calculated by relative length and absolute length\n                startOffset: originalStartOffset + startOffset,\n                endOffset: originalEndOffset + endOffset,\n                // get the path for this selection\n                startContainerPath: _utilUtil2['default'].getPath(startContainer, this.context),\n                endContainerPath: _utilUtil2['default'].getPath(endContainer, this.context)\n            };\n\n            this._renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer);\n\n            return result;\n        }\n    }, {\n        key: '_renderSelection',\n\n        /**\n         * Renders a given selection\n         *\n         * @param {Node} startContainer\n         * @param {Node} endContainer\n         * @param {int} startOffset\n         * @param {int} endOffset\n         * @param {Node} contextContainer\n         * @param {Node} outer\n         * @private\n         */\n        value: function _renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer) {\n\n            // if start and end-container are the same, mark text on the same node\n            if (startContainer === endContainer) {\n                this._markTextSameNode(startContainer, startOffset, endOffset);\n            } else {\n                var result = this._markTextDifferentNode(startContainer, endContainer, startOffset, endOffset);\n                if (!outer) {\n                    this.wrapSiblings(result.startT.nextSibling, endContainer);\n                } else {\n                    this.walk(result.startT, endContainer, contextContainer);\n                }\n            }\n        }\n    }, {\n        key: '_deserializePath',\n\n        /**\n         * Deserialize a specific path and finds the right textNodes\n         * This even works when DOM has been manipulated before by `marklib`\n         * @param {string} path the serialized path (including offsets)\n         * @return {Node}\n         * @private\n         */\n        value: function _deserializePath(path) {\n            var pSplit = path.split(';'),\n                p = pSplit[0],\n                objectIndex = parseInt(pSplit[1]),\n                charOffset = parseInt(pSplit[2]),\n                container = !p.trim() ? this.context : this.context.querySelector(p);\n            var maybeFoundNode = null;\n            this.walkDom(container, function (n) {\n                if (n.nodeType === Node.TEXT_NODE) {\n                    var atrOffsetStart = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START);\n                    atrOffsetStart = atrOffsetStart === null ? 0 : atrOffsetStart;\n                    var atrIndex = n.parentNode.getAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX);\n                    atrIndex = atrIndex === null ? _utilUtil2['default'].calcIndex(n) : atrIndex;\n                    if (parseInt(atrIndex) === objectIndex && charOffset >= atrOffsetStart && parseInt(atrOffsetStart) + n.length >= charOffset) {\n                        var thisOffset = n.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START) ? charOffset - parseInt(n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : charOffset;\n                        maybeFoundNode = { node: n, offset: thisOffset };\n                        return false;\n                    }\n                } else {\n                    return true;\n                }\n                return true;\n            });\n\n            return maybeFoundNode;\n        }\n    }, {\n        key: 'renderWithPath',\n\n        /**\n         * Prepares to render a Selection with path selectors\n         * ```\n         * A Path looks like this:\n         *\n         * #selector;#textnode;#offset\n         * ``\n         * @param {string} startPath\n         * @param {string} endPath\n         * @returns {string}\n         */\n        value: function renderWithPath(startPath, endPath) {\n            var startContainer = this._deserializePath(startPath);\n            var endContainer = this._deserializePath(endPath);\n            if (startContainer && endContainer && startContainer.node && endContainer.node) {\n                var range = document.createRange();\n                range.setStart(startContainer.node, startContainer.offset);\n                range.setEnd(endContainer.node, endContainer.offset);\n                var text = range.toString();\n                this.renderWithRange(range, true);\n                return text;\n            }\n            throw 'Could not find start- and/or end-container in document';\n        }\n    }, {\n        key: 'renderWithResult',\n\n        /**\n         * Renders a result (that returned from `renderWithRange`)\n         * @param result\n         * @returns {string}\n         */\n        value: function renderWithResult(result) {\n            return this.renderWithPath(result.startContainerPath + ';' + result.startOffset, result.endContainerPath + ';' + result.endOffset);\n        }\n    }, {\n        key: 'renderWithRange',\n\n        /**\n         * Prepares a selection with a range object\n         * @param {Range} range\n         * @param {boolean} [withoutResult] optional do calculate a result, the selection would not be serializable\n         * @returns {Object}\n         */\n        value: function renderWithRange(range, withoutResult) {\n            return this._renderWithElements(range.startContainer, range.endContainer, range.commonAncestorContainer, range.startOffset, range.endOffset, withoutResult);\n        }\n    }], [{\n        key: '_getIndexParentIfHas',\n\n        /**\n         * @param {Node} container\n         * @param {Number} thisIndex\n         * @returns {int} index of parent or original\n         * @private\n         */\n        value: function _getIndexParentIfHas(container, thisIndex) {\n            var p = container.parentNode;\n            var index = parseInt(p.getAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX));\n            return index > thisIndex ? index : thisIndex;\n        }\n    }, {\n        key: '_getOffsetParentIfHas',\n\n        /**\n         * @param container\n         * @returns {int} offset start of parent if has, else 0\n         */\n        value: function _getOffsetParentIfHas(container) {\n            var p = container.parentNode;\n            var offset = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START));\n            return offset > 0 ? offset : 0;\n        }\n    }]);\n\n    return Rendering;\n})();\n\nexports['default'] = Rendering;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL3NyYy9tYWluL1JlbmRlcmluZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7O3dCQUVJLFdBQVc7Ozs7Ozs7QUFPNUIsSUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDOzs7O0FBSTVCLElBQU0sK0JBQStCLEdBQUcsNEJBQTRCLENBQUM7Ozs7QUFJckUsSUFBTSw2QkFBNkIsR0FBRywwQkFBMEIsQ0FBQzs7OztBQUlqRSxJQUFNLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDOzs7O0FBSWhELElBQU0sMkJBQTJCLEdBQUcsd0JBQXdCLENBQUM7Ozs7QUFJN0QsSUFBTSxZQUFZLEdBQUcsbUJBQW1CLENBQUM7Ozs7OztBQU16QyxJQUFNLDhCQUE4QixHQUFHLEVBQUUsQ0FBQzs7SUFHcEMsU0FBUztBQUVBLGFBRlQsU0FBUyxDQUVDLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFOzhCQUZ2QyxTQUFTOztBQUlQLFlBQUksRUFBRSxRQUFRLFlBQVksUUFBUSxDQUFBLEFBQUMsRUFBRTtBQUNqQyxrQkFBTSxtREFBbUQsQ0FBQztTQUM3RDs7OztBQUlELFlBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDOzs7Ozs7QUFNekIsWUFBSSxDQUFDLEVBQUUsR0FBRyxzQkFBSyxJQUFJLEVBQUUsQ0FBQzs7Ozs7O0FBTXRCLFlBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxLQUFLLFFBQVEsR0FBRyxTQUFTLEdBQUcsUUFBUSxDQUFDOzs7Ozs7QUFNOUQsWUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7Ozs7OztBQU0zQixZQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQzs7Ozs7O0FBTXpCLFlBQUksQ0FBQyxZQUFZLEdBQUcs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QUFHLFNBQVMsQ0FBQyxVQUFVLENBQUM7QUFDN0IsZ0JBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLCtCQUErQixDQUFDLENBQUMsQ0FBQztBQUN2RSxtQkFBTyxNQUFNLEdBQUcsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDbEM7OztXQXBIQyxTQUFTOzs7cUJBQVQsU0FBUyIsImZpbGUiOiIvVXNlcnMvYm93bGluZ3gvUHJvamVrdGUvbWFya2xpYi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvYm93bGluZ3gvUHJvamVrdGUvbWFya2xpYi9zcmMvbWFpbi9SZW5kZXJpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgTm9kZSwgRG9jdW1lbnQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXRpbCBmcm9tICd1dGlsL1V0aWwnO1xuXG5pbXBvcnQge0FUVFJfREFUQV9PUklHSU5BTF9JTkRFWCwgREFUQV9JU19TRUxFQ1RJT059IGZyb20gJ3V0aWwvVXRpbCc7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgVEFHX05BTUUgPSAneC1tYXJrZXInO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJUID0gJ2RhdGEtb3JpZ2luYWwtb2Zmc2V0LXN0YXJ0Jztcbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgREFUQV9PUklHSU5BTF9URVhUX05PREVfSU5ERVggPSAnb3JpZ2luYWwtdGV4dC1ub2RlLWluZGV4Jztcbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgQVRUUl9EQVRBX1NUQVJUX0VORCA9ICdkYXRhLWlzLXN0YXJ0LWVuZCc7XG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IEFUVFJfREFUQV9JU19ISUdITElHSFRfTk9ERSA9ICdkYXRhLWlzLWhpZ2hsaWdodC1ub2RlJztcbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgQVRUUl9EQVRBX0lEID0gJ2RhdGEtc2VsZWN0aW9uLWlkJztcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9Ob2RlL2NvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkgPSAxNjtcblxuZXhwb3J0IGRlZmF1bHRcbmNsYXNzIFJlbmRlcmluZyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgY3NzQ2xhc3MsIGNvbnRleHQpIHtcblxuICAgICAgICBpZiAoIShkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgJ01hcmtsaWIgezB9IGlzIHJlcXVpcmVkIHRvIGJlIGEgZG9jdW1lbnQgaW5zdGFuY2UnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RG9jdW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHJlbmRlcmluZywgd2lsbCBiZSBzZXQgb24gZWFjaCBlbGVtZW50IHRoYXQgaXMgcGFydCBvZiBpdFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IFV0aWwuZ3VpZCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGFzcyB0aGF0IGlzIHNldCBvbiBhbGwgaGlnaGxpZ2h0IG5vZGVzXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNzc0NsYXNzID0gdW5kZWZpbmVkID09PSBjc3NDbGFzcyA/ICdtYXJraW5nJyA6IGNzc0NsYXNzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydENvbnRhaW5lclxuICAgICAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmRDb250YWluZXJcbiAgICAgICAgICogQHR5cGUge05vZGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZENvbnRhaW5lciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZWZpeCBiZWZvcmUgSURcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFya2VyUHJlZml4ID0gJ21hcmtlci1zdGFydC0nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWZmaXggYmVmb3JlIElEXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtlclN1ZmZpeCA9ICdtYXJrZXItZW5kLSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtOb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmRvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbldyYXBwZWROb2RlRnVuYyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gaWQgb2YgdGhpcyByZW5kZXJpbmdcbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge1JlbmRlcmluZ31cbiAgICAgKi9cbiAgICBzZXRJZChpZCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBub2RlIGlzIHdyYXBwZWQgb24gdGhpcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyaW5nfVxuICAgICAqL1xuICAgIG9uV3JhcHBlZE5vZGUoZikge1xuICAgICAgICB0aGlzLl9vbldyYXBwZWROb2RlRnVuYyA9IGY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGxPbldyYXBwZWROb2RlKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uV3JhcHBlZE5vZGVGdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9vbldyYXBwZWROb2RlRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7aW50fSBpbmRleCBvZiBwYXJlbnQgb3Igb3JpZ2luYWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfZ2V0SW5kZXhQYXJlbnRJZkhhcyhjb250YWluZXIsIHRoaXNJbmRleCkge1xuICAgICAgICB2YXIgcCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChwLmdldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfSU5ERVgpKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gdGhpc0luZGV4ID8gaW5kZXggOiB0aGlzSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtpbnR9IG9mZnNldCBzdGFydCBvZiBwYXJlbnQgaWYgaGFzLCBlbHNlIDBcbiAgICAgKi9cbiAgICBzdGF0aWMgX2dldE9mZnNldFBhcmVudElmSGFzKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgcCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocC5nZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCkpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID4gMCA/IG9mZnNldCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRlbXBsYXRlIHVzZWQgYXMgYSB3cmFwcGVyXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlV3JhcFRlbXBsYXRlKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoVEFHX05BTUUpLCB2VHJ1ZSA9IFwidHJ1ZVwiO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSB0aGlzLmNzc0NsYXNzO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoREFUQV9JU19TRUxFQ1RJT04sIHZUcnVlKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9JRCwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9JU19ISUdITElHSFRfTk9ERSwgdlRydWUpO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVGVtcGxhdGUgdG8gdXNlIGFzIHN0YXJ0IGFuZCBlbmQgbWFya3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVN0YXJ0RW5kV3JhcFRlbXBsYXRlKHRleHQpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5fY3JlYXRlV3JhcFRlbXBsYXRlKCksIHZUcnVlID0gXCJ0cnVlXCI7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShBVFRSX0RBVEFfU1RBUlRfRU5ELCB2VHJ1ZSk7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBTdGFydCBvciBFbmQgQ29udGFpbmVyIEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE5vZGVcbiAgICAgKiBAcGFyYW0gcHJlZml4XG4gICAgICogQHBhcmFtIHRleHRcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICovXG4gICAgX2NyZWF0ZVN0YXJ0T3JFbmRDb250YWluZXIoaW5pdGlhbE5vZGUsIHByZWZpeCwgdGV4dCwgb2Zmc2V0LCBpbmRleCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5fY3JlYXRlU3RhcnRFbmRXcmFwVGVtcGxhdGUodGV4dCk7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9JTkRFWCwgUmVuZGVyaW5nLl9nZXRJbmRleFBhcmVudElmSGFzKGluaXRpYWxOb2RlLCBpbmRleCkpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJULCBvZmZzZXQpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShEQVRBX09SSUdJTkFMX1RFWFRfTk9ERV9JTkRFWCwgaW5kZXgpO1xuICAgICAgICB3cmFwcGVyLm1hcmtsaWJJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIFtvcHRpb25hbExlbmd0aF1cbiAgICAgKiBAcGFyYW0gW29wdGlvbmFsSW5kZXhdXG4gICAgICogQHBhcmFtIFtvcHRpb25hbElzU2FtZU5vZGVdXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlV3JhcChlbCwgb3B0aW9uYWxMZW5ndGgsIG9wdGlvbmFsSW5kZXgsIG9wdGlvbmFsSXNTYW1lTm9kZSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGV4ID0gb3B0aW9uYWxJbmRleCA+PSAwID8gb3B0aW9uYWxJbmRleCA6IFV0aWwuY2FsY0luZGV4KGVsKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuX2NyZWF0ZVdyYXBUZW1wbGF0ZSgpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfSU5ERVgsIFJlbmRlcmluZy5fZ2V0SW5kZXhQYXJlbnRJZkhhcyhlbCwgb3JpZ2luYWxJbmRleCkpO1xuICAgICAgICBjb25zdCBvZmZzZXRMZW5ndGggPSBvcHRpb25hbExlbmd0aCA+PSAwID8gb3B0aW9uYWxMZW5ndGggOiBSZW5kZXJpbmcuX2dldE9mZnNldFBhcmVudElmSGFzKGVsKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCwgb2Zmc2V0TGVuZ3RoKTtcblxuICAgICAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIHRleHQgbm9kZSBpbiB3cmFwcGVyXG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKERBVEFfT1JJR0lOQUxfVEVYVF9OT0RFX0lOREVYLCBvcmlnaW5hbEluZGV4KTtcblxuICAgICAgICAvLyBzYXZlIHRoaXMgbWFya2VyIGluc3RhbmNlIHRvIGdpdmVuIG5vZGVcbiAgICAgICAgd3JhcHBlci5tYXJrbGliSW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvcHRpb25hbElzU2FtZU5vZGUpIHtcbiAgICAgICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9TVEFSVF9FTkQsIEFUVFJfREFUQV9TVEFSVF9FTkQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXAgPSBVdGlsLndyYXAoZWwsIHdyYXBwZXIpO1xuICAgICAgICB0aGlzLl9jYWxsT25XcmFwcGVkTm9kZShlbCwgd3JhcCk7XG4gICAgICAgIHJldHVybiB3cmFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzcGxpdCBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEVsZW1lbnQge05vZGV9IG9yaWdpbmFsIHRleHQgbm9kZSBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZCBhIHdyYXBwZXIgZm9yXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeXxOb2RlfVxuICAgICAqL1xuICAgIF9jcmVhdGVTcGxpdENvbnRhaW5lcihvcmlnaW5hbEVsZW1lbnQsIGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChUQUdfTkFNRSksIHZUcnVlID0gXCJ0cnVlXCI7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKERBVEFfSVNfU0VMRUNUSU9OLCB2VHJ1ZSk7XG4gICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9JTkRFWCwgUmVuZGVyaW5nLl9nZXRJbmRleFBhcmVudElmSGFzKG9yaWdpbmFsRWxlbWVudCwgaW5kZXgpKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCwgb2Zmc2V0KTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoREFUQV9PUklHSU5BTF9URVhUX05PREVfSU5ERVgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgYWxsIFRleHROb2RlcyBpbnNpZGUgYSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge0FycmF5LjxUZXh0Pn1cbiAgICAgKi9cbiAgICBfd2Fsa1RleHROb2RlcyhlbCwgZnVuYykge1xuICAgICAgICB0aGlzLndhbGtEb20oZWwsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoTm9kZS5URVhUX05PREUgPT09IG5vZGUubm9kZVR5cGUgJiYgIVV0aWwubm9kZUlzRW1wdHkobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBmdW5jKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhbGtzIHRoZSB0cmVlXG4gICAgICogQHBhcmFtIHN0YXJ0XG4gICAgICogQHBhcmFtIGVuZENvbnRhaW5lclxuICAgICAqIEBwYXJhbSBuZXh0UGFyZW50XG4gICAgICovXG4gICAgd2FsayhzdGFydCwgZW5kQ29udGFpbmVyLCBuZXh0UGFyZW50KSB7XG4gICAgICAgIGxldCBuZXh0UGFyZW50Tm9kZSA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSAobmV4dFBhcmVudE5vZGUgJiYgbmV4dFBhcmVudE5vZGUgIT09IG5leHRQYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnROb2RlID0gbmV4dFBhcmVudE5vZGU7XG4gICAgICAgICAgICBuZXh0UGFyZW50Tm9kZSA9IG5leHRQYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy53cmFwU2libGluZ3MoY3VycmVudFBhcmVudE5vZGUubmV4dFNpYmxpbmcsIGVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2lsbCBXcmFwIGFsbCB0ZXh0Tm9kZSBzaWJsaW5ncyBvZiBhIGNvbnRhaW5lciAoc3RhcnQpIGluc2lkZSBhIGRlZmluZWQgRWxlbWVudCAobGlrZSBhIHNwYW4pXG4gICAgICogSWYgYW4gRWxlbWVudCBub2RlIGlzIGZvdW5kLCBpdCB3aWxsIHdyYXAgYWxsIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSBpbnNpZGUgYSBlbGVtZW50IGFzIHdlbGwuXG4gICAgICogSXQgd2lsbCBzdG9wIGlmIGVuZENvbnRhaW5lciBpcyBmb3VuZCBhcyBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVuZENvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAodHJ1ZSBpZiBlbmRDb250YWluZXIgd2FzIGZvdW5kKVxuICAgICAqL1xuICAgIHdyYXBTaWJsaW5ncyhzdGFydCwgZW5kQ29udGFpbmVyKSB7XG4gICAgICAgIGxldCBuZXh0ID0gc3RhcnQsXG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENhcHN1bGUgc29tZSBsb2dpY1xuICAgICAgICBjb25zdCB3cmFwID0gKChuKSA9PiB7XG4gICAgICAgICAgICBpZiAobi5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShBVFRSX0RBVEFfU1RBUlRfRU5EKSAmJlxuICAgICAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9EQVRBX0lTX0hJR0hMSUdIVF9OT0RFKSAmJlxuICAgICAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX0lEKSA9PT0gdGhpcy5nZXRJZCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRoaXNOb2RlID0gdGhpcy5fY3JlYXRlV3JhcChuKS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHRoaXNOb2RlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jc3NDbGFzcyk7XG4gICAgICAgICAgICAgICAgdGhpc05vZGUucmVtb3ZlQXR0cmlidXRlKEFUVFJfREFUQV9JU19ISUdITElHSFRfTk9ERSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVdyYXAobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gaGVscGVyIGZ1bmN0aW9uc1xuXG4gICAgICAgIGNvbnN0IHdyYXBJZiA9IChuKSA9PiB7XG4gICAgICAgICAgICBpZiAoIVV0aWwubm9kZUlzRW1wdHkobikpIHtcbiAgICAgICAgICAgICAgICB3cmFwKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHdhbGtJZkNvbnRhaW5lZCA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSA9PT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE5vZGUuVEVYVF9OT0RFID09PSBlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgd3JhcElmKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgd2Fsa0lmTm90Q29udGFpbmVkID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB3cmFwSWYoZWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChuZXh0ICE9PSBudWxsICYmIG5leHQgIT09IGVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgLy8gRm91bmQgYSB0ZXh0IG5vZGUsIGRpcmVjdGx5IHdyYXAgaW5zaWRlIGEgc3BhblxuICAgICAgICAgICAgaWYgKE5vZGUuVEVYVF9OT0RFID09PSBjdXJyZW50TmV4dC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIHdyYXBJZihjdXJyZW50TmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudE5leHQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZW5kQ29udGFpbmVyKSAmIERPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxrRG9tKGN1cnJlbnROZXh0LCB3YWxrSWZDb250YWluZWQpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2Fsa1RleHROb2RlcyhjdXJyZW50TmV4dCwgd2Fsa0lmTm90Q29udGFpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgd2Fsa3MgdGhlIGRvbSB0cmVlIHVubGVzcyBmdW5jIHJldHVybnMgZmFsc2VcbiAgICAgKiBUaGlzIGlzIGEgbG90IG1vcmUgZWZmaWNpZW50IHRoZW4gdXNpbmcgYW55IGpRdWVyeSBvcGVyYXRpb25zXG4gICAgICpcbiAgICAgKiBBcHBsaWVzIG5vZGUgdG8gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgd2Fsa0RvbShub2RlLCBmdW5jKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndhbGtEb20oY2hpbGRyZW5baV0sIGZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRleHQgb2YgdGhlIHNhbWUgbm9kZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGV4dE5vZGVcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRJbmRleFxuICAgICAqIEBwYXJhbSB7aW50fSBlbmRJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21hcmtUZXh0U2FtZU5vZGUodGV4dE5vZGUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG5cbiAgICAgICAgY29uc3QgaW5pdGlhbFRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsSW5kZXggPSBVdGlsLmNhbGNJbmRleCh0ZXh0Tm9kZSk7XG5cbiAgICAgICAgaWYgKCFpbml0aWFsVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiB0aGVyZSBpcyBhbiB1bm1hcmtlZCBwYXJ0IGluIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQgbm9kZSxcbiAgICAgICAgLy9jdXQgb2ZmIHRoYXQgcGFydCBhbmQgcHV0IGl0IGludG8gaXQncyBvd24gdGV4dG5vZGUuXG4gICAgICAgIGlmIChzdGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dEJlZm9yZSA9IGluaXRpYWxUZXh0LnNsaWNlKDAsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgdGV4dE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0QmVmb3JlKSwgdGV4dE5vZGUpO1xuICAgICAgICAgICAgLy8gd3JhcCBjdXR0ZWQgdGV4dCBub2RlOlxuICAgICAgICAgICAgVXRpbC53cmFwKHRleHROb2RlLnByZXZpb3VzU2libGluZywgdGhpcy5fY3JlYXRlU3BsaXRDb250YWluZXIodGV4dE5vZGUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4LCBSZW5kZXJpbmcuX2dldE9mZnNldFBhcmVudElmSGFzKHRleHROb2RlKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vSWYgdGhlcmUgaXMgYW4gdW5tYXJrZWQgcGFydCBhdCB0aGUgZW5kIG9mIHRoZSB0ZXh0IG5vZGUsXG4gICAgICAgIC8vY3V0IG9mZiB0aGF0IHBhcnQgYW5kIHB1dCBpdCBpbnRvIGl0J3Mgb3duIHRleHRub2RlLlxuICAgICAgICBpZiAoZW5kSW5kZXggPCBpbml0aWFsVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRBZnRlciA9IGluaXRpYWxUZXh0LnNsaWNlKGVuZEluZGV4LCBpbml0aWFsVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgdGV4dE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0QWZ0ZXIpLCB0ZXh0Tm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBVdGlsLndyYXAodGV4dE5vZGUubmV4dFNpYmxpbmcsIHRoaXMuX2NyZWF0ZVNwbGl0Q29udGFpbmVyKHRleHROb2RlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCwgUmVuZGVyaW5nLl9nZXRPZmZzZXRQYXJlbnRJZkhhcyh0ZXh0Tm9kZSkgKyBlbmRJbmRleCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9DdXRvZmYgdGhlIHVubWFya2VkIHBhcnRzIGFuZCB3cmFwIHRoZSB0ZXh0bm9kZSBpbnRvIGEgc3Bhbi5cbiAgICAgICAgdGV4dE5vZGUubm9kZVZhbHVlID0gaW5pdGlhbFRleHQuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gdGhpcy5fY3JlYXRlV3JhcCh0ZXh0Tm9kZSxcbiAgICAgICAgICAgIFJlbmRlcmluZy5fZ2V0T2Zmc2V0UGFyZW50SWZIYXModGV4dE5vZGUpICsgc3RhcnRJbmRleCwgaW5pdGlhbEluZGV4LCB0cnVlKS5wYXJlbnROb2RlO1xuICAgICAgICB0aGlzLmVuZENvbnRhaW5lciA9IHRoaXMuc3RhcnRDb250YWluZXI7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0Q29udGFpbmVyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGV4dCBvZiBlbmQgYW5kIHN0YXJ0IGNvbnRhaW5lcnMgaWYgc3RhcnQgYW5kIGVuZCBub2RlcyBhcmUgZGlmZmVyZW50XG4gICAgICogSW1wb3J0YW50OiBUaGVyZSBtaWdodCBiZSBubyBlbmQgY29udGFpbmVyIVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBzdGFydENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0T2Zmc2V0XG4gICAgICogQHBhcmFtIHtpbnR9IGVuZE9mZnNldFxuICAgICAqIEByZXR1cm5zIHt7c3RhcnRUOiAoTm9kZSksIGVuZFQ6IChOb2RlKX19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFya1RleHREaWZmZXJlbnROb2RlKHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgZm9yIGJvdGggc3RhcnQgYW5kIGVuZDpcbiAgICAgICAgY29uc3Qgc3RhcnRDb250YWluZXJJbmRleCA9IFV0aWwuY2FsY0luZGV4KHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgZW5kQ29udGFpbmVySW5kZXggPSBVdGlsLmNhbGNJbmRleChlbmRDb250YWluZXIpO1xuXG4gICAgICAgIC8vIFNwbGl0IHRleHRcbiAgICAgICAgY29uc3QgZnVsbFRleHRTdGFydFZhbHVlID0gc3RhcnRDb250YWluZXIubm9kZVZhbHVlO1xuICAgICAgICAvLyBpbml0IHdpdGggc3RhcnRDb250YWluZXIgYmVjYXVzZSB3ZSBtYXkgaGF2ZSBub3QgYSB0ZXh0IG5vZGUgaGVyZVxuICAgICAgICBsZXQgc3RhcnRUID0gc3RhcnRDb250YWluZXI7XG5cbiAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnVsbFRleHRTdGFydFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcGFydFRleHRTdGFydFZhbHVlID0gZnVsbFRleHRTdGFydFZhbHVlLnNsaWNlKHN0YXJ0T2Zmc2V0LCBmdWxsVGV4dFN0YXJ0VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIFNldCBuZXcgdGV4dCB0byBzdGFydCBub2RlXG4gICAgICAgICAgICBzdGFydENvbnRhaW5lci5ub2RlVmFsdWUgPSBmdWxsVGV4dFN0YXJ0VmFsdWUuc2xpY2UoMCwgc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0U3RhcnQgPSBSZW5kZXJpbmcuX2dldE9mZnNldFBhcmVudElmSGFzKHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBub2RlIGZvciBzcGxpdHRlZCB0ZXh0LCBvZmZzZXQgaXMgdGhlIGxlbmd0aCBvZiBuZXcgc3RhcnRDb250YWluZXIubm9kZVZhbHVlOlxuICAgICAgICAgICAgc3RhcnRUID0gdGhpcy5fY3JlYXRlU3RhcnRPckVuZENvbnRhaW5lcihzdGFydENvbnRhaW5lciwgdGhpcy5tYXJrZXJQcmVmaXgsIHBhcnRUZXh0U3RhcnRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRTdGFydCA9PT0gc3RhcnRPZmZzZXQgPyBvZmZzZXRTdGFydCA6IG9mZnNldFN0YXJ0ICsgc3RhcnRPZmZzZXQsIHN0YXJ0Q29udGFpbmVySW5kZXgpO1xuICAgICAgICAgICAgLy8gQXBwZW5kIHRoaXMgbm9kZSBhZnRlciBzdGFydENvbnRhaW5lclxuICAgICAgICAgICAgc3RhcnRDb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3RhcnRULCBzdGFydENvbnRhaW5lci5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gc3RhcnRUO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCBzdGFydCBjb250YWluZXIgaW4gZGV0ZWN0aW9uIG5vZGUsIG9mZnNldCBpcyBhbHdheXMgMCBvciBwYXJlbnQgb2Zmc2V0LlxuICAgICAgICAgICAgICAgIFV0aWwud3JhcChzdGFydENvbnRhaW5lciwgdGhpcy5fY3JlYXRlU3BsaXRDb250YWluZXIoc3RhcnRDb250YWluZXIsIHN0YXJ0Q29udGFpbmVySW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIFJlbmRlcmluZy5fZ2V0T2Zmc2V0UGFyZW50SWZIYXMoc3RhcnRDb250YWluZXIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0IHdpdGggZW5kQ29udGFpbmVyIGJlY2F1c2Ugd2UgbWF5IGhhdmUgbm90IGEgdGV4dCBub2RlIGhlcmVcbiAgICAgICAgbGV0IGVuZFQgPSBlbmRDb250YWluZXI7XG5cbiAgICAgICAgLy8gMi4gRXh0cmFjdCBlbmQgVGV4dCBub2RlLFxuICAgICAgICBjb25zdCBmdWxsVGV4dEVuZFZhbHVlID0gZW5kQ29udGFpbmVyLm5vZGVWYWx1ZTtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGVuZCBjb250YWluZXIgdmFsdWUgaXMgbnVsbCAoaWYgYSB3aG9sZSBwYXJhZ3JhcGggaXMgbWFya2VkKVxuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdWxsVGV4dEVuZFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBTcGxpdCB0ZXh0XG4gICAgICAgICAgICB2YXIgcGFydFRleHRFbmRWYWx1ZSA9IGZ1bGxUZXh0RW5kVmFsdWUuc2xpY2UoMCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lci5ub2RlVmFsdWUgPSBmdWxsVGV4dEVuZFZhbHVlLnNsaWNlKGVuZE9mZnNldCwgZnVsbFRleHRFbmRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gRW5kIENvbnRhaW5lciBzdGFydCBvZmZzZXQgaXMgYWx3YXlzIDAgb3IgcGFyZW50IG9mZnNldC5cbiAgICAgICAgICAgIGVuZFQgPSB0aGlzLl9jcmVhdGVTdGFydE9yRW5kQ29udGFpbmVyKGVuZENvbnRhaW5lciwgdGhpcy5tYXJrZXJTdWZmaXgsIHBhcnRUZXh0RW5kVmFsdWUsXG4gICAgICAgICAgICAgICAgUmVuZGVyaW5nLl9nZXRPZmZzZXRQYXJlbnRJZkhhcyhlbmRDb250YWluZXIpLCBlbmRDb250YWluZXJJbmRleCk7XG5cbiAgICAgICAgICAgIGVuZENvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbmRULCBlbmRDb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5lbmRDb250YWluZXIgPSBlbmRUO1xuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IFJlbmRlcmluZy5fZ2V0T2Zmc2V0UGFyZW50SWZIYXMoZW5kQ29udGFpbmVyKTtcbiAgICAgICAgICAgIFV0aWwud3JhcChlbmRDb250YWluZXIsIHRoaXMuX2NyZWF0ZVNwbGl0Q29udGFpbmVyKGVuZENvbnRhaW5lciwgZW5kQ29udGFpbmVySW5kZXgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID09PSBlbmRPZmZzZXQgPyBvZmZzZXRQYXJlbnQgOiBvZmZzZXRQYXJlbnQgKyBlbmRPZmZzZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7c3RhcnRUOiBzdGFydFQsIGVuZFQ6IGVuZFR9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCBmaXJzdCBvZmZzZXRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtpbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE9yaWdpbmFsT2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9PRkZTRVRfU1RBUlQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGhFbGVtZW50ID0gVXRpbC5wYXJlbnQoZWxlbWVudCwgJ1snICsgQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCArICddJyk7XG4gICAgICAgIHJldHVybiBsZW5ndGhFbGVtZW50ID8gcGFyc2VJbnQobGVuZ3RoRWxlbWVudC5nZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX09GRlNFVF9TVEFSVCkpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtOb2RlfSBzdGFydENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtOb2RlfSBjb21tb25BbmNlc3RvclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydE9mZnNldFxuICAgICAqIEBwYXJhbSB7aW50fSBlbmRPZmZzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRob3V0UmVzdWx0XSBpZiB0cnVlIHJlc3VsdCB3aWxsIG5vdCBiZSBjYWxjdWxhdGVkXG4gICAgICogQHJldHVybnMge3tzdGFydE9mZnNldDogKGludCksIGVuZE9mZnNldDogKGludCl9fSB0aGUgb3JpZ2luYWwgb2Zmc2V0cyBmb3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlcldpdGhFbGVtZW50cyhzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyLCBjb21tb25BbmNlc3Rvciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgd2l0aG91dFJlc3VsdCkge1xuICAgICAgICBsZXQgb3V0ZXIgPSBVdGlsLnBhcmVudHMoc3RhcnRDb250YWluZXIsIGNvbW1vbkFuY2VzdG9yKTtcbiAgICAgICAgb3V0ZXIgPSBvdXRlcltvdXRlci5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgY29udGV4dENvbnRhaW5lciA9IG91dGVyID8gb3V0ZXIgOiBjb21tb25BbmNlc3RvcjtcblxuICAgICAgICAvLyBTYW1lIEVsZW1lbnQsIG1lYW5zIHRoZSBzZWxlY3Rpb24gaXMgZnVsbHkgY29udGFpbmVkIGluIGEgZGlzY3JldGUgYXJlYSwgc3RhcnQgYW5kIGVuZHBvaW50IGhhdmUgdGhlIHNhbWUgcGFyZW50XG4gICAgICAgIC8vIGJ1dCBhcmUgZGlmZmVyZW50IG5vZGVzOlxuXG4gICAgICAgIC8vIFN0YXJ0IGFuZCBFbmQgb2Zmc2V0IGhhdmUgdG8gYmUgcmVjYWxjdWxhdGVkIGJlY2F1c2UgZG9tIG1pZ2h0IGJlIGFscmVhZHkgY2hhbmdlZCBieSBoaWdobGlnaHRpbmcgaW4gZ2l2ZW4gbm9kZVxuICAgICAgICAvLyAxOiBGaXJzdCBkZXRlY3QgcmVhbCBzdGFydCBvZmZzZXQgaW4gc3RhcnRDb250YWluZXI6XG5cbiAgICAgICAgLy8gVGhhdCB3b3JrcyBieSBzZWxlY3RpbmcgdGhlIGhpZ2hlc3Qgd3JhcHBlciBhbmQgZ2V0IG9yaWdpbmFsLW9mZnNldC1zdGFydCBkYXRhIGVsZW1lbnQsIHNlZSBcImZpbmRPcmlnaW5hbE9mZnNldFwiXG4gICAgICAgIC8vIFNvIGZpcnN0IHNlbGVjdCB0aGF0IGNvbnRhaW5lcjpcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydE9mZnNldCA9IHRoaXMuX2ZpbmRPcmlnaW5hbE9mZnNldChzdGFydENvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRW5kT2Zmc2V0ID0gdGhpcy5fZmluZE9yaWdpbmFsT2Zmc2V0KGVuZENvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gV2UgbWF5IHJ1biBpbnRvIEJyb3dzZXIgQnVnczpcblxuICAgICAgICAvLyBJZiBib3RoIGFyZSBub3QgdGV4dCBub2RlcywgdXNlIG5leHQgc2libGluZyBhcyBlbmRDb250YWluZXJcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJiBlbmRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIgPT09IGVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGVuZENvbnRhaW5lci5uZXh0RWxlbWVudFNpYmxpbmcgfHwgZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElGIHN0YXJ0L2VuZCBjb250YWluZXIgaXMgbm90IHR5cGUgb2YgdGV4dCwgc2VsZWN0IGZpcnN0IGNoaWxkIHRleHQgbm9kZTpcbiAgICAgICAgLy8gV2UgcnVuIGluIHNvbWUgYnVncyB3aXRoIGZpcmVmb3ggaGVyZSB0aGF0IHNlbGVjdHMgbm8gdGV4dC1ub2RlcyBzb21ldGltZXMsIHRyeWluZyB0byBmaXggdGhpcyBoZXJlXG4gICAgICAgIC8vIFNvbWV0aW1lcyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseS4uLiAoc3BlY2lhbGx5IHdoZW4gRE9NIHdhcyBtb2RpZmllZClcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgdGhpcy53YWxrRG9tKHN0YXJ0Q29udGFpbmVyLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZWw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxhc3QgdGV4dCBub2RlOlxuICAgICAgICAgICAgY29uc3QgZW5kQ29udGFpbmVyQ29udGVudHMgPSBVdGlsLmNsb3Nlc3Qoc3RhcnRDb250YWluZXIsICc6bm90KFsnICsgREFUQV9JU19TRUxFQ1RJT04gKyAnXSknKS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgaWYgKGVuZENvbnRhaW5lckNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBlbmRDb250YWluZXJDb250ZW50c1tlbmRDb250YWluZXJDb250ZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gcjtcbiAgICAgICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYgPSByLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmICYmIGYubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBwYXJzZUludChmLnBhcmVudE5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9PRkZTRVRfU1RBUlQpKSArIGVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gZi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGlsbCBubyB0ZXh0Tm9kZT9cbiAgICAgICAgICAgIGlmIChlbmRDb250YWluZXIubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0NvdWxkIG5vdCBmb3VuZCBlbmRDb250YWluZXIsIGhpZ2hsaWdodGluZyB3b3VsZCBiZSB1bnN0YWJsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gd2l0aG91dFJlc3VsdCB8fCB7XG4gICAgICAgICAgICAgICAgLy8gUmVhbCBvZmZzZXQgaXMgY2FsY3VsYXRlZCBieSByZWxhdGl2ZSBsZW5ndGggYW5kIGFic29sdXRlIGxlbmd0aFxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBvcmlnaW5hbFN0YXJ0T2Zmc2V0ICsgc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0OiBvcmlnaW5hbEVuZE9mZnNldCArIGVuZE9mZnNldCxcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBhdGggZm9yIHRoaXMgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgc3RhcnRDb250YWluZXJQYXRoOiBVdGlsLmdldFBhdGgoc3RhcnRDb250YWluZXIsIHRoaXMuY29udGV4dCksXG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyUGF0aDogVXRpbC5nZXRQYXRoKGVuZENvbnRhaW5lciwgdGhpcy5jb250ZXh0KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJTZWxlY3Rpb24oc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgY29udGV4dENvbnRhaW5lciwgb3V0ZXIpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGdpdmVuIHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBzdGFydENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0T2Zmc2V0XG4gICAgICogQHBhcmFtIHtpbnR9IGVuZE9mZnNldFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY29udGV4dENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gb3V0ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZWxlY3Rpb24oc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgY29udGV4dENvbnRhaW5lciwgb3V0ZXIpIHtcblxuICAgICAgICAvLyBpZiBzdGFydCBhbmQgZW5kLWNvbnRhaW5lciBhcmUgdGhlIHNhbWUsIG1hcmsgdGV4dCBvbiB0aGUgc2FtZSBub2RlXG4gICAgICAgIGlmIChzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrVGV4dFNhbWVOb2RlKHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9tYXJrVGV4dERpZmZlcmVudE5vZGUoc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIW91dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwU2libGluZ3MocmVzdWx0LnN0YXJ0VC5uZXh0U2libGluZywgZW5kQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrKHJlc3VsdC5zdGFydFQsIGVuZENvbnRhaW5lciwgY29udGV4dENvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplIGEgc3BlY2lmaWMgcGF0aCBhbmQgZmluZHMgdGhlIHJpZ2h0IHRleHROb2Rlc1xuICAgICAqIFRoaXMgZXZlbiB3b3JrcyB3aGVuIERPTSBoYXMgYmVlbiBtYW5pcHVsYXRlZCBiZWZvcmUgYnkgYG1hcmtsaWJgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHNlcmlhbGl6ZWQgcGF0aCAoaW5jbHVkaW5nIG9mZnNldHMpXG4gICAgICogQHJldHVybiB7Tm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZXNlcmlhbGl6ZVBhdGgocGF0aCkge1xuICAgICAgICBjb25zdCBwU3BsaXQgPSBwYXRoLnNwbGl0KCc7JyksIHAgPSBwU3BsaXRbMF0sXG4gICAgICAgICAgICBvYmplY3RJbmRleCA9IHBhcnNlSW50KHBTcGxpdFsxXSksXG4gICAgICAgICAgICBjaGFyT2Zmc2V0ID0gcGFyc2VJbnQocFNwbGl0WzJdKSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9ICFwLnRyaW0oKSA/IHRoaXMuY29udGV4dCA6IHRoaXMuY29udGV4dC5xdWVyeVNlbGVjdG9yKHApO1xuICAgICAgICBsZXQgbWF5YmVGb3VuZE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLndhbGtEb20oY29udGFpbmVyLCBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0ck9mZnNldFN0YXJ0ID0gbi5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJUKTtcbiAgICAgICAgICAgICAgICBhdHJPZmZzZXRTdGFydCA9IGF0ck9mZnNldFN0YXJ0ID09PSBudWxsID8gMCA6IGF0ck9mZnNldFN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBhdHJJbmRleCA9IG4ucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9EQVRBX09SSUdJTkFMX0lOREVYKTtcbiAgICAgICAgICAgICAgICBhdHJJbmRleCA9IGF0ckluZGV4ID09PSBudWxsID8gVXRpbC5jYWxjSW5kZXgobikgOiBhdHJJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoYXRySW5kZXgpID09PSBvYmplY3RJbmRleCAmJiBjaGFyT2Zmc2V0ID49IGF0ck9mZnNldFN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgICgocGFyc2VJbnQoYXRyT2Zmc2V0U3RhcnQpICsgbi5sZW5ndGgpID49IGNoYXJPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlzT2Zmc2V0ID0gbi5wYXJlbnROb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAuaGFzQXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9PRkZTRVRfU1RBUlQpID8gY2hhck9mZnNldCAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KG4ucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEF0dHJpYnV0ZShBVFRSX0RBVEFfT1JJR0lOQUxfT0ZGU0VUX1NUQVJUKSkgOiBjaGFyT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBtYXliZUZvdW5kTm9kZSA9IHtub2RlOiBuLCBvZmZzZXQ6IHRoaXNPZmZzZXR9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF5YmVGb3VuZE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgdG8gcmVuZGVyIGEgU2VsZWN0aW9uIHdpdGggcGF0aCBzZWxlY3RvcnNcbiAgICAgKiBgYGBcbiAgICAgKiBBIFBhdGggbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogI3NlbGVjdG9yOyN0ZXh0bm9kZTsjb2Zmc2V0XG4gICAgICogYGBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRQYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFBhdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHJlbmRlcldpdGhQYXRoKHN0YXJ0UGF0aCwgZW5kUGF0aCkge1xuICAgICAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IHRoaXMuX2Rlc2VyaWFsaXplUGF0aChzdGFydFBhdGgpO1xuICAgICAgICBjb25zdCBlbmRDb250YWluZXIgPSB0aGlzLl9kZXNlcmlhbGl6ZVBhdGgoZW5kUGF0aCk7XG4gICAgICAgIGlmIChzdGFydENvbnRhaW5lciAmJiBlbmRDb250YWluZXIgJiYgc3RhcnRDb250YWluZXIubm9kZSAmJiBlbmRDb250YWluZXIubm9kZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLm5vZGUsIHN0YXJ0Q29udGFpbmVyLm9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoZW5kQ29udGFpbmVyLm5vZGUsIGVuZENvbnRhaW5lci5vZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhbmdlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcldpdGhSYW5nZShyYW5nZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyAnQ291bGQgbm90IGZpbmQgc3RhcnQtIGFuZC9vciBlbmQtY29udGFpbmVyIGluIGRvY3VtZW50JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgcmVzdWx0ICh0aGF0IHJldHVybmVkIGZyb20gYHJlbmRlcldpdGhSYW5nZWApXG4gICAgICogQHBhcmFtIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgcmVuZGVyV2l0aFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyV2l0aFBhdGgoXG4gICAgICAgICAgICBgJHtyZXN1bHQuc3RhcnRDb250YWluZXJQYXRofTske3Jlc3VsdC5zdGFydE9mZnNldH1gLFxuICAgICAgICAgICAgYCR7cmVzdWx0LmVuZENvbnRhaW5lclBhdGh9OyR7cmVzdWx0LmVuZE9mZnNldH1gKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgc2VsZWN0aW9uIHdpdGggYSByYW5nZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhvdXRSZXN1bHRdIG9wdGlvbmFsIGRvIGNhbGN1bGF0ZSBhIHJlc3VsdCwgdGhlIHNlbGVjdGlvbiB3b3VsZCBub3QgYmUgc2VyaWFsaXphYmxlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICByZW5kZXJXaXRoUmFuZ2UocmFuZ2UsIHdpdGhvdXRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcldpdGhFbGVtZW50cyhyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2UuZW5kQ29udGFpbmVyLFxuICAgICAgICAgICAgcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRPZmZzZXQsIHdpdGhvdXRSZXN1bHQpO1xuICAgIH1cbn1cblxuIl19\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main/Rendering.js\n ** module id = 3\n ** module chunks = 0 1\n **/","\"use strict\";\n\nvar _Object$defineProperty = require(\"babel-runtime/core-js/object/define-property\")[\"default\"];\n\nexports[\"default\"] = (function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n\n      _Object$defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n})();\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/create-class.js\n ** module id = 4\n ** module chunks = 0 1\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/define-property.js\n ** module id = 5\n ** module chunks = 0 1\n **/","var $ = require('../../modules/$');\nmodule.exports = function defineProperty(it, key, desc){\n  return $.setDesc(it, key, desc);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/fn/object/define-property.js\n ** module id = 6\n ** module chunks = 0 1\n **/","'use strict';\nvar global = typeof self != 'undefined' ? self : Function('return this')()\n  , core   = {}\n  , defineProperty = Object.defineProperty\n  , hasOwnProperty = {}.hasOwnProperty\n  , ceil  = Math.ceil\n  , floor = Math.floor\n  , max   = Math.max\n  , min   = Math.min;\n// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.\nvar DESC = !!function(){\n  try {\n    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;\n  } catch(e){ /* empty */ }\n}();\nvar hide = createDefiner(1);\n// 7.1.4 ToInteger\nfunction toInteger(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n}\nfunction desc(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n}\nfunction simpleSet(object, key, value){\n  object[key] = value;\n  return object;\n}\nfunction createDefiner(bitmap){\n  return DESC ? function(object, key, value){\n    return $.setDesc(object, key, desc(bitmap, value));\n  } : simpleSet;\n}\n\nfunction isObject(it){\n  return it !== null && (typeof it == 'object' || typeof it == 'function');\n}\nfunction isFunction(it){\n  return typeof it == 'function';\n}\nfunction assertDefined(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n}\n\nvar $ = module.exports = require('./$.fw')({\n  g: global,\n  core: core,\n  html: global.document && document.documentElement,\n  // http://jsperf.com/core-js-isobject\n  isObject:   isObject,\n  isFunction: isFunction,\n  that: function(){\n    return this;\n  },\n  // 7.1.4 ToInteger\n  toInteger: toInteger,\n  // 7.1.15 ToLength\n  toLength: function(it){\n    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n  },\n  toIndex: function(index, length){\n    index = toInteger(index);\n    return index < 0 ? max(index + length, 0) : min(index, length);\n  },\n  has: function(it, key){\n    return hasOwnProperty.call(it, key);\n  },\n  create:     Object.create,\n  getProto:   Object.getPrototypeOf,\n  DESC:       DESC,\n  desc:       desc,\n  getDesc:    Object.getOwnPropertyDescriptor,\n  setDesc:    defineProperty,\n  setDescs:   Object.defineProperties,\n  getKeys:    Object.keys,\n  getNames:   Object.getOwnPropertyNames,\n  getSymbols: Object.getOwnPropertySymbols,\n  assertDefined: assertDefined,\n  // Dummy, fix for not array-like ES3 string in es5 module\n  ES5Object: Object,\n  toObject: function(it){\n    return $.ES5Object(assertDefined(it));\n  },\n  hide: hide,\n  def: createDefiner(0),\n  set: global.Symbol ? simpleSet : hide,\n  each: [].forEach\n});\n/* eslint-disable no-undef */\nif(typeof __e != 'undefined')__e = core;\nif(typeof __g != 'undefined')__g = global;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.js\n ** module id = 7\n ** module chunks = 0 1\n **/","module.exports = function($){\n  $.FW   = false;\n  $.path = $.core;\n  return $;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.fw.js\n ** module id = 8\n ** module chunks = 0 1\n **/","\"use strict\";\n\nexports[\"default\"] = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/class-call-check.js\n ** module id = 9\n ** module chunks = 0 1\n **/","/* global Node, NodeList, Element */\n\n'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nObject.defineProperty(exports, '__esModule', {\n    value: true\n});\n/**\n * @type {string}\n */\nvar ATTR_DATA_ORIGINAL_INDEX = 'data-original-index';\nexports.ATTR_DATA_ORIGINAL_INDEX = ATTR_DATA_ORIGINAL_INDEX;\n/**\n * @type {string}\n */\nvar DATA_PSEUDO = 'data-is-pseudo';\nexports.DATA_PSEUDO = DATA_PSEUDO;\n/**\n * @type {string}\n */\nvar DATA_IS_SELECTION = 'data-is-selection';\nexports.DATA_IS_SELECTION = DATA_IS_SELECTION;\n/**\n * @type {string}\n */\nvar SERIALIZE_SEPARATOR = ';';\n\n// polyfill for matchesSelector, IE 10/11 does not support Element.matches\nif (Element && !Element.prototype.matches) {\n    var p = Element.prototype;\n    p.matches = p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n}\n\n/**\n * Utility class\n * Contains DOM/Node manipulation helpers\n */\n\nvar Util = (function () {\n    function Util() {\n        _classCallCheck(this, Util);\n    }\n\n    _createClass(Util, null, [{\n        key: 'nodeListFilter',\n\n        /**\n         * Filter for a NodeList\n         * @param {NodeList} nodes\n         * @param {Function} func\n         * @returns {Array.<HTMLElement>}\n         */\n        value: function nodeListFilter(nodes, func) {\n            return Array.prototype.filter.call(nodes || [], func);\n        }\n    }, {\n        key: 'guid',\n\n        /**\n         * Generates a unique id\n         * @return {String}\n         */\n        value: function guid() {\n            function s4() {\n                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n            }\n\n            return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n        }\n    }, {\n        key: 'nodeIsEmpty',\n\n        /**\n         * Checks if a given node is empty\n         * @param {HTMLElement} node\n         * @returns {*}\n         */\n        value: function nodeIsEmpty(node) {\n            return node.nodeValue.match(/^[\\s]*$/g);\n        }\n    }, {\n        key: 'index',\n\n        /**\n         * @param {HTMLElement} node\n         * @param [optionalList]\n         * @return {int} the index of this node in context to it's siblings\n         */\n        value: function index(node, optionalList) {\n            var children = optionalList || (node.nodeType === Node.TEXT_NODE ? node.parentNode.childNodes : node.parentNode.children);\n            return Array.prototype.indexOf.call(children || [], node);\n        }\n    }, {\n        key: 'wrap',\n\n        /**\n         * Wraps given `elms` in given `wrapper`\n         *\n         * @param {HTMLElement} wrapper\n         * @param {HTMLElement|Array.<HTMLElement>} elms\n         * @return {HTMLElement}\n         */\n        value: function wrap(elms, wrapper) {\n            if (!elms) {\n                return wrapper;\n            }\n            // Convert `elms` to an array, if necessary.\n            if (!(elms instanceof NodeList || elms instanceof Array)) {\n                elms = [elms];\n            }\n            for (var i = elms.length - 1; i >= 0; i--) {\n                var child = i > 0 ? wrapper.cloneNode(true) : wrapper;\n                var el = elms[i];\n                // Cache the current parent and sibling.\n                var _parent = el.parentNode,\n                    sibling = el.nextSibling;\n\n                child.appendChild(el);\n                if (sibling) {\n                    _parent.insertBefore(child, sibling);\n                } else {\n                    _parent.appendChild(child);\n                }\n            }\n            return wrapper;\n        }\n    }, {\n        key: 'calcIndex',\n\n        /**\n         * Will calculate an index depending on an already modified dom by marklib\n         * @param {HTMLElement} node\n         * @returns {int|boolean}\n         */\n        value: function calcIndex(node) {\n            var calculatedIndex = 0,\n                foundWrapper = false;\n            var nodes = node.parentNode.childNodes,\n                length = nodes.length;\n            for (var thisIndex = 0; thisIndex < length; thisIndex++) {\n                var el = nodes[thisIndex];\n                if (el === node) {\n                    break;\n                }\n                // reset index when original index is found\n                var maybeIndexOfOriginal = el.getAttribute ? el.getAttribute(ATTR_DATA_ORIGINAL_INDEX) : null;\n\n                if (maybeIndexOfOriginal) {\n                    calculatedIndex = parseInt(maybeIndexOfOriginal);\n                    foundWrapper = true;\n                }\n                calculatedIndex++;\n            }\n            return foundWrapper ? calculatedIndex : Util.index(node);\n        }\n    }, {\n        key: 'parents',\n\n        /**\n         * @param {HTMLElement} el\n         * @param {String} [optionalSelector] will test given element against a selector\n         *  if matches, returns this element immediately\n         * @return {Array.<HTMLElement>} an array of all found parents of given element (and optional selector)\n         */\n        value: function parents(el, optionalSelector) {\n            var element = el;\n            var foundElements = [];\n            while (element.parentNode !== null) {\n                element = element.parentNode;\n                if (optionalSelector && (element === optionalSelector || typeof optionalSelector === 'string' && element.matches && element.matches(optionalSelector))) {\n                    foundElements.push(element);\n                } else if (!optionalSelector) {\n                    foundElements.push(element);\n                }\n            }\n            return foundElements;\n        }\n    }, {\n        key: 'parent',\n\n        /**\n         * Finds a parent node (the closest) with a given selector\n         * @param {Node} el\n         * @param {String} selector\n         * @returns {Node|bool}\n         */\n        value: function parent(el, selector) {\n            var element = el;\n            while (element.parentNode !== null) {\n                element = element.parentNode;\n                if (element.matches && element.matches(selector)) {\n                    return element;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'closest',\n\n        /**\n         * Finds the closest element including itself matching a given selector\n         * @param {Node} el\n         * @param selector\n         * @returns {Node|bool}\n         */\n        value: function closest(el, selector) {\n            var element = el;\n            while (element !== null) {\n                if (element.matches && element.matches(selector)) {\n                    return element;\n                }\n                element = element.parentNode;\n            }\n            return false;\n        }\n    }, {\n        key: 'isMarkNode',\n\n        /**\n         * @param {HTMLElement} n\n         * @return {bool}\n         */\n        value: function isMarkNode(n) {\n            return n instanceof HTMLElement && n.hasAttribute(DATA_IS_SELECTION);\n        }\n    }, {\n        key: 'getPath',\n\n        /**\n         * Determines the correct paths and excludes all `marklib` generated content\n         * TODO: To improve performance we could shorten the path if an ID is present in it.\n         * @param {HTMLElement} el\n         * @param {HTMLElement} [context] if given extraction path is relative to this element\n         * @returns {string}\n         */\n        value: function getPath(el, context) {\n            var path = null,\n                node = el;\n\n            var filterSiblings = function filterSiblings(thisEl) {\n                return !Util.isMarkNode(thisEl) && thisEl.nodeName === node.nodeName;\n            };\n\n            while (node) {\n                var name = null;\n                // If node is a text-node, save index\n                if (Node.TEXT_NODE === node.nodeType) {\n\n                    /* Because nodes may wrapped inside a highlighting node, we need to find the original index that was\n                     * valid before the dom changes. We store the last known index position inside all wrapper elements\n                     * We select the outermost\n                     */\n\n                    // Extract original index of this node:\n                    // Outer most data-original-index is original index\n                    var outerMostElement = Util.parents(node, '[' + ATTR_DATA_ORIGINAL_INDEX + ']').reverse()[0];\n                    // if element is not yet wrapped in span, recalculate index based on parent container:\n                    // We have to do this because text node indexes != element indexes...\n                    var calculatedIndex = 0;\n                    if (!outerMostElement) {\n                        calculatedIndex = Util.calcIndex(node);\n                    }\n                    var index = outerMostElement ? parseInt(outerMostElement.getAttribute(ATTR_DATA_ORIGINAL_INDEX)) : calculatedIndex;\n                    name = SERIALIZE_SEPARATOR + index;\n                } else {\n                    name = node.nodeName;\n                }\n\n                if (!name) {\n                    break;\n                }\n\n                name = name.toLowerCase();\n\n                var parent = node.parentNode;\n\n                if (Util.isMarkNode(node)) {\n                    if (parent !== context) {\n                        node = parent;\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n\n                // Select only siblings that are not part of selection and are of the same type\n                // (because we use nth-of-type selector later)\n                var siblings = Util.nodeListFilter(parent.children, filterSiblings),\n                    nodeIndex = Util.index(node, siblings);\n\n                if (siblings.length > 1 && nodeIndex >= 0) {\n                    name += ':nth-of-type(' + (nodeIndex + 1) + ')';\n                }\n\n                path = name + (path ? '>' + path : '');\n\n                if (parent === context) {\n                    break;\n                }\n\n                node = parent;\n            }\n\n            return path.replace('#document>', '').replace('>;', ';');\n        }\n    }]);\n\n    return Util;\n})();\n\nexports['default'] = Util;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9ib3dsaW5neC9Qcm9qZWt0ZS9tYXJrbGliL3NyYy9tYWluL3V0aWwvVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7O0FBS04sSUFBTSx3QkFBd0IsR0FBRyxxQkFBcUIsQ0FBQztRQUFqRCx3QkFBd0IsR0FBeEIsd0JBQXdCOzs7O0FBSTlCLElBQU0sV0FBVyxHQUFHLGdCQUFnQixDQUFDO1FBQS9CLFdBQVcsR0FBWCxXQUFXOzs7O0FBSWpCLElBQU0saUJBQWlCLEdBQUcsbUJBQW1CLENBQUM7UUFBeEMsaUJBQWlCLEdBQWpCLGlCQUFpQjs7OztBQUk5QixJQUFNLG1CQUFtQixHQUFHLEdBQUcsQ0FBQzs7O0FBR2hDLElBQUksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUU7QUFDdkMsUUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztBQUMxQixLQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxlQUFlLElBQ3pCLENBQUMsQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLENBQUMsaUJBQWlCLElBQzNDLENBQUMsQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLENBQUMscUJBQXFCLENBQUM7Q0FDckQ7Ozs7Ozs7SUFPSyxJQUFJO2FBQUosSUFBSTs4QkFBSixJQUFJOzs7aUJBQUosSUFBSTs7Ozs7Ozs7O2VBT2Usd0JBQUMsS0FBSyxFQUFFLElBQUksRUFBRTtBQUMvQixtQkFBTyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUN6RDs7Ozs7Ozs7ZUFPVSxnQkFBRztBQUNWLHFCQUFTLEVBQUUsR0FBRztBQUNWLHVCQUFPLElBQUksQ0FB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Q0FBQztpQkFDbkQ7O0FBRUQsb0JBQUksR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBLEFBQUMsQ0FBQzs7QUFHdkMsb0JBQUksTUFBTSxLQUFLLE9BQU8sRUFBRTtBQUNwQiwwQkFBTTtpQkFDVDs7QUFFRCxvQkFBSSxHQUFHLE1BQU0sQ0FBQzthQUNqQjs7QUFFRCxtQkFBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQzVEOzs7V0FyUEMsSUFBSTs7O3FCQUFKLElBQUkiLCJmaWxlIjoiL1VzZXJzL2Jvd2xpbmd4L1Byb2pla3RlL21hcmtsaWIvbm9kZV9tb2R1bGVzL2VzbGludC1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2Jvd2xpbmd4L1Byb2pla3RlL21hcmtsaWIvc3JjL21haW4vdXRpbC9VdGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIE5vZGUsIE5vZGVMaXN0LCBFbGVtZW50ICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQVRUUl9EQVRBX09SSUdJTkFMX0lOREVYID0gJ2RhdGEtb3JpZ2luYWwtaW5kZXgnO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgREFUQV9QU0VVRE8gPSAnZGF0YS1pcy1wc2V1ZG8nO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgREFUQV9JU19TRUxFQ1RJT04gPSAnZGF0YS1pcy1zZWxlY3Rpb24nO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBTRVJJQUxJWkVfU0VQQVJBVE9SID0gXCI7XCI7XG5cbi8vIHBvbHlmaWxsIGZvciBtYXRjaGVzU2VsZWN0b3IsIElFIDEwLzExIGRvZXMgbm90IHN1cHBvcnQgRWxlbWVudC5tYXRjaGVzXG5pZiAoRWxlbWVudCAmJiAhRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgIHZhciBwID0gRWxlbWVudC5wcm90b3R5cGU7XG4gICAgcC5tYXRjaGVzID0gcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG59XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzc1xuICogQ29udGFpbnMgRE9NL05vZGUgbWFuaXB1bGF0aW9uIGhlbHBlcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHRcbmNsYXNzIFV0aWwge1xuICAgIC8qKlxuICAgICAqIEZpbHRlciBmb3IgYSBOb2RlTGlzdFxuICAgICAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48SFRNTEVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHN0YXRpYyBub2RlTGlzdEZpbHRlcihub2RlcywgZnVuYykge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKG5vZGVzIHx8IFtdLCBmdW5jKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBpZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ3VpZCgpIHtcbiAgICAgICAgZnVuY3Rpb24gczQoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICAgLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICtcbiAgICAgICAgICAgIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gbm9kZSBpcyBlbXB0eVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbm9kZUlzRW1wdHkobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5ub2RlVmFsdWUubWF0Y2goL15bXFxzXSokL2cpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSBbb3B0aW9uYWxMaXN0XVxuICAgICAqIEByZXR1cm4ge2ludH0gdGhlIGluZGV4IG9mIHRoaXMgbm9kZSBpbiBjb250ZXh0IHRvIGl0J3Mgc2libGluZ3NcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5kZXgobm9kZSwgb3B0aW9uYWxMaXN0KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gb3B0aW9uYWxMaXN0IHx8IChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMgOiBub2RlLnBhcmVudE5vZGUuY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChjaGlsZHJlbiB8fCBbXSwgbm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgZ2l2ZW4gYGVsbXNgIGluIGdpdmVuIGB3cmFwcGVyYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gd3JhcHBlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8QXJyYXkuPEhUTUxFbGVtZW50Pn0gZWxtc1xuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHN0YXRpYyB3cmFwKGVsbXMsIHdyYXBwZXIpIHtcbiAgICAgICAgaWYgKCFlbG1zKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IGBlbG1zYCB0byBhbiBhcnJheSwgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoIShlbG1zIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgZWxtcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgZWxtcyA9IFtlbG1zXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZWxtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAoaSA+IDApID8gd3JhcHBlci5jbG9uZU5vZGUodHJ1ZSkgOiB3cmFwcGVyO1xuICAgICAgICAgICAgY29uc3QgZWwgPSBlbG1zW2ldO1xuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGN1cnJlbnQgcGFyZW50IGFuZCBzaWJsaW5nLlxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50Tm9kZSwgc2libGluZyA9IGVsLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICBjaGlsZC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgY2FsY3VsYXRlIGFuIGluZGV4IGRlcGVuZGluZyBvbiBhbiBhbHJlYWR5IG1vZGlmaWVkIGRvbSBieSBtYXJrbGliXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqIEByZXR1cm5zIHtpbnR8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY0luZGV4KG5vZGUpIHtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRJbmRleCA9IDAsXG4gICAgICAgICAgICBmb3VuZFdyYXBwZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBub2RlLnBhcmVudE5vZGUuY2hpbGROb2RlcywgbGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCB0aGlzSW5kZXggPSAwOyB0aGlzSW5kZXggPCBsZW5ndGg7IHRoaXNJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IG5vZGVzW3RoaXNJbmRleF07XG4gICAgICAgICAgICBpZiAoZWwgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc2V0IGluZGV4IHdoZW4gb3JpZ2luYWwgaW5kZXggaXMgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IG1heWJlSW5kZXhPZk9yaWdpbmFsID0gZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9JTkRFWCkgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAobWF5YmVJbmRleE9mT3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSW5kZXggPSBwYXJzZUludChtYXliZUluZGV4T2ZPcmlnaW5hbCk7XG4gICAgICAgICAgICAgICAgZm91bmRXcmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGN1bGF0ZWRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZFdyYXBwZXIgPyBjYWxjdWxhdGVkSW5kZXggOiBVdGlsLmluZGV4KG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25hbFNlbGVjdG9yXSB3aWxsIHRlc3QgZ2l2ZW4gZWxlbWVudCBhZ2FpbnN0IGEgc2VsZWN0b3JcbiAgICAgKiAgaWYgbWF0Y2hlcywgcmV0dXJucyB0aGlzIGVsZW1lbnQgaW1tZWRpYXRlbHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48SFRNTEVsZW1lbnQ+fSBhbiBhcnJheSBvZiBhbGwgZm91bmQgcGFyZW50cyBvZiBnaXZlbiBlbGVtZW50IChhbmQgb3B0aW9uYWwgc2VsZWN0b3IpXG4gICAgICovXG4gICAgc3RhdGljIHBhcmVudHMoZWwsIG9wdGlvbmFsU2VsZWN0b3IpIHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBlbDtcbiAgICAgICAgY29uc3QgZm91bmRFbGVtZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsU2VsZWN0b3IgJiYgKChlbGVtZW50ID09PSBvcHRpb25hbFNlbGVjdG9yKSB8fFxuICAgICAgICAgICAgICAgICggKHR5cGVvZiBvcHRpb25hbFNlbGVjdG9yID09PSAnc3RyaW5nJykgJiYgZWxlbWVudC5tYXRjaGVzICYmIGVsZW1lbnQubWF0Y2hlcyhvcHRpb25hbFNlbGVjdG9yKSkpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3B0aW9uYWxTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGZvdW5kRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRFbGVtZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIHBhcmVudCBub2RlICh0aGUgY2xvc2VzdCkgd2l0aCBhIGdpdmVuIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICAgICAqIEByZXR1cm5zIHtOb2RlfGJvb2x9XG4gICAgICovXG4gICAgc3RhdGljIHBhcmVudChlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBlbDtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm1hdGNoZXMgJiYgZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgY2xvc2VzdCBlbGVtZW50IGluY2x1ZGluZyBpdHNlbGYgbWF0Y2hpbmcgYSBnaXZlbiBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXxib29sfVxuICAgICAqL1xuICAgIHN0YXRpYyBjbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICAgICAgICBsZXQgZWxlbWVudCA9IGVsO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubWF0Y2hlcyAmJiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBuXG4gICAgICogQHJldHVybiB7Ym9vbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNNYXJrTm9kZShuKSB7XG4gICAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgbi5oYXNBdHRyaWJ1dGUoREFUQV9JU19TRUxFQ1RJT04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGNvcnJlY3QgcGF0aHMgYW5kIGV4Y2x1ZGVzIGFsbCBgbWFya2xpYmAgZ2VuZXJhdGVkIGNvbnRlbnRcbiAgICAgKiBUT0RPOiBUbyBpbXByb3ZlIHBlcmZvcm1hbmNlIHdlIGNvdWxkIHNob3J0ZW4gdGhlIHBhdGggaWYgYW4gSUQgaXMgcHJlc2VudCBpbiBpdC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250ZXh0XSBpZiBnaXZlbiBleHRyYWN0aW9uIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhpcyBlbGVtZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGF0aChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcGF0aCA9IG51bGwsIG5vZGUgPSBlbDtcblxuICAgICAgICBjb25zdCBmaWx0ZXJTaWJsaW5ncyA9ICh0aGlzRWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhVXRpbC5pc01hcmtOb2RlKHRoaXNFbCkgJiYgdGhpc0VsLm5vZGVOYW1lID09PSBub2RlLm5vZGVOYW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBJZiBub2RlIGlzIGEgdGV4dC1ub2RlLCBzYXZlIGluZGV4XG4gICAgICAgICAgICBpZiAoTm9kZS5URVhUX05PREUgPT09IG5vZGUubm9kZVR5cGUpIHtcblxuICAgICAgICAgICAgICAgIC8qIEJlY2F1c2Ugbm9kZXMgbWF5IHdyYXBwZWQgaW5zaWRlIGEgaGlnaGxpZ2h0aW5nIG5vZGUsIHdlIG5lZWQgdG8gZmluZCB0aGUgb3JpZ2luYWwgaW5kZXggdGhhdCB3YXNcbiAgICAgICAgICAgICAgICAgKiB2YWxpZCBiZWZvcmUgdGhlIGRvbSBjaGFuZ2VzLiBXZSBzdG9yZSB0aGUgbGFzdCBrbm93biBpbmRleCBwb3NpdGlvbiBpbnNpZGUgYWxsIHdyYXBwZXIgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgKiBXZSBzZWxlY3QgdGhlIG91dGVybW9zdFxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBvcmlnaW5hbCBpbmRleCBvZiB0aGlzIG5vZGU6XG4gICAgICAgICAgICAgICAgLy8gT3V0ZXIgbW9zdCBkYXRhLW9yaWdpbmFsLWluZGV4IGlzIG9yaWdpbmFsIGluZGV4XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ZXJNb3N0RWxlbWVudCA9IFV0aWwucGFyZW50cyhub2RlLCAnWycgKyBBVFRSX0RBVEFfT1JJR0lOQUxfSU5ERVggKyAnXScpLnJldmVyc2UoKVswXTtcbiAgICAgICAgICAgICAgICAvLyBpZiBlbGVtZW50IGlzIG5vdCB5ZXQgd3JhcHBlZCBpbiBzcGFuLCByZWNhbGN1bGF0ZSBpbmRleCBiYXNlZCBvbiBwYXJlbnQgY29udGFpbmVyOlxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZG8gdGhpcyBiZWNhdXNlIHRleHQgbm9kZSBpbmRleGVzICE9IGVsZW1lbnQgaW5kZXhlcy4uLlxuICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGlmICghb3V0ZXJNb3N0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSW5kZXggPSBVdGlsLmNhbGNJbmRleChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvdXRlck1vc3RFbGVtZW50ID8gcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAgIG91dGVyTW9zdEVsZW1lbnQuZ2V0QXR0cmlidXRlKEFUVFJfREFUQV9PUklHSU5BTF9JTkRFWCkpIDogY2FsY3VsYXRlZEluZGV4O1xuICAgICAgICAgICAgICAgIG5hbWUgPSBTRVJJQUxJWkVfU0VQQVJBVE9SICsgaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgaWYgKFV0aWwuaXNNYXJrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmKHBhcmVudCAhPT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdCBvbmx5IHNpYmxpbmdzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHNlbGVjdGlvbiBhbmQgYXJlIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgIC8vIChiZWNhdXNlIHdlIHVzZSBudGgtb2YtdHlwZSBzZWxlY3RvciBsYXRlcilcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdzID0gVXRpbC5ub2RlTGlzdEZpbHRlcihwYXJlbnQuY2hpbGRyZW4sIGZpbHRlclNpYmxpbmdzKSxcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBVdGlsLmluZGV4KG5vZGUsIHNpYmxpbmdzKTtcblxuICAgICAgICAgICAgaWYgKHNpYmxpbmdzLmxlbmd0aCA+IDEgJiYgbm9kZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9ICc6bnRoLW9mLXR5cGUoJyArIChub2RlSW5kZXggKyAxKSArICcpJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0aCA9IG5hbWUgKyAocGF0aCA/ICc+JyArIHBhdGggOiAnJyk7XG5cblxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZShcIiNkb2N1bWVudD5cIiwgXCJcIikucmVwbGFjZSgnPjsnLCAnOycpO1xuICAgIH1cblxufVxuIl19\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main/util/Util.js\n ** module id = 10\n ** module chunks = 0 1\n **/"],"sourceRoot":""}