{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///js/marklib.min.js","webpack:///webpack/bootstrap 4c78df0762d41b78383d?839e","webpack:///./~/babel-runtime/helpers/interop-require-default.js?385b","webpack:///./src/main/util/Util.js?be3e","webpack:///./~/babel-runtime/helpers/class-call-check.js?8b1f","webpack:///./~/babel-runtime/helpers/create-class.js?0764","webpack:///./src/main/Rendering.js?4dd4","webpack:///./src/main/modules/Marklib.js?58cb","webpack:///./~/babel-runtime/core-js/object/define-property.js?5f70","webpack:///./~/babel-runtime/~/core-js/library/fn/object/define-property.js?4d33","webpack:///./~/babel-runtime/~/core-js/library/modules/$.js?2863"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","obj","__esModule","default","_createClass","_classCallCheck","Object","defineProperty","value","ATTR_DATA_ORIGINAL_INDEX","DATA_PSEUDO","DATA_IS_SELECTION","SERIALIZE_SEPARATOR","Element","prototype","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","Util","key","nodes","func","Array","filter","s4","Math","floor","random","toString","substring","node","nodeValue","match","optionalList","children","nodeType","Node","TEXT_NODE","parentNode","childNodes","indexOf","elms","wrapper","NodeList","i","length","child","cloneNode","el","_parent","sibling","nextSibling","appendChild","insertBefore","calculatedIndex","foundWrapper","thisIndex","maybeIndexOfOriginal","getAttribute","parseInt","index","optionalSelector","element","foundElements","push","selector","n","HTMLElement","hasAttribute","context","path","filterSiblings","thisEl","isMarkNode","nodeName","name","outerMostElement","parents","reverse","calcIndex","toLowerCase","parent","siblings","nodeListFilter","nodeIndex","replace","instance","Constructor","TypeError","_Object$defineProperty","defineProperties","target","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_interopRequireDefault","_utilUtil","_utilUtil2","TAG_NAME","ATTR_DATA_ORIGINAL_OFFSET_START","DATA_ORIGINAL_TEXT_NODE_INDEX","ATTR_DATA_START_END","ATTR_DATA_IS_HIGHLIGHT_NODE","ATTR_DATA_ID","DOCUMENT_POSITION_CONTAINED_BY","Rendering","document","cssClass","Document","guid","undefined","startContainer","endContainer","markerPrefix","markerSuffix","_onWrappedNodeFunc","f","apply","arguments","createElement","vTrue","className","setAttribute","getId","text","_createWrapTemplate","textContent","initialNode","prefix","offset","_createStartEndWrapTemplate","_getIndexParentIfHas","marklibInstance","optionalLength","optionalIndex","optionalIsSameNode","originalIndex","offsetLength","_getOffsetParentIfHas","wrap","_callOnWrappedNode","originalElement","walkDom","nodeIsEmpty","start","nextParent","nextParentNode","currentParentNode","wrapSiblings","_this","next","found","thisNode","_createWrap","classList","remove","removeAttribute","bind","wrapIf","walkIfContained","e","walkIfNotContained","currentNext","compareDocumentPosition","_walkTextNodes","textNode","startIndex","endIndex","initialText","initialIndex","textBefore","slice","createTextNode","previousSibling","_createSplitContainer","textAfter","startOffset","endOffset","startContainerIndex","endContainerIndex","fullTextStartValue","startT","partTextStartValue","offsetStart","_createStartOrEndContainer","endT","fullTextEndValue","partTextEndValue","offsetParent","lengthElement","commonAncestor","withoutResult","outer","contextContainer","originalStartOffset","_findOriginalOffset","originalEndOffset","nextElementSibling","endContainerContents","closest","r","lastChild","result","startContainerPath","getPath","endContainerPath","_renderSelection","_markTextSameNode","_markTextDifferentNode","walk","pSplit","split","objectIndex","charOffset","container","trim","querySelector","maybeFoundNode","atrOffsetStart","atrIndex","thisOffset","startPath","endPath","_deserializePath","range","createRange","setStart","setEnd","renderWithRange","renderWithPath","_renderWithElements","commonAncestorContainer","_Rendering","_Rendering2","$","it","desc","setDesc","$Object","create","getProto","getPrototypeOf","isEnum","propertyIsEnumerable","getDesc","getOwnPropertyDescriptor","setDescs","getKeys","keys","getNames","getOwnPropertyNames","getSymbols","getOwnPropertySymbols","each","forEach"],"mappings":"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","file":"js/marklib.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Marklib\"] = factory();\n\telse\n\t\troot[\"Marklib\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Marklib\"] = factory();\n\telse\n\t\troot[\"Marklib\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"../\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(6);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports[\"default\"] = function (obj) {\n\t  return obj && obj.__esModule ? obj : {\n\t    \"default\": obj\n\t  };\n\t};\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global Node, NodeList, Element */\n\t\n\t'use strict';\n\t\n\t/**\n\t * @type {string}\n\t */\n\t\n\tvar _createClass = __webpack_require__(4)['default'];\n\t\n\tvar _classCallCheck = __webpack_require__(3)['default'];\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\tvar ATTR_DATA_ORIGINAL_INDEX = 'data-original-index';\n\texports.ATTR_DATA_ORIGINAL_INDEX = ATTR_DATA_ORIGINAL_INDEX;\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_PSEUDO = 'data-is-pseudo';\n\texports.DATA_PSEUDO = DATA_PSEUDO;\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_IS_SELECTION = 'data-is-selection';\n\texports.DATA_IS_SELECTION = DATA_IS_SELECTION;\n\t/**\n\t * @type {string}\n\t */\n\tvar SERIALIZE_SEPARATOR = \";\";\n\t\n\t// polyfill for matchesSelector, IE 10/11 does not support Element.matches\n\tif (Element && !Element.prototype.matches) {\n\t    var p = Element.prototype;\n\t    p.matches = p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t}\n\t\n\t/**\n\t * Utility class\n\t * Contains DOM/Node manipulation helpers\n\t */\n\t\n\tvar Util = (function () {\n\t    function Util() {\n\t        _classCallCheck(this, Util);\n\t    }\n\t\n\t    _createClass(Util, null, [{\n\t        key: 'nodeListFilter',\n\t\n\t        /**\n\t         * Filter for a NodeList\n\t         * @param {NodeList} nodes\n\t         * @param {Function} func\n\t         * @returns {Array.<HTMLElement>}\n\t         */\n\t        value: function nodeListFilter(nodes, func) {\n\t            return Array.prototype.filter.call(nodes || [], func);\n\t        }\n\t\n\t        /**\n\t         * Generates a unique id\n\t         * @return {String}\n\t         */\n\t    }, {\n\t        key: 'guid',\n\t        value: function guid() {\n\t            function s4() {\n\t                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t            }\n\t\n\t            return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t        }\n\t\n\t        /**\n\t         * Checks if a given node is empty\n\t         * @param {HTMLElement} node\n\t         * @returns {*}\n\t         */\n\t    }, {\n\t        key: 'nodeIsEmpty',\n\t        value: function nodeIsEmpty(node) {\n\t            return node.nodeValue.match(/^[\\s]*$/g);\n\t        }\n\t\n\t        /**\n\t         * @param {HTMLElement} node\n\t         * @param [optionalList]\n\t         * @return {int} the index of this node in context to it's siblings\n\t         */\n\t    }, {\n\t        key: 'index',\n\t        value: function index(node, optionalList) {\n\t            var children = optionalList || (node.nodeType === Node.TEXT_NODE ? node.parentNode.childNodes : node.parentNode.children);\n\t            return Array.prototype.indexOf.call(children || [], node);\n\t        }\n\t\n\t        /**\n\t         * Wraps given `elms` in given `wrapper`\n\t         *\n\t         * @param {HTMLElement} wrapper\n\t         * @param {HTMLElement|Array.<HTMLElement>} elms\n\t         * @return {HTMLElement}\n\t         */\n\t    }, {\n\t        key: 'wrap',\n\t        value: function wrap(elms, wrapper) {\n\t            if (!elms) {\n\t                return wrapper;\n\t            }\n\t            // Convert `elms` to an array, if necessary.\n\t            if (!(elms instanceof NodeList || elms instanceof Array)) {\n\t                elms = [elms];\n\t            }\n\t            for (var i = elms.length - 1; i >= 0; i--) {\n\t                var child = i > 0 ? wrapper.cloneNode(true) : wrapper;\n\t                var el = elms[i];\n\t                // Cache the current parent and sibling.\n\t                var _parent = el.parentNode,\n\t                    sibling = el.nextSibling;\n\t\n\t                child.appendChild(el);\n\t                if (sibling) {\n\t                    _parent.insertBefore(child, sibling);\n\t                } else {\n\t                    _parent.appendChild(child);\n\t                }\n\t            }\n\t            return wrapper;\n\t        }\n\t\n\t        /**\n\t         * Will calculate an index depending on an already modified dom by marklib\n\t         * @param {HTMLElement} node\n\t         * @returns {int|boolean}\n\t         */\n\t    }, {\n\t        key: 'calcIndex',\n\t        value: function calcIndex(node) {\n\t            var calculatedIndex = 0,\n\t                foundWrapper = false;\n\t            var nodes = node.parentNode.childNodes,\n\t                length = nodes.length;\n\t            for (var thisIndex = 0; thisIndex < length; thisIndex++) {\n\t                var el = nodes[thisIndex];\n\t                if (el === node) {\n\t                    break;\n\t                }\n\t                // reset index when original index is found\n\t                var maybeIndexOfOriginal = el.getAttribute ? el.getAttribute(ATTR_DATA_ORIGINAL_INDEX) : null;\n\t\n\t                if (maybeIndexOfOriginal) {\n\t                    calculatedIndex = parseInt(maybeIndexOfOriginal);\n\t                    foundWrapper = true;\n\t                }\n\t                calculatedIndex++;\n\t            }\n\t            return foundWrapper ? calculatedIndex : Util.index(node);\n\t        }\n\t\n\t        /**\n\t         * @param {HTMLElement} el\n\t         * @param {String} [optionalSelector] will test given element against a selector\n\t         *  if matches, returns this element immediately\n\t         * @return {Array.<HTMLElement>} an array of all found parents of given element (and optional selector)\n\t         */\n\t    }, {\n\t        key: 'parents',\n\t        value: function parents(el, optionalSelector) {\n\t            var element = el;\n\t            var foundElements = [];\n\t            while (element.parentNode !== null) {\n\t                element = element.parentNode;\n\t                if (optionalSelector && (element === optionalSelector || typeof optionalSelector === 'string' && element.matches && element.matches(optionalSelector))) {\n\t                    foundElements.push(element);\n\t                } else if (!optionalSelector) {\n\t                    foundElements.push(element);\n\t                }\n\t            }\n\t            return foundElements;\n\t        }\n\t\n\t        /**\n\t         * Finds a parent node (the closest) with a given selector\n\t         * @param {Node} el\n\t         * @param {String} selector\n\t         * @returns {Node|bool}\n\t         */\n\t    }, {\n\t        key: 'parent',\n\t        value: function parent(el, selector) {\n\t            var element = el;\n\t            while (element.parentNode !== null) {\n\t                element = element.parentNode;\n\t                if (element.matches && element.matches(selector)) {\n\t                    return element;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         * Finds the closest element including itself matching a given selector\n\t         * @param {Node} el\n\t         * @param selector\n\t         * @returns {Node|bool}\n\t         */\n\t    }, {\n\t        key: 'closest',\n\t        value: function closest(el, selector) {\n\t            var element = el;\n\t            while (element !== null) {\n\t                if (element.matches && element.matches(selector)) {\n\t                    return element;\n\t                }\n\t                element = element.parentNode;\n\t            }\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         * @param {HTMLElement} n\n\t         * @return {bool}\n\t         */\n\t    }, {\n\t        key: 'isMarkNode',\n\t        value: function isMarkNode(n) {\n\t            return n instanceof HTMLElement && n.hasAttribute(DATA_IS_SELECTION);\n\t        }\n\t\n\t        /**\n\t         * Determines the correct paths and excludes all `marklib` generated content\n\t         * TODO: To improve performance we could shorten the path if an ID is present in it.\n\t         * @param {HTMLElement} el\n\t         * @param {HTMLElement} [context] if given extraction path is relative to this element\n\t         * @returns {string}\n\t         */\n\t    }, {\n\t        key: 'getPath',\n\t        value: function getPath(el, context) {\n\t            var path = null,\n\t                node = el;\n\t\n\t            var filterSiblings = function filterSiblings(thisEl) {\n\t                return !Util.isMarkNode(thisEl) && thisEl.nodeName === node.nodeName;\n\t            };\n\t\n\t            while (node) {\n\t                var name = null;\n\t                // If node is a text-node, save index\n\t                if (Node.TEXT_NODE === node.nodeType) {\n\t\n\t                    /* Because nodes may wrapped inside a highlighting node, we need to find the original index that was\n\t                     * valid before the dom changes. We store the last known index position inside all wrapper elements\n\t                     * We select the outermost\n\t                     */\n\t\n\t                    // Extract original index of this node:\n\t                    // Outer most data-original-index is original index\n\t                    var outerMostElement = Util.parents(node, '[' + ATTR_DATA_ORIGINAL_INDEX + ']').reverse()[0];\n\t                    // if element is not yet wrapped in span, recalculate index based on parent container:\n\t                    // We have to do this because text node indexes != element indexes...\n\t                    var calculatedIndex = 0;\n\t                    if (!outerMostElement) {\n\t                        calculatedIndex = Util.calcIndex(node);\n\t                    }\n\t                    var index = outerMostElement ? parseInt(outerMostElement.getAttribute(ATTR_DATA_ORIGINAL_INDEX)) : calculatedIndex;\n\t                    name = SERIALIZE_SEPARATOR + index;\n\t                } else {\n\t                    name = node.nodeName;\n\t                }\n\t\n\t                if (!name) {\n\t                    break;\n\t                }\n\t\n\t                name = name.toLowerCase();\n\t\n\t                var parent = node.parentNode;\n\t\n\t                if (Util.isMarkNode(node)) {\n\t                    if (parent !== context) {\n\t                        node = parent;\n\t                        continue;\n\t                    } else {\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                // Select only siblings that are not part of selection and are of the same type\n\t                // (because we use nth-of-type selector later)\n\t                var siblings = Util.nodeListFilter(parent.children, filterSiblings),\n\t                    nodeIndex = Util.index(node, siblings);\n\t\n\t                if (siblings.length > 1 && nodeIndex >= 0) {\n\t                    name += ':nth-of-type(' + (nodeIndex + 1) + ')';\n\t                }\n\t\n\t                path = name + (path ? '>' + path : '');\n\t\n\t                if (parent === context) {\n\t                    break;\n\t                }\n\t\n\t                node = parent;\n\t            }\n\t\n\t            return path.replace(\"#document>\", \"\").replace('>;', ';');\n\t        }\n\t    }]);\n\t\n\t    return Util;\n\t})();\n\t\n\texports['default'] = Util;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports[\"default\"] = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _Object$defineProperty = __webpack_require__(7)[\"default\"];\n\t\n\texports[\"default\"] = (function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t\n\t      _Object$defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t})();\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global Node, Document */\n\t\n\t'use strict';\n\t\n\tvar _createClass = __webpack_require__(4)['default'];\n\t\n\tvar _classCallCheck = __webpack_require__(3)['default'];\n\t\n\tvar _interopRequireDefault = __webpack_require__(1)['default'];\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\tvar _utilUtil = __webpack_require__(2);\n\t\n\tvar _utilUtil2 = _interopRequireDefault(_utilUtil);\n\t\n\t/**\n\t * @type {string}\n\t */\n\tvar TAG_NAME = 'x-marker';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ORIGINAL_OFFSET_START = 'data-original-offset-start';\n\t/**\n\t * @type {string}\n\t */\n\tvar DATA_ORIGINAL_TEXT_NODE_INDEX = 'original-text-node-index';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_START_END = 'data-is-start-end';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_IS_HIGHLIGHT_NODE = 'data-is-highlight-node';\n\t/**\n\t * @type {string}\n\t */\n\tvar ATTR_DATA_ID = 'data-selection-id';\n\t\n\t/**\n\t * @see https://developer.mozilla.org/de/docs/Web/API/Node/compareDocumentPosition\n\t * @type {number}\n\t */\n\tvar DOCUMENT_POSITION_CONTAINED_BY = 16;\n\t\n\tvar Rendering = (function () {\n\t    function Rendering(document, cssClass, context) {\n\t        _classCallCheck(this, Rendering);\n\t\n\t        if (!(document instanceof Document)) {\n\t            throw 'Marklib {0} is required to be a document instance';\n\t        }\n\t        /**\n\t         * @type {Document}\n\t         */\n\t        this.document = document;\n\t\n\t        /**\n\t         * ID of rendering, will be set on each element that is part of it\n\t         * @type {String}\n\t         */\n\t        this.id = _utilUtil2['default'].guid();\n\t\n\t        /**\n\t         * Class that is set on all highlight nodes\n\t         * @type {String}\n\t         */\n\t        this.cssClass = undefined === cssClass ? 'marking' : cssClass;\n\t\n\t        /**\n\t         * StartContainer\n\t         * @type {Node}\n\t         */\n\t        this.startContainer = null;\n\t\n\t        /**\n\t         * EndContainer\n\t         * @type {Node}\n\t         */\n\t        this.endContainer = null;\n\t\n\t        /**\n\t         * Prefix before ID\n\t         * @type {string}\n\t         */\n\t        this.markerPrefix = 'marker-start-';\n\t\n\t        /**\n\t         * Suffix before ID\n\t         * @type {string}\n\t         */\n\t        this.markerSuffix = 'marker-end-';\n\t\n\t        /**\n\t         * @type {Node}\n\t         */\n\t        this.context = context || this.document;\n\t\n\t        /**\n\t         * @type {Function}\n\t         * @private\n\t         */\n\t        this._onWrappedNodeFunc = null;\n\t    }\n\t\n\t    /**\n\t     * @returns {string} id of this rendering\n\t     */\n\t\n\t    _createClass(Rendering, [{\n\t        key: 'getId',\n\t        value: function getId() {\n\t            return this.id;\n\t        }\n\t\n\t        /**\n\t         * @param {string} id\n\t         * @returns {Rendering}\n\t         */\n\t    }, {\n\t        key: 'setId',\n\t        value: function setId(id) {\n\t            this.id = id;\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Listener that is called when a node is wrapped on this instance\n\t         * @param {Function} f\n\t         * @returns {Rendering}\n\t         */\n\t    }, {\n\t        key: 'onWrappedNode',\n\t        value: function onWrappedNode(f) {\n\t            this._onWrappedNodeFunc = f;\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_callOnWrappedNode',\n\t        value: function _callOnWrappedNode() {\n\t            if (typeof this._onWrappedNodeFunc === 'function') {\n\t                this._onWrappedNodeFunc.apply(this, arguments);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @param {Node} container\n\t         * @param {Number} thisIndex\n\t         * @returns {int} index of parent or original\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_createWrapTemplate',\n\t\n\t        /**\n\t         * Creates a Template used as a wrapper\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t        value: function _createWrapTemplate() {\n\t            var el = this.document.createElement(TAG_NAME),\n\t                vTrue = \"true\";\n\t            el.className = this.cssClass;\n\t            el.setAttribute(_utilUtil.DATA_IS_SELECTION, vTrue);\n\t            el.setAttribute(ATTR_DATA_ID, this.getId());\n\t            el.setAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE, vTrue);\n\t\n\t            return el;\n\t        }\n\t\n\t        /**\n\t         * Creates a Template to use as start and end marks\n\t         * @param {String} text\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_createStartEndWrapTemplate',\n\t        value: function _createStartEndWrapTemplate(text) {\n\t            var el = this._createWrapTemplate(),\n\t                vTrue = \"true\";\n\t            el.setAttribute(ATTR_DATA_START_END, vTrue);\n\t            el.textContent = text;\n\t            return el;\n\t        }\n\t\n\t        /**\n\t         * Creates Start or End Container Element\n\t         * @param initialNode\n\t         * @param prefix\n\t         * @param text\n\t         * @param offset\n\t         * @param index\n\t         * @returns {Node}\n\t         */\n\t    }, {\n\t        key: '_createStartOrEndContainer',\n\t        value: function _createStartOrEndContainer(initialNode, prefix, text, offset, index) {\n\t            var wrapper = this._createStartEndWrapTemplate(text);\n\t            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(initialNode, index));\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n\t            wrapper.marklibInstance = this;\n\t            return wrapper;\n\t        }\n\t\n\t        /**\n\t         * Wraps given element\n\t         * @param {Node} el\n\t         * @param [optionalLength]\n\t         * @param [optionalIndex]\n\t         * @param [optionalIsSameNode]\n\t         * @returns {Node}\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_createWrap',\n\t        value: function _createWrap(el, optionalLength, optionalIndex, optionalIsSameNode) {\n\t            var originalIndex = optionalIndex >= 0 ? optionalIndex : _utilUtil2['default'].calcIndex(el);\n\t            var wrapper = this._createWrapTemplate();\n\t            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(el, originalIndex));\n\t            var offsetLength = optionalLength >= 0 ? optionalLength : Rendering._getOffsetParentIfHas(el);\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offsetLength);\n\t\n\t            // Save a reference to original text node in wrapper\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, originalIndex);\n\t\n\t            // save this marker instance to given node\n\t            wrapper.marklibInstance = this;\n\t\n\t            if (optionalIsSameNode) {\n\t                wrapper.setAttribute(ATTR_DATA_START_END, ATTR_DATA_START_END);\n\t            }\n\t            var wrap = _utilUtil2['default'].wrap(el, wrapper);\n\t            this._callOnWrappedNode(el, wrap);\n\t            return wrap;\n\t        }\n\t\n\t        /**\n\t         * Create split container element\n\t         * @param originalElement {Node} original text node element that is created a wrapper for\n\t         * @param index\n\t         * @param offset\n\t         * @returns {*|jQuery|Node}\n\t         */\n\t    }, {\n\t        key: '_createSplitContainer',\n\t        value: function _createSplitContainer(originalElement, index, offset) {\n\t            var wrapper = this.document.createElement(TAG_NAME),\n\t                vTrue = \"true\";\n\t            wrapper.setAttribute(_utilUtil.DATA_IS_SELECTION, vTrue);\n\t            wrapper.setAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(originalElement, index));\n\t            wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n\t            wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n\t            return wrapper;\n\t        }\n\t\n\t        /**\n\t         * Extracts all TextNodes inside a container\n\t         * @param {Node} el\n\t         * @returns {Array.<Text>}\n\t         */\n\t    }, {\n\t        key: '_walkTextNodes',\n\t        value: function _walkTextNodes(el, func) {\n\t            this.walkDom(el, function (node) {\n\t                if (Node.TEXT_NODE === node.nodeType && !_utilUtil2['default'].nodeIsEmpty(node)) {\n\t                    func(node);\n\t                }\n\t                return true;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Walks the tree\n\t         * @param start\n\t         * @param endContainer\n\t         * @param nextParent\n\t         */\n\t    }, {\n\t        key: 'walk',\n\t        value: function walk(start, endContainer, nextParent) {\n\t            var nextParentNode = start;\n\t            while (nextParentNode && nextParentNode !== nextParent.parentNode) {\n\t                var currentParentNode = nextParentNode;\n\t                nextParentNode = nextParentNode.parentNode;\n\t                if (this.wrapSiblings(currentParentNode.nextSibling, endContainer)) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Will Wrap all textNode siblings of a container (start) inside a defined Element (like a span)\n\t         * If an Element node is found, it will wrap all children of this node inside a element as well.\n\t         * It will stop if endContainer is found as a node\n\t         *\n\t         * @param {Node} start\n\t         * @param {Node} endContainer\n\t         * @returns {boolean} (true if endContainer was found)\n\t         */\n\t    }, {\n\t        key: 'wrapSiblings',\n\t        value: function wrapSiblings(start, endContainer) {\n\t            var _this = this;\n\t\n\t            var next = start,\n\t                found = false;\n\t\n\t            // Capsule some logic\n\t            var wrap = (function (n) {\n\t                if (n.parentNode.hasAttribute(ATTR_DATA_START_END) && n.parentNode.hasAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE) && n.parentNode.getAttribute(ATTR_DATA_ID) === _this.getId()) {\n\t                    var thisNode = _this._createWrap(n).parentNode;\n\t                    thisNode.classList.remove(_this.cssClass);\n\t                    thisNode.removeAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE);\n\t                } else {\n\t                    _this._createWrap(n);\n\t                }\n\t            }).bind(this);\n\t\n\t            // helper functions\n\t\n\t            var wrapIf = function wrapIf(n) {\n\t                if (!_utilUtil2['default'].nodeIsEmpty(n)) {\n\t                    wrap(n);\n\t                }\n\t            };\n\t\n\t            var walkIfContained = function walkIfContained(e) {\n\t                if (e === endContainer) {\n\t                    return false;\n\t                }\n\t                if (Node.TEXT_NODE === e.nodeType) {\n\t                    wrapIf(e);\n\t                }\n\t                return true;\n\t            };\n\t\n\t            var walkIfNotContained = function walkIfNotContained(el) {\n\t                wrapIf(el);\n\t            };\n\t\n\t            while (next !== null && next !== endContainer) {\n\t                var currentNext = next;\n\t                next = next.nextSibling;\n\t                // Found a text node, directly wrap inside a span\n\t                if (Node.TEXT_NODE === currentNext.nodeType) {\n\t                    wrapIf(currentNext);\n\t                } else {\n\t                    if (currentNext.compareDocumentPosition(endContainer) & DOCUMENT_POSITION_CONTAINED_BY) {\n\t                        this.walkDom(currentNext, walkIfContained);\n\t                        found = true;\n\t                    } else {\n\t                        this._walkTextNodes(currentNext, walkIfNotContained);\n\t                    }\n\t                    if (found) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            return found;\n\t        }\n\t\n\t        /**\n\t         * Recursively walks the dom tree unless func returns false\n\t         * This is a lot more efficient then using any jQuery operations\n\t         *\n\t         * Applies node to function\n\t         * @param node\n\t         * @param func\n\t         * @returns {*}\n\t         */\n\t    }, {\n\t        key: 'walkDom',\n\t        value: function walkDom(node, func) {\n\t            if (!node) {\n\t                return false;\n\t            }\n\t            var children = node.childNodes;\n\t            if (!children) {\n\t                return false;\n\t            }\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (!this.walkDom(children[i], func)) {\n\t                    return false;\n\t                }\n\t            }\n\t            return func(node);\n\t        }\n\t\n\t        /**\n\t         * Marks text of the same node\n\t         * @param {Node} textNode\n\t         * @param {int} startIndex\n\t         * @param {int} endIndex\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_markTextSameNode',\n\t        value: function _markTextSameNode(textNode, startIndex, endIndex) {\n\t\n\t            var initialText = textNode.nodeValue,\n\t                initialIndex = _utilUtil2['default'].calcIndex(textNode);\n\t\n\t            if (!initialText) {\n\t                return false;\n\t            }\n\t\n\t            //If there is an unmarked part in the beginning of the text node,\n\t            //cut off that part and put it into it's own textnode.\n\t            if (startIndex > 0) {\n\t                var textBefore = initialText.slice(0, startIndex);\n\t                textNode.parentNode.insertBefore(this.document.createTextNode(textBefore), textNode);\n\t                // wrap cutted text node:\n\t                _utilUtil2['default'].wrap(textNode.previousSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode)));\n\t            }\n\t            //If there is an unmarked part at the end of the text node,\n\t            //cut off that part and put it into it's own textnode.\n\t            if (endIndex < initialText.length) {\n\t                var textAfter = initialText.slice(endIndex, initialText.length);\n\t                textNode.parentNode.insertBefore(this.document.createTextNode(textAfter), textNode.nextSibling);\n\t                _utilUtil2['default'].wrap(textNode.nextSibling, this._createSplitContainer(textNode, initialIndex, Rendering._getOffsetParentIfHas(textNode) + endIndex));\n\t            }\n\t\n\t            //Cutoff the unmarked parts and wrap the textnode into a span.\n\t            textNode.nodeValue = initialText.slice(startIndex, endIndex);\n\t            this.startContainer = this._createWrap(textNode, Rendering._getOffsetParentIfHas(textNode) + startIndex, initialIndex, true).parentNode;\n\t            this.endContainer = this.startContainer;\n\t            return this.startContainer;\n\t        }\n\t\n\t        /**\n\t         * Marks text of end and start containers if start and end nodes are different\n\t         * Important: There might be no end container!\n\t         *\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @returns {{startT: (Node), endT: (Node)}}\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_markTextDifferentNode',\n\t        value: function _markTextDifferentNode(startContainer, endContainer, startOffset, endOffset) {\n\t            // Get current for both start and end:\n\t            var startContainerIndex = _utilUtil2['default'].calcIndex(startContainer);\n\t            var endContainerIndex = _utilUtil2['default'].calcIndex(endContainer);\n\t\n\t            // Split text\n\t            var fullTextStartValue = startContainer.nodeValue;\n\t            // init with startContainer because we may have not a text node here\n\t            var startT = startContainer;\n\t\n\t            if (undefined !== fullTextStartValue) {\n\t                var partTextStartValue = fullTextStartValue.slice(startOffset, fullTextStartValue.length);\n\t                // Set new text to start node\n\t                startContainer.nodeValue = fullTextStartValue.slice(0, startOffset);\n\t\n\t                var offsetStart = Rendering._getOffsetParentIfHas(startContainer);\n\t                // Create a new node for splitted text, offset is the length of new startContainer.nodeValue:\n\t                startT = this._createStartOrEndContainer(startContainer, this.markerPrefix, partTextStartValue, offsetStart === startOffset ? offsetStart : offsetStart + startOffset, startContainerIndex);\n\t                // Append this node after startContainer\n\t                startContainer.parentNode.insertBefore(startT, startContainer.nextSibling);\n\t                this.startContainer = startT;\n\t\n\t                if (startContainer.nodeValue) {\n\t                    // Wrap start container in detection node, offset is always 0 or parent offset.\n\t                    _utilUtil2['default'].wrap(startContainer, this._createSplitContainer(startContainer, startContainerIndex, Rendering._getOffsetParentIfHas(startContainer)));\n\t                }\n\t            }\n\t\n\t            // init with endContainer because we may have not a text node here\n\t            var endT = endContainer;\n\t\n\t            // 2. Extract end Text node,\n\t            var fullTextEndValue = endContainer.nodeValue;\n\t            // It's possible that end container value is null (if a whole paragraph is marked)\n\t            if (undefined !== fullTextEndValue) {\n\t                // Split text\n\t                var partTextEndValue = fullTextEndValue.slice(0, endOffset);\n\t                endContainer.nodeValue = fullTextEndValue.slice(endOffset, fullTextEndValue.length);\n\t                // End Container start offset is always 0 or parent offset.\n\t                endT = this._createStartOrEndContainer(endContainer, this.markerSuffix, partTextEndValue, Rendering._getOffsetParentIfHas(endContainer), endContainerIndex);\n\t\n\t                endContainer.parentNode.insertBefore(endT, endContainer);\n\t                this.endContainer = endT;\n\t                var offsetParent = Rendering._getOffsetParentIfHas(endContainer);\n\t                _utilUtil2['default'].wrap(endContainer, this._createSplitContainer(endContainer, endContainerIndex, offsetParent === endOffset ? offsetParent : offsetParent + endOffset));\n\t            }\n\t\n\t            return { startT: startT, endT: endT };\n\t        }\n\t\n\t        /**\n\t         * Will return the original first offset\n\t         * @param element\n\t         * @returns {int}\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_findOriginalOffset',\n\t        value: function _findOriginalOffset(element) {\n\t            if (!element.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n\t                return 0;\n\t            }\n\t            var lengthElement = _utilUtil2['default'].parent(element, '[' + ATTR_DATA_ORIGINAL_OFFSET_START + ']');\n\t            return lengthElement ? parseInt(lengthElement.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : 0;\n\t        }\n\t\n\t        /**\n\t         * Renders a selection\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {Node} commonAncestor\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @param {boolean} [withoutResult] if true result will not be calculated\n\t         * @returns {{startOffset: (int), endOffset: (int)}} the original offsets found\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_renderWithElements',\n\t        value: function _renderWithElements(startContainer, endContainer, commonAncestor, startOffset, endOffset, withoutResult) {\n\t            var outer = _utilUtil2['default'].parents(startContainer, commonAncestor);\n\t            outer = outer[outer.length - 1];\n\t            var contextContainer = outer ? outer : commonAncestor;\n\t\n\t            // Same Element, means the selection is fully contained in a discrete area, start and endpoint have the same parent\n\t            // but are different nodes:\n\t\n\t            // Start and End offset have to be recalculated because dom might be already changed by highlighting in given node\n\t            // 1: First detect real start offset in startContainer:\n\t\n\t            // That works by selecting the highest wrapper and get original-offset-start data element, see \"findOriginalOffset\"\n\t            // So first select that container:\n\t            var originalStartOffset = this._findOriginalOffset(startContainer);\n\t            var originalEndOffset = this._findOriginalOffset(endContainer);\n\t\n\t            // We may run into Browser Bugs:\n\t\n\t            // If both are not text nodes, use next sibling as endContainer\n\t            if (startContainer.nodeType !== Node.TEXT_NODE && endContainer.nodeType !== Node.TEXT_NODE) {\n\t                if (startContainer === endContainer) {\n\t                    endContainer = endContainer.nextElementSibling || endContainer;\n\t                }\n\t            }\n\t            // IF start/end container is not type of text, select first child text node:\n\t            // We run in some bugs with firefox here that selects no text-nodes sometimes, trying to fix this here\n\t            // Sometimes does not work correctly... (specially when DOM was modified)\n\t            if (startContainer.nodeType !== Node.TEXT_NODE) {\n\t                this.walkDom(startContainer, function (el) {\n\t                    if (el.nodeType === Node.TEXT_NODE) {\n\t                        startContainer = el;\n\t                        return false;\n\t                    }\n\t                    return true;\n\t                });\n\t            }\n\t\n\t            if (endContainer.nodeType !== Node.TEXT_NODE) {\n\t                // Get the last text node:\n\t                var endContainerContents = _utilUtil2['default'].closest(startContainer, ':not([' + _utilUtil.DATA_IS_SELECTION + '])').childNodes;\n\t                if (endContainerContents.length) {\n\t                    var r = endContainerContents[endContainerContents.length - 1];\n\t                    if (r.nodeType === Node.TEXT_NODE) {\n\t                        endContainer = r;\n\t                        endOffset = r.length;\n\t                    } else {\n\t                        var f = r.lastChild;\n\t                        while (f !== null) {\n\t                            if (f && f.nodeType === Node.TEXT_NODE) {\n\t                                endContainer = f;\n\t                                endOffset = f.length;\n\t                                if (f.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n\t                                    endOffset = parseInt(f.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) + endOffset;\n\t                                }\n\t                            }\n\t                            f = f.lastChild;\n\t                        }\n\t                    }\n\t                }\n\t                // still no textNode?\n\t                if (endContainer.nodeType !== Node.TEXT_NODE) {\n\t                    throw 'Could not found endContainer, highlighting would be unstable';\n\t                }\n\t            }\n\t\n\t            var result = withoutResult || {\n\t                // Real offset is calculated by relative length and absolute length\n\t                startOffset: originalStartOffset + startOffset,\n\t                endOffset: originalEndOffset + endOffset,\n\t                // get the path for this selection\n\t                startContainerPath: _utilUtil2['default'].getPath(startContainer, this.context),\n\t                endContainerPath: _utilUtil2['default'].getPath(endContainer, this.context)\n\t            };\n\t\n\t            this._renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer);\n\t\n\t            return result;\n\t        }\n\t\n\t        /**\n\t         * Renders a given selection\n\t         *\n\t         * @param {Node} startContainer\n\t         * @param {Node} endContainer\n\t         * @param {int} startOffset\n\t         * @param {int} endOffset\n\t         * @param {Node} contextContainer\n\t         * @param {Node} outer\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_renderSelection',\n\t        value: function _renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer) {\n\t\n\t            // if start and end-container are the same, mark text on the same node\n\t            if (startContainer === endContainer) {\n\t                this._markTextSameNode(startContainer, startOffset, endOffset);\n\t            } else {\n\t                var result = this._markTextDifferentNode(startContainer, endContainer, startOffset, endOffset);\n\t                if (!outer) {\n\t                    this.wrapSiblings(result.startT.nextSibling, endContainer);\n\t                } else {\n\t                    this.walk(result.startT, endContainer, contextContainer);\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Deserialize a specific path and finds the right textNodes\n\t         * This even works when DOM has been manipulated before by `marklib`\n\t         * @param {string} path the serialized path (including offsets)\n\t         * @return {Node}\n\t         * @private\n\t         */\n\t    }, {\n\t        key: '_deserializePath',\n\t        value: function _deserializePath(path) {\n\t            var pSplit = path.split(';'),\n\t                p = pSplit[0],\n\t                objectIndex = parseInt(pSplit[1]),\n\t                charOffset = parseInt(pSplit[2]),\n\t                container = !p.trim() ? this.context : this.context.querySelector(p);\n\t            var maybeFoundNode = null;\n\t            this.walkDom(container, function (n) {\n\t                if (n.nodeType === Node.TEXT_NODE) {\n\t                    var atrOffsetStart = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START);\n\t                    atrOffsetStart = atrOffsetStart === null ? 0 : atrOffsetStart;\n\t                    var atrIndex = n.parentNode.getAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX);\n\t                    atrIndex = atrIndex === null ? _utilUtil2['default'].calcIndex(n) : atrIndex;\n\t                    if (parseInt(atrIndex) === objectIndex && charOffset >= atrOffsetStart && parseInt(atrOffsetStart) + n.length >= charOffset) {\n\t                        var thisOffset = n.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START) ? charOffset - parseInt(n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : charOffset;\n\t                        maybeFoundNode = { node: n, offset: thisOffset };\n\t                        return false;\n\t                    }\n\t                } else {\n\t                    return true;\n\t                }\n\t                return true;\n\t            });\n\t\n\t            return maybeFoundNode;\n\t        }\n\t\n\t        /**\n\t         * Prepares to render a Selection with path selectors\n\t         * ```\n\t         * A Path looks like this:\n\t         *\n\t         * #selector;#textnode;#offset\n\t         * ``\n\t         * @param {string} startPath\n\t         * @param {string} endPath\n\t         * @returns {string}\n\t         */\n\t    }, {\n\t        key: 'renderWithPath',\n\t        value: function renderWithPath(startPath, endPath) {\n\t            var startContainer = this._deserializePath(startPath);\n\t            var endContainer = this._deserializePath(endPath);\n\t            if (startContainer && endContainer && startContainer.node && endContainer.node) {\n\t                var range = document.createRange();\n\t                range.setStart(startContainer.node, startContainer.offset);\n\t                range.setEnd(endContainer.node, endContainer.offset);\n\t                var text = range.toString();\n\t                this.renderWithRange(range, true);\n\t                return text;\n\t            }\n\t            throw 'Could not find start- and/or end-container in document';\n\t        }\n\t\n\t        /**\n\t         * Renders a result (that returned from `renderWithRange`)\n\t         * @param result\n\t         * @returns {string}\n\t         */\n\t    }, {\n\t        key: 'renderWithResult',\n\t        value: function renderWithResult(result) {\n\t            return this.renderWithPath(result.startContainerPath + ';' + result.startOffset, result.endContainerPath + ';' + result.endOffset);\n\t        }\n\t\n\t        /**\n\t         * Prepares a selection with a range object\n\t         * @param {Range} range\n\t         * @param {boolean} [withoutResult] optional do calculate a result, the selection would not be serializable\n\t         * @returns {Object}\n\t         */\n\t    }, {\n\t        key: 'renderWithRange',\n\t        value: function renderWithRange(range, withoutResult) {\n\t            return this._renderWithElements(range.startContainer, range.endContainer, range.commonAncestorContainer, range.startOffset, range.endOffset, withoutResult);\n\t        }\n\t    }], [{\n\t        key: '_getIndexParentIfHas',\n\t        value: function _getIndexParentIfHas(container, thisIndex) {\n\t            var p = container.parentNode;\n\t            var index = parseInt(p.getAttribute(_utilUtil.ATTR_DATA_ORIGINAL_INDEX));\n\t            return index > thisIndex ? index : thisIndex;\n\t        }\n\t\n\t        /**\n\t         * @param container\n\t         * @returns {int} offset start of parent if has, else 0\n\t         */\n\t    }, {\n\t        key: '_getOffsetParentIfHas',\n\t        value: function _getOffsetParentIfHas(container) {\n\t            var p = container.parentNode;\n\t            var offset = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START));\n\t            return offset > 0 ? offset : 0;\n\t        }\n\t    }]);\n\t\n\t    return Rendering;\n\t})();\n\t\n\texports['default'] = Rendering;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _interopRequireDefault = __webpack_require__(1)['default'];\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t    value: true\n\t});\n\t\n\tvar _Rendering = __webpack_require__(5);\n\t\n\tvar _Rendering2 = _interopRequireDefault(_Rendering);\n\t\n\tvar _utilUtil = __webpack_require__(2);\n\t\n\tvar _utilUtil2 = _interopRequireDefault(_utilUtil);\n\t\n\texports['default'] = {\n\t    Rendering: _Rendering2['default'],\n\t    Util: _utilUtil2['default']\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(8), __esModule: true };\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(9);\n\tmodule.exports = function defineProperty(it, key, desc){\n\t  return $.setDesc(it, key, desc);\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tvar $Object = Object;\n\tmodule.exports = {\n\t  create:     $Object.create,\n\t  getProto:   $Object.getPrototypeOf,\n\t  isEnum:     {}.propertyIsEnumerable,\n\t  getDesc:    $Object.getOwnPropertyDescriptor,\n\t  setDesc:    $Object.defineProperty,\n\t  setDescs:   $Object.defineProperties,\n\t  getKeys:    $Object.keys,\n\t  getNames:   $Object.getOwnPropertyNames,\n\t  getSymbols: $Object.getOwnPropertySymbols,\n\t  each:       [].forEach\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** js/marklib.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"../\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4c78df0762d41b78383d\n **/","\"use strict\";\n\nexports[\"default\"] = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/interop-require-default.js\n ** module id = 1\n ** module chunks = 0 1\n **/","/* global Node, NodeList, Element */\n\n'use strict';\n\n/**\n * @type {string}\n */\nexport const ATTR_DATA_ORIGINAL_INDEX = 'data-original-index';\n/**\n * @type {string}\n */\nexport const DATA_PSEUDO = 'data-is-pseudo';\n/**\n * @type {string}\n */\nexport const DATA_IS_SELECTION = 'data-is-selection';\n/**\n * @type {string}\n */\nconst SERIALIZE_SEPARATOR = \";\";\n\n// polyfill for matchesSelector, IE 10/11 does not support Element.matches\nif (Element && !Element.prototype.matches) {\n    var p = Element.prototype;\n    p.matches = p.matchesSelector ||\n        p.mozMatchesSelector || p.msMatchesSelector ||\n        p.oMatchesSelector || p.webkitMatchesSelector;\n}\n\n/**\n * Utility class\n * Contains DOM/Node manipulation helpers\n */\nexport default\nclass Util {\n    /**\n     * Filter for a NodeList\n     * @param {NodeList} nodes\n     * @param {Function} func\n     * @returns {Array.<HTMLElement>}\n     */\n    static nodeListFilter(nodes, func) {\n        return Array.prototype.filter.call(nodes || [], func);\n    }\n\n\n    /**\n     * Generates a unique id\n     * @return {String}\n     */\n    static guid() {\n        function s4() {\n            return Math.floor((1 + Math.random()) * 0x10000)\n                .toString(16)\n                .substring(1);\n        }\n\n        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n            s4() + '-' + s4() + s4() + s4();\n    }\n\n    /**\n     * Checks if a given node is empty\n     * @param {HTMLElement} node\n     * @returns {*}\n     */\n    static nodeIsEmpty(node) {\n        return node.nodeValue.match(/^[\\s]*$/g);\n    }\n\n\n    /**\n     * @param {HTMLElement} node\n     * @param [optionalList]\n     * @return {int} the index of this node in context to it's siblings\n     */\n    static index(node, optionalList) {\n        const children = optionalList || (node.nodeType === Node.TEXT_NODE ?\n                node.parentNode.childNodes : node.parentNode.children);\n        return Array.prototype.indexOf.call(children || [], node);\n    }\n\n    /**\n     * Wraps given `elms` in given `wrapper`\n     *\n     * @param {HTMLElement} wrapper\n     * @param {HTMLElement|Array.<HTMLElement>} elms\n     * @return {HTMLElement}\n     */\n    static wrap(elms, wrapper) {\n        if (!elms) {\n            return wrapper;\n        }\n        // Convert `elms` to an array, if necessary.\n        if (!(elms instanceof NodeList || elms instanceof Array)) {\n            elms = [elms];\n        }\n        for (var i = elms.length - 1; i >= 0; i--) {\n            const child = (i > 0) ? wrapper.cloneNode(true) : wrapper;\n            const el = elms[i];\n            // Cache the current parent and sibling.\n            const parent = el.parentNode, sibling = el.nextSibling;\n\n            child.appendChild(el);\n            if (sibling) {\n                parent.insertBefore(child, sibling);\n            } else {\n                parent.appendChild(child);\n            }\n        }\n        return wrapper;\n    }\n\n    /**\n     * Will calculate an index depending on an already modified dom by marklib\n     * @param {HTMLElement} node\n     * @returns {int|boolean}\n     */\n    static calcIndex(node) {\n        let calculatedIndex = 0,\n            foundWrapper = false;\n        const nodes = node.parentNode.childNodes, length = nodes.length;\n        for (let thisIndex = 0; thisIndex < length; thisIndex++) {\n            const el = nodes[thisIndex];\n            if (el === node) {\n                break;\n            }\n            // reset index when original index is found\n            const maybeIndexOfOriginal = el.getAttribute ? el.getAttribute(ATTR_DATA_ORIGINAL_INDEX) : null;\n\n            if (maybeIndexOfOriginal) {\n                calculatedIndex = parseInt(maybeIndexOfOriginal);\n                foundWrapper = true;\n            }\n            calculatedIndex++;\n        }\n        return foundWrapper ? calculatedIndex : Util.index(node);\n    }\n\n    /**\n     * @param {HTMLElement} el\n     * @param {String} [optionalSelector] will test given element against a selector\n     *  if matches, returns this element immediately\n     * @return {Array.<HTMLElement>} an array of all found parents of given element (and optional selector)\n     */\n    static parents(el, optionalSelector) {\n        let element = el;\n        const foundElements = [];\n        while (element.parentNode !== null) {\n            element = element.parentNode;\n            if (optionalSelector && ((element === optionalSelector) ||\n                ( (typeof optionalSelector === 'string') && element.matches && element.matches(optionalSelector)))) {\n                foundElements.push(element);\n            } else if (!optionalSelector) {\n                foundElements.push(element);\n            }\n        }\n        return foundElements;\n    }\n\n    /**\n     * Finds a parent node (the closest) with a given selector\n     * @param {Node} el\n     * @param {String} selector\n     * @returns {Node|bool}\n     */\n    static parent(el, selector) {\n        let element = el;\n        while (element.parentNode !== null) {\n            element = element.parentNode;\n            if (element.matches && element.matches(selector)) {\n                return element;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the closest element including itself matching a given selector\n     * @param {Node} el\n     * @param selector\n     * @returns {Node|bool}\n     */\n    static closest(el, selector) {\n        let element = el;\n        while (element !== null) {\n            if (element.matches && element.matches(selector)) {\n                return element;\n            }\n            element = element.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * @param {HTMLElement} n\n     * @return {bool}\n     */\n    static isMarkNode(n) {\n        return n instanceof HTMLElement && n.hasAttribute(DATA_IS_SELECTION);\n    }\n\n    /**\n     * Determines the correct paths and excludes all `marklib` generated content\n     * TODO: To improve performance we could shorten the path if an ID is present in it.\n     * @param {HTMLElement} el\n     * @param {HTMLElement} [context] if given extraction path is relative to this element\n     * @returns {string}\n     */\n    static getPath(el, context) {\n        var path = null, node = el;\n\n        const filterSiblings = (thisEl) => {\n            return !Util.isMarkNode(thisEl) && thisEl.nodeName === node.nodeName;\n        };\n\n        while (node) {\n            var name = null;\n            // If node is a text-node, save index\n            if (Node.TEXT_NODE === node.nodeType) {\n\n                /* Because nodes may wrapped inside a highlighting node, we need to find the original index that was\n                 * valid before the dom changes. We store the last known index position inside all wrapper elements\n                 * We select the outermost\n                 */\n\n                // Extract original index of this node:\n                // Outer most data-original-index is original index\n                const outerMostElement = Util.parents(node, '[' + ATTR_DATA_ORIGINAL_INDEX + ']').reverse()[0];\n                // if element is not yet wrapped in span, recalculate index based on parent container:\n                // We have to do this because text node indexes != element indexes...\n                let calculatedIndex = 0;\n                if (!outerMostElement) {\n                    calculatedIndex = Util.calcIndex(node);\n                }\n                const index = outerMostElement ? parseInt(\n                    outerMostElement.getAttribute(ATTR_DATA_ORIGINAL_INDEX)) : calculatedIndex;\n                name = SERIALIZE_SEPARATOR + index;\n            } else {\n                name = node.nodeName;\n            }\n\n            if (!name) {\n                break;\n            }\n\n            name = name.toLowerCase();\n\n            var parent = node.parentNode;\n\n            if (Util.isMarkNode(node)) {\n                if(parent !== context) {\n                    node = parent;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            // Select only siblings that are not part of selection and are of the same type\n            // (because we use nth-of-type selector later)\n            const siblings = Util.nodeListFilter(parent.children, filterSiblings),\n                nodeIndex = Util.index(node, siblings);\n\n            if (siblings.length > 1 && nodeIndex >= 0) {\n                name += ':nth-of-type(' + (nodeIndex + 1) + ')';\n            }\n\n            path = name + (path ? '>' + path : '');\n\n\n            if (parent === context) {\n                break;\n            }\n\n            node = parent;\n        }\n\n        return path.replace(\"#document>\", \"\").replace('>;', ';');\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/main/util/Util.js\n **/","\"use strict\";\n\nexports[\"default\"] = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/class-call-check.js\n ** module id = 3\n ** module chunks = 0 1\n **/","\"use strict\";\n\nvar _Object$defineProperty = require(\"babel-runtime/core-js/object/define-property\")[\"default\"];\n\nexports[\"default\"] = (function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n\n      _Object$defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n})();\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/create-class.js\n ** module id = 4\n ** module chunks = 0 1\n **/","/* global Node, Document */\n\n'use strict';\n\nimport Util from 'util/Util';\n\nimport {ATTR_DATA_ORIGINAL_INDEX, DATA_IS_SELECTION} from 'util/Util';\n\n/**\n * @type {string}\n */\nconst TAG_NAME = 'x-marker';\n/**\n * @type {string}\n */\nconst ATTR_DATA_ORIGINAL_OFFSET_START = 'data-original-offset-start';\n/**\n * @type {string}\n */\nconst DATA_ORIGINAL_TEXT_NODE_INDEX = 'original-text-node-index';\n/**\n * @type {string}\n */\nconst ATTR_DATA_START_END = 'data-is-start-end';\n/**\n * @type {string}\n */\nconst ATTR_DATA_IS_HIGHLIGHT_NODE = 'data-is-highlight-node';\n/**\n * @type {string}\n */\nconst ATTR_DATA_ID = 'data-selection-id';\n\n/**\n * @see https://developer.mozilla.org/de/docs/Web/API/Node/compareDocumentPosition\n * @type {number}\n */\nconst DOCUMENT_POSITION_CONTAINED_BY = 16;\n\nexport default\nclass Rendering {\n\n    constructor(document, cssClass, context) {\n\n        if (!(document instanceof Document)) {\n            throw 'Marklib {0} is required to be a document instance';\n        }\n        /**\n         * @type {Document}\n         */\n        this.document = document;\n\n        /**\n         * ID of rendering, will be set on each element that is part of it\n         * @type {String}\n         */\n        this.id = Util.guid();\n\n        /**\n         * Class that is set on all highlight nodes\n         * @type {String}\n         */\n        this.cssClass = undefined === cssClass ? 'marking' : cssClass;\n\n        /**\n         * StartContainer\n         * @type {Node}\n         */\n        this.startContainer = null;\n\n        /**\n         * EndContainer\n         * @type {Node}\n         */\n        this.endContainer = null;\n\n        /**\n         * Prefix before ID\n         * @type {string}\n         */\n        this.markerPrefix = 'marker-start-';\n\n        /**\n         * Suffix before ID\n         * @type {string}\n         */\n        this.markerSuffix = 'marker-end-';\n\n        /**\n         * @type {Node}\n         */\n        this.context = context || this.document;\n\n        /**\n         * @type {Function}\n         * @private\n         */\n        this._onWrappedNodeFunc = null;\n    }\n\n    /**\n     * @returns {string} id of this rendering\n     */\n    getId() {\n        return this.id;\n    }\n\n    /**\n     * @param {string} id\n     * @returns {Rendering}\n     */\n    setId(id) {\n        this.id = id;\n        return this;\n    }\n\n    /**\n     * Listener that is called when a node is wrapped on this instance\n     * @param {Function} f\n     * @returns {Rendering}\n     */\n    onWrappedNode(f) {\n        this._onWrappedNodeFunc = f;\n        return this;\n    }\n\n    /**\n     * @private\n     */\n    _callOnWrappedNode() {\n        if (typeof this._onWrappedNodeFunc === 'function') {\n            this._onWrappedNodeFunc.apply(this, arguments);\n        }\n    }\n\n\n    /**\n     * @param {Node} container\n     * @param {Number} thisIndex\n     * @returns {int} index of parent or original\n     * @private\n     */\n    static _getIndexParentIfHas(container, thisIndex) {\n        var p = container.parentNode;\n        var index = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_INDEX));\n        return index > thisIndex ? index : thisIndex;\n    }\n\n    /**\n     * @param container\n     * @returns {int} offset start of parent if has, else 0\n     */\n    static _getOffsetParentIfHas(container) {\n        var p = container.parentNode;\n        var offset = parseInt(p.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START));\n        return offset > 0 ? offset : 0;\n    }\n\n    /**\n     * Creates a Template used as a wrapper\n     * @returns {Node}\n     * @private\n     */\n    _createWrapTemplate() {\n        var el = this.document.createElement(TAG_NAME), vTrue = \"true\";\n        el.className = this.cssClass;\n        el.setAttribute(DATA_IS_SELECTION, vTrue);\n        el.setAttribute(ATTR_DATA_ID, this.getId());\n        el.setAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE, vTrue);\n\n        return el;\n    }\n\n    /**\n     * Creates a Template to use as start and end marks\n     * @param {String} text\n     * @returns {Node}\n     * @private\n     */\n    _createStartEndWrapTemplate(text) {\n        var el = this._createWrapTemplate(), vTrue = \"true\";\n        el.setAttribute(ATTR_DATA_START_END, vTrue);\n        el.textContent = text;\n        return el;\n    }\n\n\n    /**\n     * Creates Start or End Container Element\n     * @param initialNode\n     * @param prefix\n     * @param text\n     * @param offset\n     * @param index\n     * @returns {Node}\n     */\n    _createStartOrEndContainer(initialNode, prefix, text, offset, index) {\n        const wrapper = this._createStartEndWrapTemplate(text);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(initialNode, index));\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n        wrapper.marklibInstance = this;\n        return wrapper;\n    }\n\n    /**\n     * Wraps given element\n     * @param {Node} el\n     * @param [optionalLength]\n     * @param [optionalIndex]\n     * @param [optionalIsSameNode]\n     * @returns {Node}\n     * @private\n     */\n    _createWrap(el, optionalLength, optionalIndex, optionalIsSameNode) {\n        const originalIndex = optionalIndex >= 0 ? optionalIndex : Util.calcIndex(el);\n        const wrapper = this._createWrapTemplate();\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(el, originalIndex));\n        const offsetLength = optionalLength >= 0 ? optionalLength : Rendering._getOffsetParentIfHas(el);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offsetLength);\n\n        // Save a reference to original text node in wrapper\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, originalIndex);\n\n        // save this marker instance to given node\n        wrapper.marklibInstance = this;\n\n        if (optionalIsSameNode) {\n            wrapper.setAttribute(ATTR_DATA_START_END, ATTR_DATA_START_END);\n        }\n        const wrap = Util.wrap(el, wrapper);\n        this._callOnWrappedNode(el, wrap);\n        return wrap;\n    }\n\n    /**\n     * Create split container element\n     * @param originalElement {Node} original text node element that is created a wrapper for\n     * @param index\n     * @param offset\n     * @returns {*|jQuery|Node}\n     */\n    _createSplitContainer(originalElement, index, offset) {\n        const wrapper = this.document.createElement(TAG_NAME), vTrue = \"true\";\n        wrapper.setAttribute(DATA_IS_SELECTION, vTrue);\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_INDEX, Rendering._getIndexParentIfHas(originalElement, index));\n        wrapper.setAttribute(ATTR_DATA_ORIGINAL_OFFSET_START, offset);\n        wrapper.setAttribute(DATA_ORIGINAL_TEXT_NODE_INDEX, index);\n        return wrapper;\n    }\n\n    /**\n     * Extracts all TextNodes inside a container\n     * @param {Node} el\n     * @returns {Array.<Text>}\n     */\n    _walkTextNodes(el, func) {\n        this.walkDom(el, function (node) {\n            if (Node.TEXT_NODE === node.nodeType && !Util.nodeIsEmpty(node)) {\n                func(node);\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Walks the tree\n     * @param start\n     * @param endContainer\n     * @param nextParent\n     */\n    walk(start, endContainer, nextParent) {\n        let nextParentNode = start;\n        while (nextParentNode && nextParentNode !== nextParent.parentNode) {\n            var currentParentNode = nextParentNode;\n            nextParentNode = nextParentNode.parentNode;\n            if (this.wrapSiblings(currentParentNode.nextSibling, endContainer)) {\n                break;\n            }\n        }\n    }\n\n\n    /**\n     * Will Wrap all textNode siblings of a container (start) inside a defined Element (like a span)\n     * If an Element node is found, it will wrap all children of this node inside a element as well.\n     * It will stop if endContainer is found as a node\n     *\n     * @param {Node} start\n     * @param {Node} endContainer\n     * @returns {boolean} (true if endContainer was found)\n     */\n    wrapSiblings(start, endContainer) {\n        let next = start,\n            found = false;\n\n        // Capsule some logic\n        const wrap = ((n) => {\n            if (n.parentNode.hasAttribute(ATTR_DATA_START_END) &&\n                n.parentNode.hasAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE) &&\n                n.parentNode.getAttribute(ATTR_DATA_ID) === this.getId()) {\n                let thisNode = this._createWrap(n).parentNode;\n                thisNode.classList.remove(this.cssClass);\n                thisNode.removeAttribute(ATTR_DATA_IS_HIGHLIGHT_NODE);\n            } else {\n                this._createWrap(n);\n            }\n        }).bind(this);\n\n        // helper functions\n\n        const wrapIf = (n) => {\n            if (!Util.nodeIsEmpty(n)) {\n                wrap(n);\n            }\n        };\n\n        const walkIfContained = (e) => {\n            if (e === endContainer) {\n                return false;\n            }\n            if (Node.TEXT_NODE === e.nodeType) {\n                wrapIf(e);\n            }\n            return true;\n        };\n\n        const walkIfNotContained = (el) => {\n            wrapIf(el);\n        };\n\n        while (next !== null && next !== endContainer) {\n            var currentNext = next;\n            next = next.nextSibling;\n            // Found a text node, directly wrap inside a span\n            if (Node.TEXT_NODE === currentNext.nodeType) {\n                wrapIf(currentNext);\n            } else {\n                if ((currentNext.compareDocumentPosition(endContainer) & DOCUMENT_POSITION_CONTAINED_BY)) {\n                    this.walkDom(currentNext, walkIfContained);\n                    found = true;\n                } else {\n                    this._walkTextNodes(currentNext, walkIfNotContained);\n                }\n                if (found) {\n                    return true;\n                }\n            }\n        }\n        return found;\n    }\n\n    /**\n     * Recursively walks the dom tree unless func returns false\n     * This is a lot more efficient then using any jQuery operations\n     *\n     * Applies node to function\n     * @param node\n     * @param func\n     * @returns {*}\n     */\n    walkDom(node, func) {\n        if (!node) {\n            return false;\n        }\n        const children = node.childNodes;\n        if (!children) {\n            return false;\n        }\n        for (var i = 0; i < children.length; i++) {\n            if (!this.walkDom(children[i], func)) {\n                return false;\n            }\n        }\n        return func(node);\n    }\n\n    /**\n     * Marks text of the same node\n     * @param {Node} textNode\n     * @param {int} startIndex\n     * @param {int} endIndex\n     * @private\n     */\n    _markTextSameNode(textNode, startIndex, endIndex) {\n\n        const initialText = textNode.nodeValue,\n            initialIndex = Util.calcIndex(textNode);\n\n        if (!initialText) {\n            return false;\n        }\n\n        //If there is an unmarked part in the beginning of the text node,\n        //cut off that part and put it into it's own textnode.\n        if (startIndex > 0) {\n            const textBefore = initialText.slice(0, startIndex);\n            textNode.parentNode.insertBefore(this.document.createTextNode(textBefore), textNode);\n            // wrap cutted text node:\n            Util.wrap(textNode.previousSibling, this._createSplitContainer(textNode,\n                initialIndex, Rendering._getOffsetParentIfHas(textNode)));\n        }\n        //If there is an unmarked part at the end of the text node,\n        //cut off that part and put it into it's own textnode.\n        if (endIndex < initialText.length) {\n            const textAfter = initialText.slice(endIndex, initialText.length);\n            textNode.parentNode.insertBefore(this.document.createTextNode(textAfter), textNode.nextSibling);\n            Util.wrap(textNode.nextSibling, this._createSplitContainer(textNode,\n                initialIndex, Rendering._getOffsetParentIfHas(textNode) + endIndex));\n        }\n\n        //Cutoff the unmarked parts and wrap the textnode into a span.\n        textNode.nodeValue = initialText.slice(startIndex, endIndex);\n        this.startContainer = this._createWrap(textNode,\n            Rendering._getOffsetParentIfHas(textNode) + startIndex, initialIndex, true).parentNode;\n        this.endContainer = this.startContainer;\n        return this.startContainer;\n    }\n\n\n    /**\n     * Marks text of end and start containers if start and end nodes are different\n     * Important: There might be no end container!\n     *\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @returns {{startT: (Node), endT: (Node)}}\n     * @private\n     */\n    _markTextDifferentNode(startContainer, endContainer, startOffset, endOffset) {\n        // Get current for both start and end:\n        const startContainerIndex = Util.calcIndex(startContainer);\n        const endContainerIndex = Util.calcIndex(endContainer);\n\n        // Split text\n        const fullTextStartValue = startContainer.nodeValue;\n        // init with startContainer because we may have not a text node here\n        let startT = startContainer;\n\n        if (undefined !== fullTextStartValue) {\n            var partTextStartValue = fullTextStartValue.slice(startOffset, fullTextStartValue.length);\n            // Set new text to start node\n            startContainer.nodeValue = fullTextStartValue.slice(0, startOffset);\n\n            var offsetStart = Rendering._getOffsetParentIfHas(startContainer);\n            // Create a new node for splitted text, offset is the length of new startContainer.nodeValue:\n            startT = this._createStartOrEndContainer(startContainer, this.markerPrefix, partTextStartValue,\n                offsetStart === startOffset ? offsetStart : offsetStart + startOffset, startContainerIndex);\n            // Append this node after startContainer\n            startContainer.parentNode.insertBefore(startT, startContainer.nextSibling);\n            this.startContainer = startT;\n\n            if (startContainer.nodeValue) {\n                // Wrap start container in detection node, offset is always 0 or parent offset.\n                Util.wrap(startContainer, this._createSplitContainer(startContainer, startContainerIndex,\n                    Rendering._getOffsetParentIfHas(startContainer)));\n            }\n        }\n\n        // init with endContainer because we may have not a text node here\n        let endT = endContainer;\n\n        // 2. Extract end Text node,\n        const fullTextEndValue = endContainer.nodeValue;\n        // It's possible that end container value is null (if a whole paragraph is marked)\n        if (undefined !== fullTextEndValue) {\n            // Split text\n            var partTextEndValue = fullTextEndValue.slice(0, endOffset);\n            endContainer.nodeValue = fullTextEndValue.slice(endOffset, fullTextEndValue.length);\n            // End Container start offset is always 0 or parent offset.\n            endT = this._createStartOrEndContainer(endContainer, this.markerSuffix, partTextEndValue,\n                Rendering._getOffsetParentIfHas(endContainer), endContainerIndex);\n\n            endContainer.parentNode.insertBefore(endT, endContainer);\n            this.endContainer = endT;\n            var offsetParent = Rendering._getOffsetParentIfHas(endContainer);\n            Util.wrap(endContainer, this._createSplitContainer(endContainer, endContainerIndex,\n                offsetParent === endOffset ? offsetParent : offsetParent + endOffset));\n        }\n\n        return {startT: startT, endT: endT};\n    }\n\n    /**\n     * Will return the original first offset\n     * @param element\n     * @returns {int}\n     * @private\n     */\n    _findOriginalOffset(element) {\n        if (!element.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n            return 0;\n        }\n        const lengthElement = Util.parent(element, '[' + ATTR_DATA_ORIGINAL_OFFSET_START + ']');\n        return lengthElement ? parseInt(lengthElement.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : 0;\n    }\n\n    /**\n     * Renders a selection\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {Node} commonAncestor\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @param {boolean} [withoutResult] if true result will not be calculated\n     * @returns {{startOffset: (int), endOffset: (int)}} the original offsets found\n     * @private\n     */\n    _renderWithElements(startContainer, endContainer, commonAncestor, startOffset, endOffset, withoutResult) {\n        let outer = Util.parents(startContainer, commonAncestor);\n        outer = outer[outer.length - 1];\n        const contextContainer = outer ? outer : commonAncestor;\n\n        // Same Element, means the selection is fully contained in a discrete area, start and endpoint have the same parent\n        // but are different nodes:\n\n        // Start and End offset have to be recalculated because dom might be already changed by highlighting in given node\n        // 1: First detect real start offset in startContainer:\n\n        // That works by selecting the highest wrapper and get original-offset-start data element, see \"findOriginalOffset\"\n        // So first select that container:\n        const originalStartOffset = this._findOriginalOffset(startContainer);\n        const originalEndOffset = this._findOriginalOffset(endContainer);\n\n        // We may run into Browser Bugs:\n\n        // If both are not text nodes, use next sibling as endContainer\n        if (startContainer.nodeType !== Node.TEXT_NODE && endContainer.nodeType !== Node.TEXT_NODE) {\n            if (startContainer === endContainer) {\n                endContainer = endContainer.nextElementSibling || endContainer;\n            }\n        }\n        // IF start/end container is not type of text, select first child text node:\n        // We run in some bugs with firefox here that selects no text-nodes sometimes, trying to fix this here\n        // Sometimes does not work correctly... (specially when DOM was modified)\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            this.walkDom(startContainer, function (el) {\n                if (el.nodeType === Node.TEXT_NODE) {\n                    startContainer = el;\n                    return false;\n                }\n                return true;\n            });\n        }\n\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            // Get the last text node:\n            const endContainerContents = Util.closest(startContainer, ':not([' + DATA_IS_SELECTION + '])').childNodes;\n            if (endContainerContents.length) {\n                const r = endContainerContents[endContainerContents.length - 1];\n                if (r.nodeType === Node.TEXT_NODE) {\n                    endContainer = r;\n                    endOffset = r.length;\n                } else {\n                    let f = r.lastChild;\n                    while (f !== null) {\n                        if (f && f.nodeType === Node.TEXT_NODE) {\n                            endContainer = f;\n                            endOffset = f.length;\n                            if (f.parentNode.hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) {\n                                endOffset = parseInt(f.parentNode\n                                        .getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) + endOffset;\n                            }\n                        }\n                        f = f.lastChild;\n                    }\n                }\n            }\n            // still no textNode?\n            if (endContainer.nodeType !== Node.TEXT_NODE) {\n                throw 'Could not found endContainer, highlighting would be unstable';\n            }\n        }\n\n        var result = withoutResult || {\n                // Real offset is calculated by relative length and absolute length\n                startOffset: originalStartOffset + startOffset,\n                endOffset: originalEndOffset + endOffset,\n                // get the path for this selection\n                startContainerPath: Util.getPath(startContainer, this.context),\n                endContainerPath: Util.getPath(endContainer, this.context)\n            };\n\n        this._renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer);\n\n        return result;\n    }\n\n    /**\n     * Renders a given selection\n     *\n     * @param {Node} startContainer\n     * @param {Node} endContainer\n     * @param {int} startOffset\n     * @param {int} endOffset\n     * @param {Node} contextContainer\n     * @param {Node} outer\n     * @private\n     */\n    _renderSelection(startContainer, endContainer, startOffset, endOffset, contextContainer, outer) {\n\n        // if start and end-container are the same, mark text on the same node\n        if (startContainer === endContainer) {\n            this._markTextSameNode(startContainer, startOffset, endOffset);\n        } else {\n            var result = this._markTextDifferentNode(startContainer, endContainer, startOffset, endOffset);\n            if (!outer) {\n                this.wrapSiblings(result.startT.nextSibling, endContainer);\n            } else {\n                this.walk(result.startT, endContainer, contextContainer);\n            }\n        }\n    }\n\n\n    /**\n     * Deserialize a specific path and finds the right textNodes\n     * This even works when DOM has been manipulated before by `marklib`\n     * @param {string} path the serialized path (including offsets)\n     * @return {Node}\n     * @private\n     */\n    _deserializePath(path) {\n        const pSplit = path.split(';'), p = pSplit[0],\n            objectIndex = parseInt(pSplit[1]),\n            charOffset = parseInt(pSplit[2]),\n            container = !p.trim() ? this.context : this.context.querySelector(p);\n        let maybeFoundNode = null;\n        this.walkDom(container, function (n) {\n            if (n.nodeType === Node.TEXT_NODE) {\n                var atrOffsetStart = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START);\n                atrOffsetStart = atrOffsetStart === null ? 0 : atrOffsetStart;\n                var atrIndex = n.parentNode.getAttribute(ATTR_DATA_ORIGINAL_INDEX);\n                atrIndex = atrIndex === null ? Util.calcIndex(n) : atrIndex;\n                if (parseInt(atrIndex) === objectIndex && charOffset >= atrOffsetStart &&\n                    ((parseInt(atrOffsetStart) + n.length) >= charOffset)) {\n                    var thisOffset = n.parentNode\n                        .hasAttribute(ATTR_DATA_ORIGINAL_OFFSET_START) ? charOffset -\n                    parseInt(n.parentNode\n                        .getAttribute(ATTR_DATA_ORIGINAL_OFFSET_START)) : charOffset;\n                    maybeFoundNode = {node: n, offset: thisOffset};\n                    return false;\n                }\n            } else {\n                return true;\n            }\n            return true;\n        });\n\n        return maybeFoundNode;\n    }\n\n    /**\n     * Prepares to render a Selection with path selectors\n     * ```\n     * A Path looks like this:\n     *\n     * #selector;#textnode;#offset\n     * ``\n     * @param {string} startPath\n     * @param {string} endPath\n     * @returns {string}\n     */\n    renderWithPath(startPath, endPath) {\n        const startContainer = this._deserializePath(startPath);\n        const endContainer = this._deserializePath(endPath);\n        if (startContainer && endContainer && startContainer.node && endContainer.node) {\n            var range = document.createRange();\n            range.setStart(startContainer.node, startContainer.offset);\n            range.setEnd(endContainer.node, endContainer.offset);\n            const text = range.toString();\n            this.renderWithRange(range, true);\n            return text;\n        }\n        throw 'Could not find start- and/or end-container in document';\n    }\n\n    /**\n     * Renders a result (that returned from `renderWithRange`)\n     * @param result\n     * @returns {string}\n     */\n    renderWithResult(result) {\n        return this.renderWithPath(\n            `${result.startContainerPath};${result.startOffset}`,\n            `${result.endContainerPath};${result.endOffset}`);\n    }\n\n\n    /**\n     * Prepares a selection with a range object\n     * @param {Range} range\n     * @param {boolean} [withoutResult] optional do calculate a result, the selection would not be serializable\n     * @returns {Object}\n     */\n    renderWithRange(range, withoutResult) {\n        return this._renderWithElements(range.startContainer, range.endContainer,\n            range.commonAncestorContainer, range.startOffset, range.endOffset, withoutResult);\n    }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/main/Rendering.js\n **/","'use strict';\n\nimport Rendering from 'Rendering';\nimport Util from 'util/Util';\n\nexport default {\n    Rendering: Rendering,\n    Util: Util\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/main/modules/Marklib.js\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/define-property.js\n ** module id = 7\n ** module chunks = 0 1\n **/","var $ = require('../../modules/$');\nmodule.exports = function defineProperty(it, key, desc){\n  return $.setDesc(it, key, desc);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/fn/object/define-property.js\n ** module id = 8\n ** module chunks = 0 1\n **/","var $Object = Object;\nmodule.exports = {\n  create:     $Object.create,\n  getProto:   $Object.getPrototypeOf,\n  isEnum:     {}.propertyIsEnumerable,\n  getDesc:    $Object.getOwnPropertyDescriptor,\n  setDesc:    $Object.defineProperty,\n  setDescs:   $Object.defineProperties,\n  getKeys:    $Object.keys,\n  getNames:   $Object.getOwnPropertyNames,\n  getSymbols: $Object.getOwnPropertySymbols,\n  each:       [].forEach\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.js\n ** module id = 9\n ** module chunks = 0 1\n **/"],"sourceRoot":""}